"use strict";(self.webpackChunk_localrepo_benjie_dev=self.webpackChunk_localrepo_benjie_dev||[]).push([[5173],{5121:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>h,contentTitle:()=>d,default:()=>g,frontMatter:()=>o,metadata:()=>c,toc:()=>p});var t=r(5893),i=r(1151);const a=r.p+"assets/images/legacy-app-widget-error-f6a951aaa00bd77625edcfdb4e39acc0.png",l=r.p+"assets/images/legacy-app-fullscreen-error-e5127ef2c205d1091652a777bdc4ba94.png",s=r.p+"assets/images/everyones-happy-6d890589e55871ad639a56c800648cf7.png",o={type:"page",title:"Nullability",description:"The past and future of GraphQL nullability, according to Benjie",tag:"graphql",author:"Benjie",breadcrumb:!1,sidebar_position:35},d=void 0,c={id:"graphql/nullability/index",title:"Nullability",description:"The past and future of GraphQL nullability, according to Benjie",source:"@site/pages/graphql/nullability/index.mdx",sourceDirName:"graphql/nullability",slug:"/graphql/nullability/",permalink:"/graphql/nullability/",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:35,frontMatter:{type:"page",title:"Nullability",description:"The past and future of GraphQL nullability, according to Benjie",tag:"graphql",author:"Benjie",breadcrumb:!1,sidebar_position:35},sidebar:"defaultSidebar",previous:{title:"Naming Conventions",permalink:"/graphql/naming"},next:{title:"WG Status",permalink:"/graphql/nullability/status"}},h={},p=[{value:"The status quo",id:"the-status-quo",level:2},{value:"By default, data doesn&#39;t exist",id:"by-default-data-doesnt-exist",level:3},{value:"Partial success",id:"partial-success",level:3},{value:"Error propagation (aka null bubbling)",id:"error-propagation-aka-null-bubbling",level:3},{value:"Schema best practice?",id:"schema-best-practice",level:3},{value:"The future of GraphQL nullability!",id:"the-future-of-graphql-nullability",level:2},{value:"Handling errors on the client",id:"handling-errors-on-the-client",level:3},{value:"Disabling error propagation and reflecting true nullability",id:"disabling-error-propagation-and-reflecting-true-nullability",level:3},{value:"Supporting legacy clients",id:"supporting-legacy-clients",level:3},{value:"The &quot;transitional non-null&quot; type",id:"the-transitional-non-null-type",level:3},{value:"New schema? New field? No legacy clients? No asterisk needed!",id:"new-schema-new-field-no-legacy-clients-no-asterisk-needed",level:3}];function u(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...e.components},{Details:r}=n;return r||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"This article reflects Benjie's opinions on the past and the future of\nNullability in GraphQL; but note that these are merely opinions."})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Here's a 60 second summary of this article:"}),"\n",(0,t.jsx)("iframe",{width:"315",height:"560",src:"https://www.youtube.com/embed/gYnVaZz-19A",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0}),"\n",(0,t.jsx)(n.h2,{id:"the-status-quo",children:"The status quo"}),"\n",(0,t.jsx)(n.admonition,{title:"Already familiar with GraphQL's error handling?",type:"tip",children:(0,t.jsxs)(n.p,{children:["\u23e9 Jump to ",(0,t.jsx)(n.a,{href:"#handling-errors-on-the-client",children:"Handling errors on the client"})," for the\nproposed changes to GraphQL."]})}),"\n",(0,t.jsx)(n.h3,{id:"by-default-data-doesnt-exist",children:"By default, data doesn't exist"}),"\n",(0,t.jsxs)(n.p,{children:["In mathematics and in many programming languages we use ",(0,t.jsx)(n.code,{children:"null"})," to represent data\nthat doesn't exist (let's not get into JavaScript...)."]}),"\n",(0,t.jsxs)(n.p,{children:["The original SQL standard factored this knowledge into its design, so an ",(0,t.jsx)(n.code,{children:"int"}),'\ncolumn in SQL means "an integer or null". To represent a non-nullable integer\nyou would add a type narrowing constraint, such as ',(0,t.jsx)(n.code,{children:"int not null"}),'. This pattern\nof the type including null unless otherwise constrained is called "',(0,t.jsx)(n.strong,{children:"nullable by\ndefault"}),'".']}),"\n",(0,t.jsx)(n.p,{children:'GraphQL is similar, types are nullable by default. To narrow a type to exclude\nnull, we add a "non null" wrapper, indicated in the GraphQL language by an\nexclamation point:'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",metastring:'title="Initial schema"',children:"type User {\n  name: String! # Definitely a string, never null\n}\n\ntype Query {\n  you: User! # Definitely a User, never null\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"partial-success",children:"Partial success"}),"\n",(0,t.jsx)(n.p,{children:'Resiliency was a key design goal of GraphQL. When working on the newsfeed,\nFacebook wanted to ensure that any temporary interruptions in one part of the\nsystem would not impact on other parts and cause user outages. Instead, they\nwanted GraphQL to enable "partial success" where as much data as possible would\nbe rendered to the user.'}),"\n",(0,t.jsxs)(n.p,{children:['To enable this resiliency, when GraphQL meets an error it notes where it was,\nadds it to the "errors" list, and replaces the output data with ',(0,t.jsx)(n.code,{children:"null"}),":"]}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:"Schema and query (click to show/hide)"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",metastring:'title="Query type"',children:"type Query {\n  you: User!\n  me: User\n}\n"})}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",metastring:'title="Query"',children:"query Q {\n  you {\n    name\n  }\n  me {\n    name\n  }\n}\n"})})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",metastring:'title="Response"',children:'{\n  "data": {\n    "you": {\n      "name": "Jo"\n    },\n    "me": null // < An error occurred, see `errors`\n  },\n  "errors": [\n    {\n      "path": ["me"],\n      "message": "Not logged in"\n    }\n  ]\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"But what if a non-null field errors? If we placed a null in that position,\nwouldn't that be a contradiction?"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",metastring:'title="Query type"',children:"type Query {\n  you: User!\n  me: User! # How does non-null interact with errors?\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"error-propagation-aka-null-bubbling",children:"Error propagation (aka null bubbling)"}),"\n",(0,t.jsx)(n.p,{children:'To keep the non-null promise, GraphQL decided to perform a behavior it terms\n"error propagation" but most people refer to as "null bubbling" - it would throw\nthe error and catch it at the next nullable position (or the operation root if\nno such position existed).'}),"\n",(0,t.jsxs)(n.p,{children:['The end result: GraphQL will destroy result data outside of the field that\nfailed in order to keep non-null promises. No wonder Facebook call the non-null\ntype "',(0,t.jsx)(n.strong,{children:"kills parent on exception"}),'"!']}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",metastring:'title="Response"',children:'{\n  "data": null,\n  //     \ud83d\udc46 All of the data was destroyed, even the unrelated `you` field!\n  "errors": [\n    {\n      "path": ["me"],\n      "message": "Not logged in"\n    }\n  ]\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"schema-best-practice",children:"Schema best practice?"}),"\n",(0,t.jsx)(n.p,{children:"So when designing schemas it has been best practice to make fields nullable\nunless we're fairly certain they won't error. This allows the client to retain\nits resilience to errors, by rendering partially successful data."}),"\n",(0,t.jsx)(n.p,{children:"But having null checks throughout our client sucks!"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"if (data.me) {\n  return <User user={data.me} />;\n} else {\n  // TODO: determine if this was an error null,\n  // or just a non-existent user.\n  return <NotFoundOrError />;\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"the-future-of-graphql-nullability",children:"The future of GraphQL nullability!"}),"\n",(0,t.jsx)(n.h3,{id:"handling-errors-on-the-client",children:"Handling errors on the client"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/graphile/graphql-toe",children:(0,t.jsx)(n.code,{children:"graphql-toe"})})," is an npm module that\nuses getters to reproduce server errors on the client by throwing when an\nerrored field is accessed:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'import { toe } from "graphql-toe";\nimport { gql, request } from "graffle";\n\nconst response = await request("/graphql", document);\nconst dataAndErrors = toe(response);\n\ndataAndErrors.you; // Returns {"name": "Jo"}\ndataAndErrors.me; // \u203c\ufe0f throws Error("Log in!") \u203c\ufe0f\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"graphql-toe"})," can be integrated into many frameworks in the JS ecosystem (Apollo\nClient, urql, graffle, ",(0,t.jsx)(n.code,{children:"fetch()"}),"), but other frameworks may have their own\nnative error handling (e.g. Relay has the\n",(0,t.jsxs)(n.a,{href:"https://relay.dev/docs/guides/throw-on-field-error-directive/",children:[(0,t.jsx)(n.code,{children:"@throwOnFieldError"})," directive"]}),"\nwhich can be applied to fragments)."]}),"\n",(0,t.jsxs)(n.p,{children:["By recombining ",(0,t.jsx)(n.code,{children:"errors"})," back into ",(0,t.jsx)(n.code,{children:"data"})," we no longer need GraphQL to bubble\nnulls to keep its promise; since a ",(0,t.jsx)(n.code,{children:"null"})," can never be read from an errored\nposition."]}),"\n",(0,t.jsxs)(n.p,{children:['An "',(0,t.jsx)(n.strong,{children:"error handling client"}),'" is a client which prevents the user from reading\na ',(0,t.jsx)(n.code,{children:"null"})," used as a placeholder for an error in a GraphQL response. The client\nmay do so by throwing when an errored field is accessed (as is the case for\n",(0,t.jsx)(n.a,{href:"https://github.com/graphile/graphql-toe",children:(0,t.jsx)(n.code,{children:"graphql-toe"})}),"), or when a fragment\ncontaining an error is read (as is the case for Relay's ",(0,t.jsx)(n.code,{children:"@throwOnFieldError"}),"\ndirective), or by preventing any data from being read if an error occurred (as\nwith Apollo Client's ",(0,t.jsx)(n.code,{children:'errorPolicy: "none"'}),")."]}),"\n",(0,t.jsxs)(n.admonition,{title:"Error-handling clients are the future",type:"tip",children:[(0,t.jsxs)(n.p,{children:["Reproducing server errors on the client like this allows your developers to use\nyour language or framework's native error handling mechanisms, whether that be\n",(0,t.jsx)(n.code,{children:"try"}),"/",(0,t.jsx)(n.code,{children:"catch"})," or ",(0,t.jsx)(n.code,{children:"<ErrorBoundary />"})," or whatever your language/framework\nsupports. No need for GraphQL-specific error handling within your components!"]}),(0,t.jsxs)(n.p,{children:["You can likely make your existing client an error-handling client today by\nintegrating ",(0,t.jsx)(n.code,{children:"graphql-toe"}),", it's only 512 bytes gzipped! (You can also just\nintegrate the source code, it's less than 100 LOC in TypeScript and is MIT\nlicensed.)"]})]}),"\n",(0,t.jsx)(n.h3,{id:"disabling-error-propagation-and-reflecting-true-nullability",children:"Disabling error propagation and reflecting true nullability"}),"\n",(0,t.jsx)(n.p,{children:'If the client were to take responsibility for error handling by disabling null\nbubbling and implementing a "throw on error" or similar behavior, we could\nreflect the data\'s true nullability in the schema:'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",metastring:'title="Query type"',children:"type Query {\n  you: User!\n  me: User! # True nullability; client handles errors\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Hooray for fewer null checks! \ud83c\udf89"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",metastring:'title="Before \ud83d\ude1e"',children:"if (data.me) {\n  return <User user={data.me} />;\n} else {\n  // TODO: determine if this was an error null,\n  // or just a non-existent user.\n  return <NotFoundOrError />;\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",metastring:'title="After \ud83e\udd29"',children:"return <User user={data.me} />;\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["(Example assumes that your React application is already using\n",(0,t.jsx)(n.code,{children:"<ErrorBoundary />"})," in a parent component.)"]})}),"\n",(0,t.jsx)(n.admonition,{title:"Try it today!",type:"tip",children:(0,t.jsxs)(n.p,{children:["Some GraphQL engines already support clients disabling error propagation via the\n",(0,t.jsx)(n.code,{children:"@experimental_disableErrorPropagation"})," operation directive; but make sure that\nyou only use this with an error-handling client or you may get unexpected\nresults!"]})}),"\n",(0,t.jsx)(n.h3,{id:"supporting-legacy-clients",children:"Supporting legacy clients"}),"\n",(0,t.jsx)(n.p,{children:"What does this mean for our existing deployed applications, for example mobile\napps on legacy devices that can no longer be updated? This is certainly a\ncritical concern for organizations such as Facebook!"}),"\n",(0,t.jsx)(n.p,{children:"If we introduce non-null in more places, this would have the effect of making\nexisting deployed applications less resilient to errors since errors will now\ndestroy even more of the returned data. For example, an application such as this\none that handles errors at the widget level might result in a full page error if we simply marked the type as non-nullable:"}),"\n",(0,t.jsxs)("div",{style:{textAlign:"center"},children:[(0,t.jsx)("img",{alt:"A legacy mobile application rendering many widgets, one of which has errored",src:a,style:{maxWidth:"200px",marginRight:"1em"}}),(0,t.jsx)("img",{alt:"A legacy mobile application rendering a full-page error",src:l,style:{maxWidth:"200px"}})]}),"\n",(0,t.jsx)(n.p,{children:"This is much less useful for the user!"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"(Thanks to v0 for generating these app mockups for me!)"})}),"\n",(0,t.jsx)(n.h3,{id:"the-transitional-non-null-type",children:'The "transitional non-null" type'}),"\n",(0,t.jsxs)(n.p,{children:['To support these legacy apps, I propose a "',(0,t.jsx)(n.strong,{children:"transitional"}),' non-null" type,\nrepresented by the wildcard symbol ',(0,t.jsx)(n.code,{children:"*"}),", that changes to either be nullable (",(0,t.jsx)(n.code,{children:"T*"}),"\n\u21d2 ",(0,t.jsx)(n.code,{children:"T"}),") for legacy/traditional apps or non-nullable (",(0,t.jsx)(n.code,{children:"T*"})," \u21d2 ",(0,t.jsx)(n.code,{children:"T!"}),') for\nour future "error handling clients".']}),"\n",(0,t.jsx)("div",{style:{textAlign:"center"},children:(0,t.jsx)("img",{alt:"Legacy and future apps side by side, handling errors gracefully thanks to transitional non-null type",src:s,style:{maxWidth:"300px",width:"100%"}})}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsxs)(n.mdxAdmonitionTitle,{children:["Use ",(0,t.jsx)(n.code,{children:"graphql-sock"})," to convert these types"]}),(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/graphile/graphql-sock",children:(0,t.jsx)(n.code,{children:"graphql-sock"})}),' is an npm module that\nprovides a CLI and TypeScript library capable of converting a "semantic\nnullability" schema (that is to say one that supports the "semantic non null"\naka "transitional non null" type) into a schema with traditional syntax, either\nby removing the semantic non-nullability for legacy clients\n(',(0,t.jsx)(n.code,{children:"semantic-to-nullable"}),") or by replacing transitional/semantic non-null with the\ntraditional (strict) non-null for error-handling clients (",(0,t.jsx)(n.code,{children:"semantic-to-strict"}),")."]}),(0,t.jsxs)(n.p,{children:["Use it today to support both your legacy (",(0,t.jsx)(n.code,{children:"semantic-to-nullable"}),") and\nerror-handling (",(0,t.jsx)(n.code,{children:"semantic-to-strict"}),") applications' codegen, linting, and\nsimilar needs."]})]}),"\n",(0,t.jsx)(n.h3,{id:"new-schema-new-field-no-legacy-clients-no-asterisk-needed",children:"New schema? New field? No legacy clients? No asterisk needed!"}),"\n",(0,t.jsxs)(n.p,{children:["The best part about this? ",(0,t.jsx)(n.strong,{children:"If you're starting a new project from scratch and\nonly want to support error-handling clients, you'll never need to add this\nsymbol to your schema or anywhere else!"})," It'll be as if it doesn't exist!"]}),"\n",(0,t.jsxs)(n.p,{children:["You also don't need to add the symbol to types in any new fields on an existing\nschema since a new field has no legacy \u2014 you can just use ",(0,t.jsx)(n.code,{children:"!"}),' directly to\nrepresent "semantically" non-null positions as a way of encouraging all\nclients to become error-handling clients.']}),"\n",(0,t.jsxs)(n.p,{children:['If you want to leverage "true nullability" in new clients without breaking your\nexisting deployed clients, this little symbol is there for you. And once all\nyour clients have become error-handling clients you can just replace ',(0,t.jsx)(n.code,{children:"*"})," for\n",(0,t.jsx)(n.code,{children:"!"})," and your migration is complete!"]}),"\n",(0,t.jsx)(n.p,{children:"Everybody wins!"})]})}function g(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},1151:(e,n,r)=>{r.d(n,{Z:()=>s,a:()=>l});var t=r(7294);const i={},a=t.createContext(i);function l(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);