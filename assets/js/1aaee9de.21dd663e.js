"use strict";(self.webpackChunk_localrepo_benjie_dev=self.webpackChunk_localrepo_benjie_dev||[]).push([[7358],{3862:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>h,frontMatter:()=>a,metadata:()=>c,toc:()=>l});var s=i(5893),r=i(1151);const a={identifier:"OperationExpressions",stage:"0",title:"Operation Expressions",events:[{type:"docCreated",date:new Date("2021-09-02T21:41:43.000Z"),href:"https://github.com/graphql/graphql-wg/blob/40a5e9ddbb41af18972df0cbc74945c09fb7b935/rfcs/OperationExpressions.md",actor:"Benjie Gillam"}],shortname:"Operation Expressions",image:"/img/rfc_tracker.png"},t=void 0,c={id:"OperationExpressions",title:"Operation Expressions",description:"At a glance",source:"@site/rfcs/OperationExpressions.md",sourceDirName:".",slug:"/OperationExpressions",permalink:"/rfcs/OperationExpressions",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{identifier:"OperationExpressions",stage:"0",title:"Operation Expressions",events:[{type:"docCreated",date:"2021-09-02T21:41:43.000Z",href:"https://github.com/graphql/graphql-wg/blob/40a5e9ddbb41af18972df0cbc74945c09fb7b935/rfcs/OperationExpressions.md",actor:"Benjie Gillam"}],shortname:"Operation Expressions",image:"/img/rfc_tracker.png"},sidebar:"rfcsSidebar",previous:{title:"Implicit Inheritance",permalink:"/rfcs/ImplicitInheritance"},next:{title:"Schema Fragments",permalink:"/rfcs/SchemaFragments"}},d={},l=[{value:"At a glance",id:"at-a-glance",level:2},{value:"Timeline",id:"timeline",level:2},{value:"Aim",id:"aim",level:2},{value:"Use cases",id:"use-cases",level:2},{value:"Referencing a position within a GraphQL Operation Document",id:"referencing-a-position-within-a-graphql-operation-document",level:4},{value:"Generating a GraphQL Operation Document quickly (Emmet-style)",id:"generating-a-graphql-operation-document-quickly-emmet-style",level:3},{value:"Documentation Permalinks",id:"documentation-permalinks",level:3},{value:"Linking from a field description to an operation path",id:"linking-from-a-field-description-to-an-operation-path",level:3},{value:"Indicating how to access a particular field",id:"indicating-how-to-access-a-particular-field",level:3},{value:"Analytics",id:"analytics",level:3},{value:"Syntax",id:"syntax",level:2},{value:"Pathing",id:"pathing",level:4},{value:"Operations",id:"operations",level:4},{value:"Fragments",id:"fragments",level:4},{value:"Arguments",id:"arguments",level:4},{value:"Grammar",id:"grammar",level:2},{value:"Lexical Tokens",id:"lexical-tokens",level:3},{value:"Expression Syntax",id:"expression-syntax",level:3}];function o(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"at-a-glance",children:"At a glance"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Identifier"}),": OperationExpressions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Stage"}),": ",(0,s.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md#stage-0-strawman",children:"RFC0: Strawman"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Champion"}),": -"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"PR"}),": -"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"timeline",children:"Timeline"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/40a5e9ddbb41af18972df0cbc74945c09fb7b935/rfcs/OperationExpressions.md",children:"RFC document created"})})," on 2021-09-02 by Benjie Gillam"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.h1,{id:"rfc-operation-expressions",children:"RFC: Operation Expressions"}),"\n",(0,s.jsx)(n.p,{children:"(WORKING TITLE!)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Proposed by:"})," ",(0,s.jsx)(n.a,{href:"https://twitter.com/benjie",children:"Benjie Gillam"})," - Graphile"]}),"\n",(0,s.jsxs)(n.p,{children:["In the ",(0,s.jsx)(n.a,{href:"/rfcs/SchemaCoordinates",children:"Schema Coordinates RFC"}),' Mark introduced the\nconcept of "schema coordinates" which give a standard human- and\nmachine-readable way to unambiguously refer to entities within a GraphQL schema:\ntypes, fields, field arguments, enum values, directives and directive arguments.\nThe scope of that RFC is deliberately very tight, and it serves that goal well,\nproviding a one-to-one mapping between the schema coordinates and the schema\nentities.']}),"\n",(0,s.jsx)(n.p,{children:"This RFC is to gather feedback on expansions of the Schema Coordinate syntax\nthat could be used for different purposes whilst maintaining familiarity."}),"\n",(0,s.jsx)(n.h2,{id:"aim",children:"Aim"}),"\n",(0,s.jsx)(n.p,{children:"The aim of this RFC is to give the GraphQL community a standard syntax that\npeople, tools and documentation can use to concisely and consistently reference\nGraphQL operation concepts such as paths that is more fluid, expressive, and\ncontains more context than the Schema Coordinates RFC that this RFC builds on\ntop of."}),"\n",(0,s.jsx)(n.p,{children:"This is not intended to be a replacement of the Schema Coordinates RFC, but an\nextension to it for a number of additional use-cases."}),"\n",(0,s.jsx)(n.h2,{id:"use-cases",children:"Use cases"}),"\n",(0,s.jsx)(n.h4,{id:"referencing-a-position-within-a-graphql-operation-document",children:"Referencing a position within a GraphQL Operation Document"}),"\n",(0,s.jsx)(n.p,{children:"Imagine you have the following GraphQL query:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:'{\n  businesses: searchBusinesses(name: "Automotive") {\n    id\n    name\n    owner: personByOwnerId {\n      id\n      name\n      email # <<< HERE\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["You might reference the marked (",(0,s.jsx)(n.code,{children:"<<< HERE"}),") field with an expression such as:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Person.email"}),' - this is the "schema coordinate" which uniquely identifies the\nfield, but lacks context on how we retrieved it']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:">businesses>owner>email"})," - given the GraphQL query document, this is\nsufficient to uniquely identify this specific reference (caveat: duplicate\nfields would all be referenced with the same expression)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:">businesses:searchBusinesses>owner:personByOwnerId>email"})," - this contains\nmore context than the above, indicating not just the aliases but the actual\nfield names too; with this access to the operation document is not required to\ndetermine what was requested"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:">businesses:searchBusinesses(name:)>owner:personByOwnerId>email"})," - this\ncontains even more context (the argument names that were used)"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These are all valid operation expressions, but they each convey different levels\nof context."}),"\n",(0,s.jsx)(n.h3,{id:"generating-a-graphql-operation-document-quickly-emmet-style",children:"Generating a GraphQL Operation Document quickly (Emmet-style)"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Emmet is a plugin for many popular text editors which greatly improves HTML &\nCSS workflow:"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Emmet is a popular syntax for quickly generating HTML/CSS. It's easy to imagine\nhow a operation expression syntax could be combined with a GraphQL schema\ndefinition to quickly generate GraphQL queries, mutations and subscriptions with\na concise syntax. For example the expression:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:">businesses:searchBusinesses(name:)>owner:personByOwnerId>email"})}),"\n",(0,s.jsx)(n.p,{children:"might expand to:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"query($name: String!) {\n  businesses: searchBusinesses(name: $name) {\n    owner: personByOwnerId {\n      email\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"MyFragment:User.businesses>owner>email"})}),"\n",(0,s.jsx)(n.p,{children:"might expand to:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"fragment MyFragment on User {\n  businesses {\n    owner {\n      email\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"documentation-permalinks",children:"Documentation Permalinks"}),"\n",(0,s.jsx)(n.p,{children:'When navigating the GraphiQL documentation, GraphiQL maintains a stack of the\npath you arrived to the current documentation page through. It could be valuable\nto store this into the query string such that you could share a "documentation\nstack" with someone else (or bookmark it). For example if you browsed through\nthe documentation via:'}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"User"})," type"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"User.friends"})," field (returns a ",(0,s.jsx)(n.code,{children:"User"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"User.latestMedia"})," field (returns a ",(0,s.jsx)(n.code,{children:"Media"})," union)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Post"})," type in Media union"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"title"})," field"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"you might use a query string such as:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"?docs=User.friends>latestMedia>Post.title\n"})}),"\n",(0,s.jsx)(n.h3,{id:"linking-from-a-field-description-to-an-operation-path",children:"Linking from a field description to an operation path"}),"\n",(0,s.jsx)(n.p,{children:"If, for example, you were to deprecate a root-level field in your schema, you\nmight want to indicate where the user can retrieve the equivalent data now. You\ncould do this by including an operation expression as part of the deprecation\nreason:"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Query.branchesFromFork"})," field is being removed; please use the following\npath instead: ",(0,s.jsx)(n.code,{children:"Query>repositories>forks>branches"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"indicating-how-to-access-a-particular-field",children:"Indicating how to access a particular field"}),"\n",(0,s.jsx)(n.p,{children:"When reading the documentation of a type in GraphiQL it currently does not\nindicate how to reach a particular field. Though there are often infinitely many\npaths to reach a field, often the shortest are the most valuable, so GraphiQL\ncould indicate a few of the shorter paths using operation expression syntax:"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"User.firstName"})," can be accessed through paths such as:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:">me>firstName"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:">articles>author>firstName"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:">searchMedia>Book.author>firstName"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"mutation>createUser>user>firstName"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"analytics",children:"Analytics"}),"\n",(0,s.jsx)(n.p,{children:"When analysing how a GraphQL schema is used, it may be useful to track\nstatistics for each type, field, argument using Schema Coordinates; but it may\nalso be interesting to track through what paths users are finding said fields.\nYou could use operation expression syntax to track this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"counters['Query.cities>libraries>findBook(isbn:)']++\n"})}),"\n",(0,s.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,s.jsx)(n.p,{children:"Syntax is in flux; but here's some thoughts:"}),"\n",(0,s.jsx)(n.h4,{id:"pathing",children:"Pathing"}),"\n",(0,s.jsxs)(n.p,{children:["Following a path from one field to the next could use the ",(0,s.jsx)(n.code,{children:">"})," character; this is\nalready used in Apollo's GraphQL documentation browser and is intuitive for\nnavigation. This leaves ",(0,s.jsx)(n.code,{children:"."})," available and non-ambiguous for referring to fields\non a type, which is useful when disambiguating references on a union type, for\ninstance:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:">me>media>Film.duration\n"})}),"\n",(0,s.jsx)(n.p,{children:"might model:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"{\n  me {\n    media {\n      ... on Film {\n        duration\n      }\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"operations",children:"Operations"}),"\n",(0,s.jsxs)(n.p,{children:["The expression ",(0,s.jsx)(n.code,{children:">me>name"})," would expand to ",(0,s.jsx)(n.code,{children:"{ me { name } }"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"If you want to create a mutation or subscription operation, you can prefix the\npath with the operation type (you can do this for queries too, but just like in\noperation documents, the query keyword is optional):"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mutation>createUser>user>name"})," expands to\n",(0,s.jsx)(n.code,{children:"mutation ($input: CreateUserInput!) { createUser(input: $input) { user { name } } }"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"subscription>currentUserUpdated>name"})," expands to\n",(0,s.jsx)(n.code,{children:"subscription { currentUserUpdated { name } }"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"query>me>name"})," expands to ",(0,s.jsx)(n.code,{children:"query { me { name } }"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"You may name operations by prefixing with an operation name followed by a colon;\nfor example:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MyQuery:>me>name"})," and ",(0,s.jsx)(n.code,{children:"MyQuery:query>me>name"})," expand to\n",(0,s.jsx)(n.code,{children:"query MyQuery { me { name } }"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MyMutation:mutation>createUser>name"})," expands to\n",(0,s.jsx)(n.code,{children:"mutation MyMutation { createUser { name } }"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MySubscription:subscription>userCreated>name"})," expands to\n",(0,s.jsx)(n.code,{children:"subscription MySubscription { userCreated { name } }"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"fragments",children:"Fragments"}),"\n",(0,s.jsxs)(n.p,{children:["Fragments start with a type name followed by a period: ",(0,s.jsx)(n.code,{children:"User.friends>name"}),"\nexpands to ",(0,s.jsx)(n.code,{children:"... on User { friends { name } }"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["You can name fragments by prefixing with a fragment name and a colon:\n",(0,s.jsx)(n.code,{children:"FriendNames:User.friends>name"})," expands to\n",(0,s.jsx)(n.code,{children:"fragment FriendNames on User { friends { name } }"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Other examples:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"MyFragment:Node.User.fullName:name"})," expands to\n",(0,s.jsx)(n.code,{children:"fragment MyFragment on Node { ... on User { fullName: name } }"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"MyQuery:>allEntities>edges>node>MyNodeFragment:Node.MyUserFragment:User.fullName:name"}),"\nexpands to"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"query MyQuery {\n  allEntities {\n    edges {\n      node {\n        ...MyNodeFragment\n      }\n    }\n  }\n}\n\nfragment MyNodeFragment on Node {\n  ...MyUserFragment\n}\n\nfragment MyUserFragment on User {\n  fullName: name\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"arguments",children:"Arguments"}),"\n",(0,s.jsxs)(n.p,{children:["Arguments use the same syntax as Schema Coordinates; namely parenthesis and a\ncolon: ",(0,s.jsx)(n.code,{children:">searchBusinesses(name:)>city"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"We also allow you to reference input objects used in arguments, for example:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:">searchBusinesses(where>size>greaterThan:)>city"})}),"\n",(0,s.jsx)(n.p,{children:"expands to something like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"query($whereSizeGreaterThan: Int) {\n  searchBusinesses(where: { size: { greaterThan: $whereSizeGreaterThan } }) {\n    city\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Further we allow for multiple arguments to be specified, joined with commas:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:">searchBusinesses(where>size>greaterThan:,where>size>lessThan:,where>city>equalTo:)>name"})}),"\n",(0,s.jsx)(n.p,{children:"expands to something like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"query(\n  $whereSizeGreaterThan: Int\n  $whereSizeLessThan: Int\n  $whereCityEqualTo: String\n) {\n  searchBusinesses(\n    where: {\n      size: { greaterThan: $whereSizeGreaterThan, lessThan: $whereSizeLessThan }\n      city: { equalTo: $whereCityEqualTo }\n    }\n  ) {\n    name\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"NOTE: the following number syntax probably needs more thought. Added only for\ncompleteness."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["We also allow ",(0,s.jsx)(n.code,{children:"[number]"})," syntax to refer to a numbered entry in a list, or ",(0,s.jsx)(n.code,{children:"[]"}),"\nto refer to the next entry; e.g.:"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:">findUsers(byIds[]:,byIds[],byIds[],byIds[5])>name"})}),"\n",(0,s.jsx)(n.p,{children:"expands to something like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"query($byIds0: ID, $byIds1: ID, $byIds2: ID, $byIds5: ID) {\n  findUsers(byIds: [$byIds0, $byIds1, $byIds2, null, null, $byIds5]) {\n    name\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"grammar",children:"Grammar"}),"\n",(0,s.jsxs)(n.p,{children:["The Lexical Tokens below plus ",(0,s.jsx)(n.code,{children:"OperationType"})," and ",(0,s.jsx)(n.code,{children:"Alias"})," are defined as in the\nGraphQL spec. Note there are no ignored characters: ",(0,s.jsx)(n.strong,{children:"whitespace is not\nignored"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"lexical-tokens",children:"Lexical Tokens"}),"\n",(0,s.jsx)(n.p,{children:"Name ::"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"NameStart NameContinue* [lookahead != NameContinue]"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"NameStart ::"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Letter"}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"_"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"NameContinue ::"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Letter"}),"\n",(0,s.jsx)(n.li,{children:"Digit"}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"_"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Letter :: one of\n",(0,s.jsx)(n.code,{children:"A"})," ",(0,s.jsx)(n.code,{children:"B"})," ",(0,s.jsx)(n.code,{children:"C"})," ",(0,s.jsx)(n.code,{children:"D"})," ",(0,s.jsx)(n.code,{children:"E"})," ",(0,s.jsx)(n.code,{children:"F"})," ",(0,s.jsx)(n.code,{children:"G"})," ",(0,s.jsx)(n.code,{children:"H"})," ",(0,s.jsx)(n.code,{children:"I"})," ",(0,s.jsx)(n.code,{children:"J"})," ",(0,s.jsx)(n.code,{children:"K"})," ",(0,s.jsx)(n.code,{children:"L"})," ",(0,s.jsx)(n.code,{children:"M"}),"\n",(0,s.jsx)(n.code,{children:"N"})," ",(0,s.jsx)(n.code,{children:"O"})," ",(0,s.jsx)(n.code,{children:"P"})," ",(0,s.jsx)(n.code,{children:"Q"})," ",(0,s.jsx)(n.code,{children:"R"})," ",(0,s.jsx)(n.code,{children:"S"})," ",(0,s.jsx)(n.code,{children:"T"})," ",(0,s.jsx)(n.code,{children:"U"})," ",(0,s.jsx)(n.code,{children:"V"})," ",(0,s.jsx)(n.code,{children:"W"})," ",(0,s.jsx)(n.code,{children:"X"})," ",(0,s.jsx)(n.code,{children:"Y"})," ",(0,s.jsx)(n.code,{children:"Z"}),"\n",(0,s.jsx)(n.code,{children:"a"})," ",(0,s.jsx)(n.code,{children:"b"})," ",(0,s.jsx)(n.code,{children:"c"})," ",(0,s.jsx)(n.code,{children:"d"})," ",(0,s.jsx)(n.code,{children:"e"})," ",(0,s.jsx)(n.code,{children:"f"})," ",(0,s.jsx)(n.code,{children:"g"})," ",(0,s.jsx)(n.code,{children:"h"})," ",(0,s.jsx)(n.code,{children:"i"})," ",(0,s.jsx)(n.code,{children:"j"})," ",(0,s.jsx)(n.code,{children:"k"})," ",(0,s.jsx)(n.code,{children:"l"})," ",(0,s.jsx)(n.code,{children:"m"}),"\n",(0,s.jsx)(n.code,{children:"n"})," ",(0,s.jsx)(n.code,{children:"o"})," ",(0,s.jsx)(n.code,{children:"p"})," ",(0,s.jsx)(n.code,{children:"q"})," ",(0,s.jsx)(n.code,{children:"r"})," ",(0,s.jsx)(n.code,{children:"s"})," ",(0,s.jsx)(n.code,{children:"t"})," ",(0,s.jsx)(n.code,{children:"u"})," ",(0,s.jsx)(n.code,{children:"v"})," ",(0,s.jsx)(n.code,{children:"w"})," ",(0,s.jsx)(n.code,{children:"x"})," ",(0,s.jsx)(n.code,{children:"y"})," ",(0,s.jsx)(n.code,{children:"z"})]}),"\n",(0,s.jsxs)(n.p,{children:["Digit :: one of\n",(0,s.jsx)(n.code,{children:"0"})," ",(0,s.jsx)(n.code,{children:"1"})," ",(0,s.jsx)(n.code,{children:"2"})," ",(0,s.jsx)(n.code,{children:"3"})," ",(0,s.jsx)(n.code,{children:"4"})," ",(0,s.jsx)(n.code,{children:"5"})," ",(0,s.jsx)(n.code,{children:"6"})," ",(0,s.jsx)(n.code,{children:"7"})," ",(0,s.jsx)(n.code,{children:"8"})," ",(0,s.jsx)(n.code,{children:"9"})]}),"\n",(0,s.jsxs)(n.p,{children:["IntValue :: IntegerPart [lookahead != {Digit, ",(0,s.jsx)(n.code,{children:"."}),", NameStart}]"]}),"\n",(0,s.jsx)(n.p,{children:"IntegerPart ::"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"NegativeSign? 0"}),"\n",(0,s.jsx)(n.li,{children:"NegativeSign? NonZeroDigit Digit*"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"NegativeSign :: -"}),"\n",(0,s.jsxs)(n.p,{children:["NonZeroDigit :: Digit but not ",(0,s.jsx)(n.code,{children:"0"})]}),"\n",(0,s.jsx)(n.p,{children:"Comma :: ,"}),"\n",(0,s.jsx)(n.h3,{id:"expression-syntax",children:"Expression Syntax"}),"\n",(0,s.jsx)(n.p,{children:"Expression :"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"FragmentExpression"}),"\n",(0,s.jsx)(n.li,{children:"OperationExpression"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"OperationExpression : Alias? OperationType? > SelectionPath"}),"\n",(0,s.jsx)(n.p,{children:"FragmentExpression : Alias? Name . SelectionPath"}),"\n",(0,s.jsx)(n.p,{children:"Alias : Name :"}),"\n",(0,s.jsxs)(n.p,{children:["OperationType : one of ",(0,s.jsx)(n.code,{children:"query"})," ",(0,s.jsx)(n.code,{children:"mutation"})," ",(0,s.jsx)(n.code,{children:"subscription"})]}),"\n",(0,s.jsx)(n.p,{children:"SelectionPath :"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Alias? Name . Alias? Name ( Arguments ) > SelectionPath"}),"\n",(0,s.jsx)(n.li,{children:"Alias? Name . Alias? Name ( Arguments )"}),"\n",(0,s.jsx)(n.li,{children:"Alias? Name . Alias? Name > SelectionPath"}),"\n",(0,s.jsx)(n.li,{children:"Alias? Name . Alias? Name"}),"\n",(0,s.jsx)(n.li,{children:"Alias? Name ( Arguments ) > SelectionPath"}),"\n",(0,s.jsx)(n.li,{children:"Alias? Name ( Arguments )"}),"\n",(0,s.jsx)(n.li,{children:"Alias? Name > SelectionPath"}),"\n",(0,s.jsx)(n.li,{children:"Alias? Name"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Arguments :"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Argument Comma Arguments"}),"\n",(0,s.jsx)(n.li,{children:"Argument"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Argument : NamePath :"}),"\n",(0,s.jsx)(n.p,{children:"NamePath :"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Name Indexes? > NamePath"}),"\n",(0,s.jsx)(n.li,{children:"Name Indexes?"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Indexes :"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Index Indexes"}),"\n",(0,s.jsx)(n.li,{children:"Index"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Index :"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"[ IntValue ]"}),"\n",(0,s.jsx)(n.li,{children:"[ ]"}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>c,a:()=>t});var s=i(7294);const r={},a=s.createContext(r);function t(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);