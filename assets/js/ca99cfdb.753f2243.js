"use strict";(self.webpackChunk_localrepo_benjie_dev=self.webpackChunk_localrepo_benjie_dev||[]).push([[9720],{2154:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>h,contentTitle:()=>c,default:()=>g,frontMatter:()=>o,metadata:()=>d,toc:()=>u});var i=r(5893),s=r(1151);const t=r.p+"assets/images/legacy-app-widget-error-f6a951aaa00bd77625edcfdb4e39acc0.png",l=r.p+"assets/images/legacy-app-fullscreen-error-e5127ef2c205d1091652a777bdc4ba94.png",a=r.p+"assets/images/everyones-happy-6d890589e55871ad639a56c800648cf7.png",o={type:"page",title:"Nullability",description:"The past and future of GraphQL nullability, according to Benjie",tag:"graphql",author:"Benjie",breadcrumb:!1,sidebar_position:35},c=void 0,d={id:"graphql/nullability",title:"Nullability",description:"The past and future of GraphQL nullability, according to Benjie",source:"@site/pages/graphql/nullability.mdx",sourceDirName:"graphql",slug:"/graphql/nullability",permalink:"/graphql/nullability",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:35,frontMatter:{type:"page",title:"Nullability",description:"The past and future of GraphQL nullability, according to Benjie",tag:"graphql",author:"Benjie",breadcrumb:!1,sidebar_position:35},sidebar:"defaultSidebar",previous:{title:"Naming Conventions",permalink:"/graphql/naming"},next:{title:"Nested Mutations",permalink:"/graphql/nested-mutations"}},h={},u=[{value:"By default, data doesn&#39;t exist",id:"by-default-data-doesnt-exist",level:3},{value:"Partial success",id:"partial-success",level:3},{value:"Error propagation (aka null bubbling)",id:"error-propagation-aka-null-bubbling",level:3},{value:"Schema best practice?",id:"schema-best-practice",level:3},{value:"Handling errors on the client",id:"handling-errors-on-the-client",level:3},{value:"Disabling error propagation and reflecting true nullability",id:"disabling-error-propagation-and-reflecting-true-nullability",level:3},{value:"Supporting legacy clients",id:"supporting-legacy-clients",level:3},{value:"The &quot;transitional non-null&quot; type",id:"the-transitional-non-null-type",level:3},{value:"New app? No new syntax!",id:"new-app-no-new-syntax",level:3},{value:"Current status - disabling error propagation",id:"current-status---disabling-error-propagation",level:3},{value:"Current status - semantic nullability",id:"current-status---semantic-nullability",level:3},{value:"Specification",id:"specification",level:4},{value:"Server support",id:"server-support",level:4},{value:"Client support",id:"client-support",level:4}];function p(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h3:"h3",h4:"h4",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"This article reflects Benjie's opinions on the past and the future of\nNullability in GraphQL; but note that these are merely opinions."})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Here's a 60 second summary of this article:"}),"\n",(0,i.jsx)("iframe",{width:"315",height:"560",src:"https://www.youtube.com/embed/gYnVaZz-19A",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0}),"\n",(0,i.jsx)(n.h3,{id:"by-default-data-doesnt-exist",children:"By default, data doesn't exist"}),"\n",(0,i.jsxs)(n.p,{children:["In mathematics and in many programming languages we use ",(0,i.jsx)(n.code,{children:"null"})," to represent data\nthat doesn't exist (let's not get into JavaScript...)."]}),"\n",(0,i.jsxs)(n.p,{children:["The original SQL standard factored this knowledge into its design, so an ",(0,i.jsx)(n.code,{children:"int"}),'\ncolumn in SQL means "an integer or null". To represent a non-nullable integer\nyou would add a type narrowing constraint, such as ',(0,i.jsx)(n.code,{children:"int not null"}),'. This pattern\nof the type including null unless otherwise constrained is called "',(0,i.jsx)(n.strong,{children:"nullable by\ndefault"}),'".']}),"\n",(0,i.jsx)(n.p,{children:'GraphQL is similar, types are nullable by default. To narrow a type to exclude\nnull, we add a "non null" wrapper, indicated in the GraphQL language by an\nexclamation point:'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",metastring:'title="Initial schema"',children:"type User {\n  name: String! # Definitely a string, never null\n}\n\ntype Query {\n  you: User! # Definitely a User, never null\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"partial-success",children:"Partial success"}),"\n",(0,i.jsx)(n.p,{children:'Resiliency was a key design goal of GraphQL. When working on the newsfeed,\nFacebook wanted to ensure that any temporary interruptions in one part of the\nsystem would not impact on other parts and cause user outages. Instead, they\nwanted GraphQL to enable "partial success" where as much data as possible would\nbe rendered to the user.'}),"\n",(0,i.jsxs)(n.p,{children:['To enable this resiliency, when GraphQL meets an error it notes where it was,\nadds it to the "errors" list, and replaces the output data with ',(0,i.jsx)(n.code,{children:"null"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",metastring:'title="Query type"',children:"type Query {\n  you: User!\n  me: User\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",metastring:'title="Query"',children:"query Q {\n  you {\n    name\n  }\n  me {\n    name\n  }\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:'title="Response"',children:'{\n  "data": {\n    "you": {\n      "name": "Jo"\n    },\n    "me": null // < An error occurred, see `errors`\n  },\n  "errors": [\n    {\n      "path": ["me"],\n      "message": "Not logged in"\n    }\n  ]\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"But what if a non-null field errors? If we placed a null in that position,\nwouldn't that be a contradiction?"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",metastring:'title="Query type"',children:"type Query {\n  you: User!\n  me: User! # How does non-null interact with errors?\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"error-propagation-aka-null-bubbling",children:"Error propagation (aka null bubbling)"}),"\n",(0,i.jsx)(n.p,{children:'To keep the non-null promise, GraphQL decided to perform a behavior it terms\n"error propagation" but most people refer to as "null bubbling" - it would throw\nthe error and catch it at the next nullable position (or the operation root if\nno such position existed).'}),"\n",(0,i.jsxs)(n.p,{children:['The end result: GraphQL will destroy result data outside of the field that\nfailed in order to keep non-null promises. No wonder Facebook call the non-null\ntype "',(0,i.jsx)(n.strong,{children:"kills parent on exception"}),'"!']}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:'title="Response"',children:'{\n  "data": null,\n  //     \ud83d\udc46 All of the data was destroyed, even the unrelated `you` field!\n  "errors": [\n    {\n      "path": ["me"],\n      "message": "Not logged in"\n    }\n  ]\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"schema-best-practice",children:"Schema best practice?"}),"\n",(0,i.jsx)(n.p,{children:"So when designing schemas it has been best practice to make fields nullable\nunless we're fairly certain they won't error. This allows the client to retain\nits resilience to errors, by rendering partially successful data."}),"\n",(0,i.jsx)(n.p,{children:"But having null checks throughout our client sucks!"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"if (data.me) {\n  return <User user={data.me} />;\n} else {\n  // TODO: determine if this was an error null,\n  // or just a non-existent user.\n  return <NotFoundOrError />;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"handling-errors-on-the-client",children:"Handling errors on the client"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://github.com/graphile/graphql-toe",children:(0,i.jsx)(n.code,{children:"graphql-toe"})})," is an npm module that\nuses getters to reproduce server errors on the client by throwing when an\nerrored field is accessed:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'import { toe } from "graphql-toe";\nimport { gql, request } from "graffle";\n\nconst response = await request("/graphql", document);\nconst dataAndErrors = toe(response);\n\ndataAndErrors.you; // Returns {"name": "Jo"}\ndataAndErrors.me; // \u203c\ufe0f throws Error("Log in!") \u203c\ufe0f\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"graphql-toe"})," can be integrated into many frameworks in the JS ecosystem (Apollo\nClient, urql, graffle, ",(0,i.jsx)(n.code,{children:"fetch()"}),"), but other frameworks may have their own\nnative error handling (e.g. Relay has the\n",(0,i.jsxs)(n.a,{href:"https://relay.dev/docs/guides/throw-on-field-error-directive/",children:[(0,i.jsx)(n.code,{children:"@throwOnFieldError"})," directive"]}),"\nwhich can be applied to fragments)."]}),"\n",(0,i.jsxs)(n.p,{children:["By recombining ",(0,i.jsx)(n.code,{children:"errors"})," back into ",(0,i.jsx)(n.code,{children:"data"})," we no longer need GraphQL to bubble\nnulls to keep its promise; since a ",(0,i.jsx)(n.code,{children:"null"})," can never be read from an errored\nposition."]}),"\n",(0,i.jsxs)(n.p,{children:['An "',(0,i.jsx)(n.strong,{children:"error handling client"}),'" is a client which prevents the user from reading\na ',(0,i.jsx)(n.code,{children:"null"})," used as a placeholder for an error in a GraphQL response. The client\nmay do so by throwing when an errored field is accessed (as is the case for\n",(0,i.jsx)(n.a,{href:"https://github.com/graphile/graphql-toe",children:(0,i.jsx)(n.code,{children:"graphql-toe"})}),"), or when a fragment\ncontaining an error is read (as is the case for Relay's ",(0,i.jsx)(n.code,{children:"@throwOnFieldError"}),"\ndirective), or by preventing any data from being read if an error occurred (as\nwith Apollo Client's ",(0,i.jsx)(n.code,{children:'errorPolicy: "none"'}),")."]}),"\n",(0,i.jsxs)(n.admonition,{title:"Error-handling clients are the future",type:"tip",children:[(0,i.jsxs)(n.p,{children:["Reproducing server errors on the client like this allows your developers to use\nyour language or framework's native error handling mechanisms, whether that be\n",(0,i.jsx)(n.code,{children:"try"}),"/",(0,i.jsx)(n.code,{children:"catch"})," or ",(0,i.jsx)(n.code,{children:"<ErrorBoundary />"})," or whatever your language/framework\nsupports. No need for GraphQL-specific error handling within your components!"]}),(0,i.jsxs)(n.p,{children:["You can likely make your existing client an error-handling client today by\nintegrating ",(0,i.jsx)(n.code,{children:"graphql-toe"}),", it's only 512 bytes gzipped! (You can also just\nintegrate the source code, it's less than 100 LOC in TypeScript and is MIT\nlicensed.)"]})]}),"\n",(0,i.jsx)(n.h3,{id:"disabling-error-propagation-and-reflecting-true-nullability",children:"Disabling error propagation and reflecting true nullability"}),"\n",(0,i.jsx)(n.p,{children:'If the client were to take responsibility for error handling by disabling null\nbubbling and implementing a "throw on error" or similar behavior, we could\nreflect the data\'s true nullability in the schema:'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",metastring:'title="Query type"',children:"type Query {\n  you: User!\n  me: User! # True nullability; client handles errors\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Hooray for fewer null checks! \ud83c\udf89"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="Before \ud83d\ude1e"',children:"if (data.me) {\n  return <User user={data.me} />;\n} else {\n  // TODO: determine if this was an error null,\n  // or just a non-existent user.\n  return <NotFoundOrError />;\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="After \ud83e\udd29"',children:"return <User user={data.me} />;\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["(Example assumes that your React application is already using\n",(0,i.jsx)(n.code,{children:"<ErrorBoundary />"})," in a parent component.)"]})}),"\n",(0,i.jsx)(n.admonition,{title:"Try it today!",type:"tip",children:(0,i.jsxs)(n.p,{children:["Some GraphQL engines already support clients disabling error propagation via the\n",(0,i.jsx)(n.code,{children:"@experimental_disableErrorPropagation"})," operation directive; but make sure that\nyou only use this with an error-handling client or you may get unexpected\nresults!"]})}),"\n",(0,i.jsx)(n.h3,{id:"supporting-legacy-clients",children:"Supporting legacy clients"}),"\n",(0,i.jsx)(n.p,{children:"What does this mean for our existing deployed applications, for example mobile\napps on legacy devices that can no longer be updated? This is certainly a\ncritical concern for organizations such as Facebook!"}),"\n",(0,i.jsx)(n.p,{children:"If we introduce non-null in more places, this would have the effect of making\nexisting deployed applications less resilient to errors since errors will now\ndestroy even more of the returned data. For example, an application such as this\none that handles errors at the widget level:"}),"\n",(0,i.jsx)("img",{alt:"A legacy mobile application rendering many widgets, one of which has errored",src:t,style:{maxWidth:"250px"}}),"\n",(0,i.jsx)(n.p,{children:"might result in a full page error if we simply marked the type as non-nullable:"}),"\n",(0,i.jsx)("img",{alt:"A legacy mobile application rendering a full-page error",src:l,style:{maxWidth:"250px"}}),"\n",(0,i.jsx)(n.p,{children:"This is much less useful for the user!"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"(Thanks to v0 for generating these app mockups for me!)"})}),"\n",(0,i.jsx)(n.h3,{id:"the-transitional-non-null-type",children:'The "transitional non-null" type'}),"\n",(0,i.jsxs)(n.p,{children:['To support these legacy apps, I propose a "',(0,i.jsx)(n.strong,{children:"transitional"}),' non-null" type,\nrepresented by the wildcard symbol ',(0,i.jsx)(n.code,{children:"*"}),", that changes to either be nullable (",(0,i.jsx)(n.code,{children:"T*"}),"\n\u21d2 ",(0,i.jsx)(n.code,{children:"T"}),") for legacy/traditional apps or non-nullable (",(0,i.jsx)(n.code,{children:"T*"})," \u21d2 ",(0,i.jsx)(n.code,{children:"T!"}),') for\nour future "error handling clients".']}),"\n",(0,i.jsx)("img",{alt:"Legacy and future apps side by side, handling errors gracefully thanks to transitional non-null type",src:a,style:{maxWidth:"500px",width:"100%"}}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsxs)(n.mdxAdmonitionTitle,{children:["Use ",(0,i.jsx)(n.code,{children:"graphql-sock"})," to convert these types"]}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://github.com/graphile/graphql-sock",children:(0,i.jsx)(n.code,{children:"graphql-sock"})}),' is an npm module that\nprovides a CLI and TypeScript library capable of converting a "semantic\nnullability" schema (that is to say one that supports the "semantic non null"\naka "transitional non null" type) into a schema with traditional syntax, either\nby removing the semantic non-nullability for legacy clients\n(',(0,i.jsx)(n.code,{children:"semantic-to-nullable"}),") or by replacing transitional/semantic non-null with the\ntraditional (strict) non-null for error-handling clients (",(0,i.jsx)(n.code,{children:"semantic-to-strict"}),")."]}),(0,i.jsxs)(n.p,{children:["Use it today to support both your legacy (",(0,i.jsx)(n.code,{children:"semantic-to-nullable"}),") and\nerror-handling (",(0,i.jsx)(n.code,{children:"semantic-to-strict"}),") applications' codegen, linting, and\nsimilar needs."]})]}),"\n",(0,i.jsx)(n.h3,{id:"new-app-no-new-syntax",children:"New app? No new syntax!"}),"\n",(0,i.jsx)(n.p,{children:"The best part about this? If you're starting a new project from scratch and only\nwant to support error-handling clients, you'll never need to add this symbol or\nany new directives to your schema or anywhere else! But with it, existing\nschemas can allow new apps to leverage true nullability in the schema, without\nbreaking existing clients. Everybody wins!"}),"\n",(0,i.jsx)(n.h3,{id:"current-status---disabling-error-propagation",children:"Current status - disabling error propagation"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Last updated: 2025-03-26"})}),"\n",(0,i.jsx)(n.p,{children:"Generally agreed that the future of GraphQL in one in which error propagation is\ndisabled. The mechanics of it, particularly recognising that we need to support\nlegacy clients, are still under discussion."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Originally proposed as a directive\n(",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/pull/1050",children:"spec edits"}),") - currently\n",(0,i.jsx)(n.code,{children:"@disableErrorPropagation"})]}),"\n",(0,i.jsxs)(n.li,{children:["Currently, Benjie proposes this should be a request (in the GraphQL sense, not\nnecessarily the HTTP sense) parameter:\n",(0,i.jsx)(n.a,{href:"https://github.com/graphql/nullability-wg/discussions/86",children:"https://github.com/graphql/nullability-wg/discussions/86"})]}),"\n",(0,i.jsxs)(n.li,{children:['There\'s discussion around whether clients that reject the entire response on\nany error should get their own "behavior", e.g. ',(0,i.jsx)(n.code,{children:"@behavior(onError: ABORT)"})," -\nthis would increase server efficiency, and prevent sending unnecessary data\nover the wire that the client would ignore anyway."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"@experimental_disableErrorPropagation"})," directive can be used to experiment\nwith disabling error propagation without any further impact, and will be\navailable in the next releases of:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-js/pull/4348",children:"graphql-js"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql-java/graphql-java/pull/3772",children:"graphql-java"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"current-status---semantic-nullability",children:"Current status - semantic nullability"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["THIS IS BENJIE'S OPINION, FOR TRUE STATUS SEE\n",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/main/rfcs/SemanticNullability.md",children:"THE RFC DOCUMENT"}),"!"]})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Last updated: 2025-03-26"})}),"\n",(0,i.jsx)(n.h4,{id:"specification",children:"Specification"}),"\n",(0,i.jsxs)(n.p,{children:['To deal with the legacy clients problem, the working group has generally\nsolidified around the concept of a "semantic non-nullable" type that can be\nthought of as "null only on error" - i.e. it will never be ',(0,i.jsx)(n.code,{children:"null"})," unless an\nerror has occurred (and been noted in the ",(0,i.jsx)(n.code,{children:'"errors"'})," list)."]}),"\n",(0,i.jsxs)(n.p,{children:["However, how this is presented via the SDL is under heavy discussion. There are\ncurrently\n",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/main/rfcs/SemanticNullability.md#-possible-solutions",children:"6 solutions"}),"\nbeing discussed."]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Semantic non-null, represented by ",(0,i.jsx)(n.code,{children:"*"})]})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Champion"}),": Benjie"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Status"}),": Preferred by Benjie, outdated."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Spec edits"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/pull/1065",children:"https://github.com/graphql/graphql-spec/pull/1065"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reference implementation"}),":\n",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-js/pull/4192",children:"https://github.com/graphql/graphql-js/pull/4192"})," - available via\n",(0,i.jsx)(n.code,{children:"graphql@canary-pr-4192"})]}),"\n",(0,i.jsx)(n.li,{children:"An outdated version of what is proposed above."}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"TODO"}),": update this!"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Strict Semantic Nullability"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Champion"}),": Lee Byron"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Status"}),": Rejected by Lee"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Spec edits"}),": none"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reference implementation"}),": none"]}),"\n",(0,i.jsxs)(n.li,{children:['This proposal choose to break the "nullable by default" tradition in\nfavour of representing nullable with a ',(0,i.jsx)(n.code,{children:"?"}),": nullable (",(0,i.jsx)(n.code,{children:"T?"}),"), semantically\nnon-nullable (",(0,i.jsx)(n.code,{children:"T"}),") and strictly non-nullable (",(0,i.jsx)(n.code,{children:"T!"}),")strictly non-nullable\n(",(0,i.jsx)(n.code,{children:"T!"}),"), and does so by introducing a directive on the schema to indicate\nthis."]}),"\n",(0,i.jsx)(n.li,{children:"Benjie believes it's non-viable for a number of reasons, chiefly that it\ndoesn't consider what it means for executable documents (how do clients\ndefine variables?), and none of the three solutions to executable\ndocuments seem desirable."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Semantic non-null usurps ",(0,i.jsx)(n.code,{children:"!"})," syntax, strict non-null uses ",(0,i.jsx)(n.code,{children:"!!"})]})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Champion"}),": Benjie"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Status"}),": On hold, since solution 1 is currently preferred by Benjie."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Spec edits"}),": none"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reference implementation"}),": none"]}),"\n",(0,i.jsxs)(n.li,{children:["This was a derivative of solution 1 to attempt to address concerns that\nthe ",(0,i.jsx)(n.code,{children:"*"})," syntax was non-obvious."]}),"\n",(0,i.jsxs)(n.li,{children:["It requires a document directive to opt in to the new syntax (otherwise\n",(0,i.jsx)(n.code,{children:"!"})," will continue to mean strict non-null)."]}),"\n",(0,i.jsx)(n.li,{children:"Client documents need not change."}),"\n",(0,i.jsx)(n.li,{children:"It recognises the two modes laid out in this article, but tries to move\ntowards a future where every schema only uses semantically non-null types,\nand the legacy strict non-null is phased out."}),"\n",(0,i.jsxs)(n.li,{children:["Benjie doesn't currently prefer this because he agrees with solution 5 -\nthe future of GraphQL uses its current syntax, and doesn't need a\n",(0,i.jsx)(n.code,{children:'"use strict"'}),"-style pragma at the top of every document."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Unadorned becomes semantic non-null, nullable represented by ",(0,i.jsx)(n.code,{children:"?"})]})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Champion"}),": None (currently Alex Reilly is representing)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Status"}),": Unknown"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Spec edits"}),": none"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reference implementation"}),":\n",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-js/pull/4337",children:"https://github.com/graphql/graphql-js/pull/4337"})]}),"\n",(0,i.jsx)(n.li,{children:"This is an expansion of solution 2 that moves the directive from the\nschema to the document."}),"\n",(0,i.jsxs)(n.li,{children:["Benjie dislikes it because:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Data is nullable by default, but this makes data semantically\nnon-nullable by default."}),"\n",(0,i.jsxs)(n.li,{children:["The unadorned type cannot be migrated to other types (specifically the\n",(0,i.jsx)(n.code,{children:"T?"})," nullable type) in a non-breaking way, so schema authors will have\nto be extra careful that they have remembered to mark up every type\ncorrectly - they can't fix it later by adding a symbol."]}),"\n",(0,i.jsxs)(n.li,{children:["If ",(0,i.jsx)(n.code,{children:"?"})," means nullable in the SDL and unadorned means non-nullable, what\ndoes this mean for existing executable documents where unadorned means\nnullable?","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Should executable documents use ",(0,i.jsx)(n.code,{children:"@semanticNullability"})," and use\n",(0,i.jsx)(n.code,{children:"?"}),"/unadorned, or should they continue to use unadorned/",(0,i.jsx)(n.code,{children:"!"}),"?"]}),"\n",(0,i.jsx)(n.li,{children:"Will this cause a split in the GraphQL ecosystem over best practices\naround this?"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Having the meaning of unadorned suddenly mean the opposite of what it\ndid before (nullable \u21d2 non-nullable) based on the presence of a\ndirective at the top of the document is super confusing."}),"\n",(0,i.jsx)(n.li,{children:"Spec implementation is complex."}),"\n",(0,i.jsx)(n.li,{children:"Reference implementation is complex."}),"\n",(0,i.jsx)(n.li,{children:'Updating all the "nullable by default" documentation across the last\ndecade for GraphQL is not desirable.'}),"\n",(0,i.jsx)(n.li,{children:"Newbies to GraphQL will be super confused."}),"\n",(0,i.jsx)(n.li,{children:"I think this would be one of the worst possible moves that GraphQL could\nmake."}),"\n",(0,i.jsxs)(n.li,{children:['I would much rather see a "GraphQL 2.0" that disables null bubbling\n(and, if you like, gets rid of the ',(0,i.jsx)(n.code,{children:"!"})," syntax in favour of ",(0,i.jsx)(n.code,{children:"?"}),") than see\nGraphQL enter this state."]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.em,{children:'Increasingly incoherent "old man yells at cloud" noises.'})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Just use ",(0,i.jsx)(n.code,{children:"!"})," for semantically non-nullable"]})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Champion"}),": Martin Bonnin"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Status"}),": Actively proposed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Spec edits"}),": no action needed!"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reference implementation"}),": no action needed!"]}),"\n",(0,i.jsx)(n.li,{children:"Martin thinks we should just use the existing non-null in semantically\nnon-nullable places, relying on the ability to disable error propagation\nfor all future clients."}),"\n",(0,i.jsx)(n.li,{children:"This proposal is extremely compelling, it feels like it should be the\nfuture of GraphQL, and it recognises that error propagation was probably a\nmistake and just turning that off should be enough to fix our woes."}),"\n",(0,i.jsxs)(n.li,{children:["Unfortunately, as laid out ",(0,i.jsx)(n.a,{href:"#supporting-legacy-clients",children:"above"}),", this would\nbe a major shift in behavior for existing deployed clients resulting in\nerror boundaries moving towards the root of the operation, causing legacy\nclients that cannot be updated to be less resilient to errors."]}),"\n",(0,i.jsx)(n.li,{children:"This sparked Benjie's reframing of solution 1 as presented in this\narticle."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"@semanticNonNull"})," directive"]})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Champion"}),": None (the nullability WG designed this together as an\ninterrim solution)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Status"}),": Interrim solution, implemented in a number of runtimes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Spec edits"}),": None (though solution 1 could be changed to doing this\nwith very few edits)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reference implementation"}),": None (though solution 1 could be changed to\ndoing this with very few edits)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Community spec"}),":\n",(0,i.jsx)(n.a,{href:"https://specs.apollo.dev/nullability/v0.4/#@semanticNonNull",children:"https://specs.apollo.dev/nullability/v0.4/#@semanticNonNull"})]}),"\n",(0,i.jsxs)(n.li,{children:["Essentially this is solution 1, but instead of introducing a ",(0,i.jsx)(n.code,{children:"*"})," character\n(e.g. ",(0,i.jsx)(n.code,{children:"[T*]*"}),") we use a directive to indicate semantic nullability\n(",(0,i.jsx)(n.code,{children:"[T] @semanticNonNull(levels: [0, 1])"}),")"]}),"\n",(0,i.jsx)(n.li,{children:"Does everything that solution 1 does, except for the convenient syntax."}),"\n",(0,i.jsx)(n.li,{children:"Directives already exist, so we don't need to debate syntax!"}),"\n",(0,i.jsxs)(n.li,{children:["Benjie's opinion:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Given this is essentially solution 1 but without the syntax changes, I\nsupport it..."}),"\n",(0,i.jsxs)(n.li,{children:["Do we really hate ",(0,i.jsx)(n.code,{children:"*"})," syntax so much that we'd rather type\n",(0,i.jsx)(n.code,{children:"@semanticNonNull(levels: [0, 1])"})," than adding two ",(0,i.jsx)(n.code,{children:"*"})," characters?"]}),"\n",(0,i.jsxs)(n.li,{children:["I currently see this as being implemented in the same way as solution 1;\n",(0,i.jsx)(n.strong,{children:"however"}),", it could be implemented as schema metadata and thus never\nactually enter the specification.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"It needs support in both server and client, so it feels like it should\nbe part of the spec."}),"\n",(0,i.jsxs)(n.li,{children:["Keeping it as schema metadata would require a solution to the infamous\n",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/issues/300",children:"#300"})]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"server-support",children:"Server support"}),"\n",(0,i.jsxs)(n.p,{children:["Users can manually mark up schemas with ",(0,i.jsx)(n.code,{children:"@semanticNonNull"})," for use by\n",(0,i.jsx)(n.code,{children:"graphql-sock"}),", ",(0,i.jsx)(n.code,{children:"graphql-code-generator"})," and other tools."]}),"\n",(0,i.jsx)(n.p,{children:"Native support for semantic nullability is available in the following GraphQL\nimplementations:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"graphql@canary-pr-4192"})," has support for the ",(0,i.jsx)(n.code,{children:"*"})," syntax for semantic\nnullability"]}),"\n",(0,i.jsxs)(n.li,{children:["Grats has support for ",(0,i.jsx)(n.code,{children:"@semanticNonNull"})," in\n",(0,i.jsx)(n.a,{href:"https://grats.capt.dev/docs/guides/strict-semantic-nullability/",children:"v0.0.32"})]}),"\n",(0,i.jsxs)(n.li,{children:["Hot Chocolate has support for ",(0,i.jsx)(n.code,{children:"@semanticNonNull"})," as of\n",(0,i.jsx)(n.a,{href:"https://github.com/ChilliCream/graphql-platform/releases/tag/14.2.0",children:"v14.2.0"})]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"client-support",children:"Client support"}),"\n",(0,i.jsxs)(n.p,{children:["Most clients can become error-handling clients by integrating\n",(0,i.jsx)(n.a,{href:"https://github.com/graphile/graphql-toe",children:(0,i.jsx)(n.code,{children:"graphql-toe"})}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Graffle, fetch, and other simple clients have examples in the graphql-toe\n",(0,i.jsx)(n.code,{children:"README"})]}),"\n",(0,i.jsxs)(n.li,{children:["Apollo Client has an example of ",(0,i.jsx)(n.code,{children:"useTOEQuery()"})," (to replace ",(0,i.jsx)(n.code,{children:"useQuery()"}),") in\nthe graphql-toe ",(0,i.jsx)(n.code,{children:"README"})]}),"\n",(0,i.jsxs)(n.li,{children:["URQL has ",(0,i.jsx)(n.code,{children:"@urql/exchange-throw-on-error"})," that integrates ",(0,i.jsx)(n.code,{children:"graphql-toe"})]}),"\n",(0,i.jsxs)(n.li,{children:["Relay users should use ",(0,i.jsx)(n.code,{children:"@throwOnFieldError"})," instead"]}),"\n",(0,i.jsxs)(n.li,{children:["Apollo Kotlin has native support for ",(0,i.jsx)(n.code,{children:"@catch"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Most clients can use ",(0,i.jsx)(n.a,{href:"https://github.com/graphile/graphql-sock",children:(0,i.jsx)(n.code,{children:"graphql-sock"})}),"\nto convert a semantic nullability schema into a nullable\n(",(0,i.jsx)(n.code,{children:"semantic-to-nullable"}),") schema for legacy clients, or a strict\n(",(0,i.jsx)(n.code,{children:"semantic-to-strict"}),") schema for error handling clients, for the purposes of\ncode generation, linting, and other needs."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["GraphQL code generator has support for ",(0,i.jsx)(n.code,{children:"@semanticNonNull"})," (any version) and\nthe ",(0,i.jsx)(n.code,{children:"*"})," syntax (if you're using ",(0,i.jsx)(n.code,{children:"graphql@canary-pr-4192"}),") in the\n",(0,i.jsx)(n.a,{href:"https://github.com/dotansimha/graphql-code-generator/pull/10323",children:"latest alpha"}),"\nvia ",(0,i.jsx)(n.code,{children:"graphql-sock"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Relay has built in support for code generation respecting semantic nullability\non a per-fragment and per-field basis as of Relay v18 via the ",(0,i.jsx)(n.code,{children:"@catch"})," and\n",(0,i.jsx)(n.code,{children:"@throwOnFieldError"})," directives."]}),"\n",(0,i.jsxs)(n.li,{children:["Apollo Kotlin's code generator has native support for ",(0,i.jsx)(n.code,{children:"@semanticNonNull"})," and\n",(0,i.jsx)(n.code,{children:"@catch"})]}),"\n"]})]})}function g(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},1151:(e,n,r)=>{r.d(n,{Z:()=>a,a:()=>l});var i=r(7294);const s={},t=i.createContext(s);function l(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);