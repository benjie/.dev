"use strict";(self.webpackChunk_localrepo_benjie_dev=self.webpackChunk_localrepo_benjie_dev||[]).push([[7530],{5015:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>o,frontMatter:()=>r,metadata:()=>a,toc:()=>h});var i=l(5893),s=l(1151);const r={identifier:"SemanticNullability",stage:"0",title:"Semantic Nullability",events:[{type:"docUpdated",date:new Date("2025-05-01T15:31:59.000Z"),href:"https://github.com/graphql/graphql-wg/blob/1cd0215e06037621dac28c2590fffb1dab939261/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docUpdated",date:new Date("2025-05-01T14:46:17.000Z"),href:"https://github.com/graphql/graphql-wg/blob/e3630e38fd430ca33c08e91ffb377a2f5f705898/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docUpdated",date:new Date("2025-04-25T13:10:33.000Z"),href:"https://github.com/graphql/graphql-wg/blob/6816e9f6050cee9722f24b79f38dd3eef31c5daa/rfcs/SemanticNullability.md",actor:"Martin Bonnin"},{type:"docUpdated",date:new Date("2025-03-29T07:49:34.000Z"),href:"https://github.com/graphql/graphql-wg/blob/5629792430b8d22343883084be36e6f27951d0ba/rfcs/SemanticNullability.md",actor:"Martin Bonnin"},{type:"docUpdated",date:new Date("2025-03-28T10:43:16.000Z"),href:"https://github.com/graphql/graphql-wg/blob/058bf9055d2c8235d3db3df8d365984d312769c9/rfcs/SemanticNullability.md",actor:"Martin Bonnin"},{type:"docUpdated",date:new Date("2025-03-28T07:43:47.000Z"),href:"https://github.com/graphql/graphql-wg/blob/dd2c3c6fcda4f3b4a27345a57f1c63761a0bd2ac/rfcs/SemanticNullability.md",actor:"Alex Reilly"},{type:"docUpdated",date:new Date("2025-03-06T18:17:49.000Z"),href:"https://github.com/graphql/graphql-wg/blob/3441a2d5eda2f7211f17f02f5a5cf7352b94f72c/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docUpdated",date:new Date("2025-02-22T12:45:51.000Z"),href:"https://github.com/graphql/graphql-wg/blob/36aff80993c5e4453274e9ed42ebce5e704971b5/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docUpdated",date:new Date("2025-02-22T11:32:00.000Z"),href:"https://github.com/graphql/graphql-wg/blob/cd807eb3d6cb7d21616d98d71285dbf33facc7a1/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docUpdated",date:new Date("2025-02-20T22:03:18.000Z"),href:"https://github.com/graphql/graphql-wg/blob/3ff9ab3a1cecf70e1d571838bc5358c2187a09f1/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docUpdated",date:new Date("2025-02-20T21:54:01.000Z"),href:"https://github.com/graphql/graphql-wg/blob/93aa905f39d3be8bbe74dfad7964b05925933bd0/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docUpdated",date:new Date("2025-02-20T20:03:57.000Z"),href:"https://github.com/graphql/graphql-wg/blob/d3477790f7d0fddb79c58d799279f265e15768b6/rfcs/SemanticNullability.md",actor:"Martin Bonnin"},{type:"docUpdated",date:new Date("2025-02-17T23:00:49.000Z"),href:"https://github.com/graphql/graphql-wg/blob/b3d32a65ff9aaf944c9e733fdc43702aaf064cee/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docUpdated",date:new Date("2025-02-17T19:44:29.000Z"),href:"https://github.com/graphql/graphql-wg/blob/2a09600d6c757b21e05560958b8fc68882581cf3/rfcs/SemanticNullability.md",actor:"Alex Reilly"},{type:"docUpdated",date:new Date("2025-02-17T18:19:04.000Z"),href:"https://github.com/graphql/graphql-wg/blob/8f2f34308a1ba7abd49199595ec29ffd0d9f92a1/rfcs/SemanticNullability.md",actor:"Martin Bonnin"},{type:"docUpdated",date:new Date("2025-02-17T17:12:27.000Z"),href:"https://github.com/graphql/graphql-wg/blob/1abb4b36871a669fdd4206c3662ed4ce5d7f2931/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docUpdated",date:new Date("2025-02-17T16:57:59.000Z"),href:"https://github.com/graphql/graphql-wg/blob/a0d1ea9b68d074ada0a3e9d7a65ad7a95dcac562/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docUpdated",date:new Date("2025-02-16T10:18:38.000Z"),href:"https://github.com/graphql/graphql-wg/blob/4ea256a2926b9dc47034a68056b1de20900f11a3/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docUpdated",date:new Date("2025-02-16T10:16:21.000Z"),href:"https://github.com/graphql/graphql-wg/blob/f6809bd4fd099f7088e262d3d0fc732e4e3b4c57/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docCreated",date:new Date("2025-02-15T12:58:27.000Z"),href:"https://github.com/graphql/graphql-wg/blob/7535894a6deec5a618de02aaa16fdcf83a4e09ed/rfcs/SemanticNullability.md",actor:"Benjie"}],related:"1065, 1165, wg1410, wg1700",shortname:"Semantic Nullability",image:"/img/rfc_tracker.png"},t=void 0,a={id:"SemanticNullability",title:"Semantic Nullability",description:"At a glance",source:"@site/rfcs/SemanticNullability.md",sourceDirName:".",slug:"/SemanticNullability",permalink:"/rfcs/SemanticNullability",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{identifier:"SemanticNullability",stage:"0",title:"Semantic Nullability",events:[{type:"docUpdated",date:"2025-05-01T15:31:59.000Z",href:"https://github.com/graphql/graphql-wg/blob/1cd0215e06037621dac28c2590fffb1dab939261/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docUpdated",date:"2025-05-01T14:46:17.000Z",href:"https://github.com/graphql/graphql-wg/blob/e3630e38fd430ca33c08e91ffb377a2f5f705898/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docUpdated",date:"2025-04-25T13:10:33.000Z",href:"https://github.com/graphql/graphql-wg/blob/6816e9f6050cee9722f24b79f38dd3eef31c5daa/rfcs/SemanticNullability.md",actor:"Martin Bonnin"},{type:"docUpdated",date:"2025-03-29T07:49:34.000Z",href:"https://github.com/graphql/graphql-wg/blob/5629792430b8d22343883084be36e6f27951d0ba/rfcs/SemanticNullability.md",actor:"Martin Bonnin"},{type:"docUpdated",date:"2025-03-28T10:43:16.000Z",href:"https://github.com/graphql/graphql-wg/blob/058bf9055d2c8235d3db3df8d365984d312769c9/rfcs/SemanticNullability.md",actor:"Martin Bonnin"},{type:"docUpdated",date:"2025-03-28T07:43:47.000Z",href:"https://github.com/graphql/graphql-wg/blob/dd2c3c6fcda4f3b4a27345a57f1c63761a0bd2ac/rfcs/SemanticNullability.md",actor:"Alex Reilly"},{type:"docUpdated",date:"2025-03-06T18:17:49.000Z",href:"https://github.com/graphql/graphql-wg/blob/3441a2d5eda2f7211f17f02f5a5cf7352b94f72c/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docUpdated",date:"2025-02-22T12:45:51.000Z",href:"https://github.com/graphql/graphql-wg/blob/36aff80993c5e4453274e9ed42ebce5e704971b5/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docUpdated",date:"2025-02-22T11:32:00.000Z",href:"https://github.com/graphql/graphql-wg/blob/cd807eb3d6cb7d21616d98d71285dbf33facc7a1/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docUpdated",date:"2025-02-20T22:03:18.000Z",href:"https://github.com/graphql/graphql-wg/blob/3ff9ab3a1cecf70e1d571838bc5358c2187a09f1/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docUpdated",date:"2025-02-20T21:54:01.000Z",href:"https://github.com/graphql/graphql-wg/blob/93aa905f39d3be8bbe74dfad7964b05925933bd0/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docUpdated",date:"2025-02-20T20:03:57.000Z",href:"https://github.com/graphql/graphql-wg/blob/d3477790f7d0fddb79c58d799279f265e15768b6/rfcs/SemanticNullability.md",actor:"Martin Bonnin"},{type:"docUpdated",date:"2025-02-17T23:00:49.000Z",href:"https://github.com/graphql/graphql-wg/blob/b3d32a65ff9aaf944c9e733fdc43702aaf064cee/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docUpdated",date:"2025-02-17T19:44:29.000Z",href:"https://github.com/graphql/graphql-wg/blob/2a09600d6c757b21e05560958b8fc68882581cf3/rfcs/SemanticNullability.md",actor:"Alex Reilly"},{type:"docUpdated",date:"2025-02-17T18:19:04.000Z",href:"https://github.com/graphql/graphql-wg/blob/8f2f34308a1ba7abd49199595ec29ffd0d9f92a1/rfcs/SemanticNullability.md",actor:"Martin Bonnin"},{type:"docUpdated",date:"2025-02-17T17:12:27.000Z",href:"https://github.com/graphql/graphql-wg/blob/1abb4b36871a669fdd4206c3662ed4ce5d7f2931/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docUpdated",date:"2025-02-17T16:57:59.000Z",href:"https://github.com/graphql/graphql-wg/blob/a0d1ea9b68d074ada0a3e9d7a65ad7a95dcac562/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docUpdated",date:"2025-02-16T10:18:38.000Z",href:"https://github.com/graphql/graphql-wg/blob/4ea256a2926b9dc47034a68056b1de20900f11a3/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docUpdated",date:"2025-02-16T10:16:21.000Z",href:"https://github.com/graphql/graphql-wg/blob/f6809bd4fd099f7088e262d3d0fc732e4e3b4c57/rfcs/SemanticNullability.md",actor:"Benjie"},{type:"docCreated",date:"2025-02-15T12:58:27.000Z",href:"https://github.com/graphql/graphql-wg/blob/7535894a6deec5a618de02aaa16fdcf83a4e09ed/rfcs/SemanticNullability.md",actor:"Benjie"}],related:"1065, 1165, wg1410, wg1700",shortname:"Semantic Nullability",image:"/img/rfc_tracker.png"},sidebar:"rfcsSidebar",previous:{title:"Do not exclude schema keyword if schema has description",permalink:"/rfcs/1167"},next:{title:"Add Transitional Non-Null appendix (`@noPropagate` directive)",permalink:"/rfcs/1165"}},d={},h=[{value:"At a glance",id:"at-a-glance",level:2},{value:"Timeline",id:"timeline",level:2},{value:"Error propagation",id:"error-propagation",level:2},{value:"Complication 1: partial success",id:"complication-1-partial-success",level:3},{value:"Complication 2: nullable epidemic",id:"complication-2-nullable-epidemic",level:3},{value:"Complication 3: normalized caching",id:"complication-3-normalized-caching",level:3},{value:"The Nullability Working Group",id:"the-nullability-working-group",level:2},{value:"Client-controlled nullability",id:"client-controlled-nullability",level:3},{value:"True nullability schema",id:"true-nullability-schema",level:3},{value:"Disabling error propagation",id:"disabling-error-propagation",level:2},{value:"Semantic nullability",id:"semantic-nullability",level:3},{value:"\ud83c\udfaf A. GraphQL should be able to indicate which nullable fields should become non-nullable when error propagation is disabled",id:"-a-graphql-should-be-able-to-indicate-which-nullable-fields-should-become-non-nullable-when-error-propagation-is-disabled",level:2},{value:"\ud83c\udfaf B. Existing executable documents should retain validity and meaning",id:"-b-existing-executable-documents-should-retain-validity-and-meaning",level:2},{value:"\ud83c\udfaf C. Unadorned type should mean nullable",id:"-c-unadorned-type-should-mean-nullable",level:2},{value:"\ud83c\udfaf D. Syntax should be obvious to programmers",id:"-d-syntax-should-be-obvious-to-programmers",level:2},{value:"\ud83c\udfaf E. Syntax used in SDL and in executable documents should be consistent with SDL",id:"-e-syntax-used-in-sdl-and-in-executable-documents-should-be-consistent-with-sdl",level:2},{value:"\ud83c\udfaf F. Alternative syntaxes should not cause confusion",id:"-f-alternative-syntaxes-should-not-cause-confusion",level:2},{value:"\ud83c\udfaf G. Error propagation boundaries should not change in existing executable documents",id:"-g-error-propagation-boundaries-should-not-change-in-existing-executable-documents",level:2},{value:"\ud83c\udfaf H. Implementation and spec simplicity",id:"-h-implementation-and-spec-simplicity",level:2},{value:"\ud83c\udfaf I. Syntax used in executable documents should be unchanged",id:"-i-syntax-used-in-executable-documents-should-be-unchanged",level:2},{value:"\ud83c\udfaf J. Type reasoning should remain local",id:"-j-type-reasoning-should-remain-local",level:2},{value:"\ud83c\udfaf K. Introspection must be backwards compatible",id:"-k-introspection-must-be-backwards-compatible",level:2},{value:"\ud83c\udfaf L. General GraphQL consumers should only need to think about nullable vs non-nullable",id:"-l-general-graphql-consumers-should-only-need-to-think-about-nullable-vs-non-nullable",level:2},{value:"\ud83c\udfaf M. The SDL should have exactly one form used by all producers and consumers",id:"-m-the-sdl-should-have-exactly-one-form-used-by-all-producers-and-consumers",level:2},{value:"\ud83c\udfaf N. The solution should add value even with error propagation enabled",id:"-n-the-solution-should-add-value-even-with-error-propagation-enabled",level:2},{value:"\ud83c\udfaf O. Should not have breaking changes for existing executable documents",id:"-o-should-not-have-breaking-changes-for-existing-executable-documents",level:2},{value:"\ud83c\udfaf P. The solution should result in users marking all semantically non-null fields as such",id:"-p-the-solution-should-result-in-users-marking-all-semantically-non-null-fields-as-such",level:2},{value:"\ud83c\udfaf Q. Migrating the unadorned output type to other forms of nullability should be non-breaking",id:"-q-migrating-the-unadorned-output-type-to-other-forms-of-nullability-should-be-non-breaking",level:2},{value:"\ud83c\udfaf R. Semantic nullability should only impact outputs, not inputs",id:"-r-semantic-nullability-should-only-impact-outputs-not-inputs",level:2},{value:"\ud83c\udfaf S. Should be incrementally adoptable",id:"-s-should-be-incrementally-adoptable",level:2},{value:"\ud83c\udfaf T. Should be incrementally removable",id:"-t-should-be-incrementally-removable",level:2},{value:"\ud83c\udfaf U. Legacy tooling and clients should safely interpret SDL even when ignoring directives",id:"-u-legacy-tooling-and-clients-should-safely-interpret-sdl-even-when-ignoring-directives",level:2},{value:"\ud83c\udfaf X. Title",id:"-x-title",level:2},{value:"\ud83d\udca1 1. New &quot;Semantic Non-Null&quot; type, represented by <code>*</code>",id:"-1-new-semantic-non-null-type-represented-by-",level:2},{value:"\ud83c\udfb2 Variations",id:"-variations",level:3},{value:"\u2696\ufe0f Evaluation",id:"\ufe0f-evaluation",level:3},{value:"\ud83d\udca1 2. &quot;Strict Semantic Nullability&quot;",id:"-2-strict-semantic-nullability",level:2},{value:"\u2696\ufe0f Evaluation",id:"\ufe0f-evaluation-1",level:3},{value:"\ud83d\udca1 3. New &quot;Semantic Non-Null&quot; type, usurping <code>!</code> syntax",id:"-3-new-semantic-non-null-type-usurping--syntax",level:2},{value:"\u2696\ufe0f Evaluation",id:"\ufe0f-evaluation-2",level:3},{value:"\ud83d\udca1 4. New &quot;Semantic Non-Null&quot; type, with <code>?</code> used for nullable types",id:"-4-new-semantic-non-null-type-with--used-for-nullable-types",level:2},{value:"\u2696\ufe0f Evaluation",id:"\ufe0f-evaluation-3",level:3},{value:"\ud83d\udca1 5. Use non-null in semantically non-nullable places and encourage disabling error propagation",id:"-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",level:2},{value:"\u2696\ufe0f Evaluation",id:"\ufe0f-evaluation-4",level:3},{value:"\ud83d\udca1 6. <code>@semanticNonNull</code> directive",id:"-6-semanticnonnull-directive",level:2},{value:"\u2696\ufe0f Evaluation",id:"\ufe0f-evaluation-5",level:3},{value:"\ud83d\udca1 7. <code>@propagateError</code> directive",id:"-7-propagateerror-directive",level:2},{value:"\u2696\ufe0f Evaluation",id:"\ufe0f-evaluation-6",level:3},{value:"\ud83d\udca1 8. Transitional Non-Null appendix",id:"-8-transitional-non-null-appendix",level:2},{value:"\u2696\ufe0f Evaluation",id:"\ufe0f-evaluation-7",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components},{Details:l}=n;return l||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"at-a-glance",children:"At a glance"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Identifier"}),": SemanticNullability"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stage"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md#stage-0-strawman",children:"RFC0: Strawman"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Champion"}),": -"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"PR"}),": -"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Related"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/rfcs/1065",title:"SemanticNonNull type (null only on error) / RFC0",children:"#1065"})," (SemanticNonNull type (null only on error))"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/rfcs/1165",title:"Add Transitional Non-Null appendix (`@noPropagate` directive) / RFC0",children:"#1165"})," (Add Transitional Non-Null appendix (`@noPropagate` directive))"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/rfcs/wg1410",title:"Strict Semantic Nullability / RFC0",children:"wg#1410"})," (Strict Semantic Nullability)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/rfcs/wg1700",title:"Lee's new nullability & error propagation proposal / RFC0",children:"wg#1700"})," (Lee's new nullability & error propagation proposal)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"timeline",children:"Timeline"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/1cd0215e06037621dac28c2590fffb1dab939261/rfcs/SemanticNullability.md",children:"RFC document updated"})})," on 2025-05-01 by Benjie"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/e3630e38fd430ca33c08e91ffb377a2f5f705898/rfcs/SemanticNullability.md",children:"RFC document updated"})})," on 2025-05-01 by Benjie"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/6816e9f6050cee9722f24b79f38dd3eef31c5daa/rfcs/SemanticNullability.md",children:"RFC document updated"})})," on 2025-04-25 by Martin Bonnin"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/5629792430b8d22343883084be36e6f27951d0ba/rfcs/SemanticNullability.md",children:"RFC document updated"})})," on 2025-03-29 by Martin Bonnin"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/058bf9055d2c8235d3db3df8d365984d312769c9/rfcs/SemanticNullability.md",children:"RFC document updated"})})," on 2025-03-28 by Martin Bonnin"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/dd2c3c6fcda4f3b4a27345a57f1c63761a0bd2ac/rfcs/SemanticNullability.md",children:"RFC document updated"})})," on 2025-03-28 by Alex Reilly"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/3441a2d5eda2f7211f17f02f5a5cf7352b94f72c/rfcs/SemanticNullability.md",children:"RFC document updated"})})," on 2025-03-06 by Benjie"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/36aff80993c5e4453274e9ed42ebce5e704971b5/rfcs/SemanticNullability.md",children:"RFC document updated"})})," on 2025-02-22 by Benjie"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/cd807eb3d6cb7d21616d98d71285dbf33facc7a1/rfcs/SemanticNullability.md",children:"RFC document updated"})})," on 2025-02-22 by Benjie"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/3ff9ab3a1cecf70e1d571838bc5358c2187a09f1/rfcs/SemanticNullability.md",children:"RFC document updated"})})," on 2025-02-20 by Benjie"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/93aa905f39d3be8bbe74dfad7964b05925933bd0/rfcs/SemanticNullability.md",children:"RFC document updated"})})," on 2025-02-20 by Benjie"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/d3477790f7d0fddb79c58d799279f265e15768b6/rfcs/SemanticNullability.md",children:"RFC document updated"})})," on 2025-02-20 by Martin Bonnin"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/b3d32a65ff9aaf944c9e733fdc43702aaf064cee/rfcs/SemanticNullability.md",children:"RFC document updated"})})," on 2025-02-17 by Benjie"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/2a09600d6c757b21e05560958b8fc68882581cf3/rfcs/SemanticNullability.md",children:"RFC document updated"})})," on 2025-02-17 by Alex Reilly"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/8f2f34308a1ba7abd49199595ec29ffd0d9f92a1/rfcs/SemanticNullability.md",children:"RFC document updated"})})," on 2025-02-17 by Martin Bonnin"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/1abb4b36871a669fdd4206c3662ed4ce5d7f2931/rfcs/SemanticNullability.md",children:"RFC document updated"})})," on 2025-02-17 by Benjie"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/a0d1ea9b68d074ada0a3e9d7a65ad7a95dcac562/rfcs/SemanticNullability.md",children:"RFC document updated"})})," on 2025-02-17 by Benjie"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/4ea256a2926b9dc47034a68056b1de20900f11a3/rfcs/SemanticNullability.md",children:"RFC document updated"})})," on 2025-02-16 by Benjie"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/f6809bd4fd099f7088e262d3d0fc732e4e3b4c57/rfcs/SemanticNullability.md",children:"RFC document updated"})})," on 2025-02-16 by Benjie"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/7535894a6deec5a618de02aaa16fdcf83a4e09ed/rfcs/SemanticNullability.md",children:"RFC document created"})})," on 2025-02-15 by Benjie"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.h1,{id:"rfc-semantic-nullability",children:"RFC: Semantic Nullability"}),"\n",(0,i.jsx)(n.h1,{id:"-problem-history",children:"\ud83d\udcdc Problem History"}),"\n",(0,i.jsx)(n.p,{children:"One of GraphQL's early decisions was to allow \"partial success\"; this was a\ncritical feature for Facebook - if one part of their backend infrastructure\nbecame degraded they wouldn't want to just render an error page, instead they\nwanted to serve the user a page with as much working data as they could."}),"\n",(0,i.jsx)(n.h2,{id:"error-propagation",children:"Error propagation"}),"\n",(0,i.jsxs)(n.p,{children:["To accomplish this, if an error occured within a resolver, the resolver's value\nwould be replaced with a ",(0,i.jsx)(n.code,{children:"null"}),", and an error would be added to the ",(0,i.jsx)(n.code,{children:"errors"}),'\narray in the response. GraphQL thus adopted the non-traditional stance of all\ntypes being "nullable by default" (since an error could happen anywhere at any\ntime for any reason).']}),"\n",(0,i.jsxs)(n.p,{children:["However, null-checking is exhausting and in some positions errors are extremely\nunlikely (and null is not an expected value according to the business logic) so\nGraphQL allowed a position to be marked non-nullable by following the type with\na ",(0,i.jsx)(n.code,{children:"!"})," marker - this would guarantee that that position in the data could not\ncontain a ",(0,i.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["What if a non-null field were to throw an error, or incorrectly return ",(0,i.jsx)(n.code,{children:"null"}),',\nthen? To solve that apparent contradiction, GraphQL introduced the "error\npropagation" behavior (also known colloquially as "null bubbling") - when a\n',(0,i.jsx)(n.code,{children:"null"})," (from an error or otherwise) occurs in a non-nullable position, the\nparent position (either a field or a list item) is made ",(0,i.jsx)(n.code,{children:"null"}),' instead. This\nbehavior would repeat if the parent position was also non-nullable, and this\ncould propagate (or "bubble") all the way up to the root of the operation if\neverything in the path is non-nullable.']}),"\n",(0,i.jsxs)(n.p,{children:["Thus the ",(0,i.jsx)(n.code,{children:"!"}),' non-null marker has also been known as "kills parent on exception"\ndue to this destructive error propagation behavior.']}),"\n",(0,i.jsx)(n.p,{children:"This solved the issue, and meant that GraphQL's nullability promises were still\nhonoured; but it wasn't without complications."}),"\n",(0,i.jsx)(n.h3,{id:"complication-1-partial-success",children:"Complication 1: partial success"}),"\n",(0,i.jsx)(n.p,{children:"We want to be resilient to systems failing; but errors that occur in\nnon-nullable positions cascade to surrounding parts of the query, making less\nand less data available to be rendered."}),"\n",(0,i.jsxs)(n.p,{children:["This seems contrary to our \"partial success\" aim, but it's easy to solve - we\njust make sure that the positions where we expect errors to occur are nullable\nso that errors don't propagate further. Clients now need to handle ",(0,i.jsx)(n.code,{children:"null"})," in\nthese positions."]}),"\n",(0,i.jsx)(n.h3,{id:"complication-2-nullable-epidemic",children:"Complication 2: nullable epidemic"}),"\n",(0,i.jsx)(n.p,{children:"Almost any field in your GraphQL schema could raise an error - errors might not\nonly be caused by backend services becoming unavailable or responding in\nunexpected ways; they can also be caused by simple programming errors in your\nbusiness logic, data consistency errors (e.g. expecting a boolean but receiving\na float), or any other cause."}),"\n",(0,i.jsxs)(n.p,{children:["Since we don't want to \"blow up\" the entire response if any such issue occurred,\nwe've moved to strongly encourage nullable usage throughout a schema, only\nadding the non-nullable ",(0,i.jsx)(n.code,{children:"!"})," marker to positions where we're truly sure that\nfield is extremely unlikely to error. This has the effect of meaning that\ndevelopers consuming the GraphQL API have to handle potential nulls in more\npositions than they would expect, making for additional work."]}),"\n",(0,i.jsx)(n.h3,{id:"complication-3-normalized-caching",children:"Complication 3: normalized caching"}),"\n",(0,i.jsx)(n.p,{children:'Many modern GraphQL clients use a "normalized" cache, such that updates pulled\ndown from the API in one query can automatically update all the previously\nrendered data across the application. This helps ensure consistency for users,\nand is a powerful feature.'}),"\n",(0,i.jsxs)(n.p,{children:["However, if an error occurs in a non-nullable position, it's\n",(0,i.jsx)(n.a,{href:"https://github.com/graphql/nullability-wg/issues/20",children:"no longer safe"})," to store\nthe data to the normalized cache. Again, the solution is to make more of your\nschema nullable."]}),"\n",(0,i.jsx)(n.h2,{id:"the-nullability-working-group",children:"The Nullability Working Group"}),"\n",(0,i.jsx)(n.p,{children:"At first, we thought the solution to this was to give clients control over the\nnullability of a response, so we set up the Client-Controlled Nullability (CCN)\nWorking Group. Later, we renamed the working group to the Nullability WG to show\nthat it encompassed all potential solutions to this problem."}),"\n",(0,i.jsx)(n.h3,{id:"client-controlled-nullability",children:"Client-controlled nullability"}),"\n",(0,i.jsx)(n.p,{children:"The first Nullability WG proposal came from a collaboration between Yelp and\nNetflix, with contributions from GraphQL WG regulars Alex Reilly, Mark Larah,\nand Stephen Spalding among others. They proposed we could adorn the queries we\nissue to the server with sigils indicating our desired nullability overrides for\nthe given fields - client-controlled nullability."}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"?"})," would be added to fields where we don't mind if they're null, but we\ndefinitely want errors to stop there; and add a ",(0,i.jsx)(n.code,{children:"!"})," to fields where we\ndefinitely don't want a null to occur (whether or not there is an error). This\nwould give consumers control over where errors/nulls were handled."]}),"\n",(0,i.jsx)(n.p,{children:"However, after much exploration of the topic over years we found numerous issues\nthat traded one set of concerns for another. We kept iterating whilst we looked\nfor a solution to these tradeoffs."}),"\n",(0,i.jsx)(n.h3,{id:"true-nullability-schema",children:"True nullability schema"}),"\n",(0,i.jsxs)(n.p,{children:["Jordan Eldredge\n",(0,i.jsx)(n.a,{href:"https://github.com/graphql/nullability-wg/discussions/22",children:"proposed"}),' that making\nfields nullable to handle error propagation was hiding the "true" nullability of\nthe data. Instead, he suggested, we should have the schema represent the true\nnullability, and put the responsibility on clients to use the ',(0,i.jsx)(n.code,{children:"?"})," CCN operator\nto handle errors in the relevant places."]}),"\n",(0,i.jsxs)(n.p,{children:["However, this would mean that clients such as Relay would want to add ",(0,i.jsx)(n.code,{children:"?"}),' in\nevery position, causing an "explosion" of question marks, because really what\nRelay desired was to disable error propagation entirely.']}),"\n",(0,i.jsx)(n.h2,{id:"disabling-error-propagation",children:"Disabling error propagation"}),"\n",(0,i.jsx)(n.p,{children:'It became clear that disabling error propagation was desired by advanced GraphQL\nclients and vital for ensuring that normalized caches were as useful as possible\nand that we could live up to the promise of GraphQL\'s partial success without\ncompromise. But that was only part of the problem - the other part was that we\nwant to see the "true" nullability of fields, the nullability if we were to\nexclude errors.'}),"\n",(0,i.jsxs)(n.p,{children:["Note: this RFC assumes that clients may opt out of error propagation via some\nmechanism that is outside the scope of this RFC and will be handled in a\nseparate RFC (e.g. via a directive such as ",(0,i.jsx)(n.code,{children:"@noErrorPropagation"})," or\n",(0,i.jsx)(n.code,{children:"@behavior(onError: NULL)"}),"; or via a request-level flag) - in general the\nspecific mechanism is unimportant and thus solutions are not expected to comment\non it unless the choice is significant to the proposal."]}),"\n",(0,i.jsx)(n.h3,{id:"semantic-nullability",children:"Semantic nullability"}),"\n",(0,i.jsx)(n.p,{children:"We realised that if we were to do this, we would need two schemas: one for when\nnull bubbling is disabled, where the true nullability of fields could be\nrepresented; and one for the traditional error handling behavior, where\nnullability would need to factor in that errors can occur."}),"\n",(0,i.jsx)(n.p,{children:"However, maintaining two nearly-identical-except-for-nullability schemas is a\nchore... and it felt like it was solveable if we could teach GraphQL to\nunderstand this need... What we ultimately realised is that GraphQL is missing a\ntype."}),"\n",(0,i.jsxs)(n.p,{children:["Ignoring errors, if we look at our business logic we can determine if a field is\neither ",(0,i.jsx)(n.em,{children:"semantically nullable"})," (it's meaningful for this field to be null - for\nexample an ",(0,i.jsx)(n.code,{children:"Animal"})," might not have an ",(0,i.jsx)(n.code,{children:"owner"})," currently) or ",(0,i.jsx)(n.em,{children:"semantically\nnon-nullable"})," (this field will never be null - for example every ",(0,i.jsx)(n.code,{children:"Post"})," must\nbelong to a ",(0,i.jsx)(n.code,{children:"topic"}),'). However GraphQL muddied the waters here by factoring\nerrors into the mix... "what if the "topics" service went down?" it would ask;\n"we might want to render the post!" And thus, we would make ',(0,i.jsx)(n.code,{children:"Post.topic"}),"\nnullable, even though we know it ",(0,i.jsx)(n.em,{children:"should"})," always exist, because we don't want\nerror propagation to destroy the entire response."]}),"\n",(0,i.jsx)(n.p,{children:"So we actually have three types:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{}),(0,i.jsx)(n.th,{children:"Value"}),(0,i.jsx)(n.th,{children:"Error"}),(0,i.jsx)(n.th,{children:"null"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Semantically nullable"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Semantically non-nullable"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u274c"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Strictly non-nullable"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u274c"}),(0,i.jsx)(n.td,{children:"\u274c"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["We could already express a position that could never error and never be null (we\ncalled this non-nullable, e.g. ",(0,i.jsx)(n.code,{children:"Int!"}),"), and we could express a position that\ncould be null or have an error (we called this nullable, e.g. ",(0,i.jsx)(n.code,{children:"Int"}),'), but what\nwe lacked was the ability to say "this position can be null, but that will only\nhappen if an error has occurred" - a "null only on error" or "semantically\nnon-null" type.']}),"\n",(0,i.jsx)(n.h1,{id:"-problem-statement",children:"\ud83d\udcdc Problem Statement"}),"\n",(0,i.jsx)(n.p,{children:"GraphQL needs to be able to represent semantically nullable and semantically\nnon-nullable types as such when error propagation is disabled."}),"\n",(0,i.jsx)(n.h1,{id:"-solution-criteria",children:"\ud83d\udccb Solution Criteria"}),"\n",(0,i.jsxs)(n.p,{children:["This section sketches out the potential goals that a solution might attempt to\nfulfill. These goals will be evaluated with the\n",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md#guiding-principles",children:"GraphQL Spec Guiding Principles"}),"\nin mind:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Backwards compatibility"}),"\n",(0,i.jsx)(n.li,{children:"Performance is a feature"}),"\n",(0,i.jsx)(n.li,{children:"Favor no change"}),"\n",(0,i.jsx)(n.li,{children:"Enable new capabilities motivated by real use cases"}),"\n",(0,i.jsx)(n.li,{children:"Simplicity and consistency over expressiveness and terseness"}),"\n",(0,i.jsx)(n.li,{children:"Preserve option value"}),"\n",(0,i.jsx)(n.li,{children:"Understandability is just as important as correctness"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Each criteria is identified with a ",(0,i.jsx)(n.code,{children:"Letter"})," so they can be referenced in the\nrest of the document. New criteria must be added to the end of the list."]}),"\n",(0,i.jsx)(n.p,{children:"Solutions are evaluated and scored using a simple 3 part scale. A solution may\nhave multiple evaluations based on variations present in the solution."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Pass."})," The solution clearly meets the criteria"]}),"\n",(0,i.jsxs)(n.li,{children:["\u26a0\ufe0f ",(0,i.jsx)(n.strong,{children:"Warning."})," The solution doesn't clearly meet or fail the criteria, or\nthere is an important caveat to passing the criteria"]}),"\n",(0,i.jsxs)(n.li,{children:["\ud83d\udeab ",(0,i.jsx)(n.strong,{children:"Fail."})," The solution clearly fails the criteria"]}),"\n",(0,i.jsx)(n.li,{children:"\u2754 The criteria hasn't been evaluated yet"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Passing or failing a specific criteria is NOT the final word. Both the Criteria\n",(0,i.jsx)(n.em,{children:"and"})," the Solutions are up for debate."]}),"\n",(0,i.jsx)(n.p,{children:'Criteria have been given a "score" according to their relative importance in\nsolving the problem laid out in this RFC while adhering to the GraphQL Spec\nGuiding Principles. The scores are:'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\ud83e\udd47 Gold - A must-have"}),"\n",(0,i.jsx)(n.li,{children:"\ud83e\udd48 Silver - A nice-to-have"}),"\n",(0,i.jsx)(n.li,{children:"\ud83e\udd49 Bronze - Not necessary"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"-a-graphql-should-be-able-to-indicate-which-nullable-fields-should-become-non-nullable-when-error-propagation-is-disabled",children:"\ud83c\udfaf A. GraphQL should be able to indicate which nullable fields should become non-nullable when error propagation is disabled"}),"\n",(0,i.jsx)(n.p,{children:'The promise of this RFC - the reflection of the semantic nullability of the\nfields without compromising requests with error propagation enabled via the\ndifferentiation of a "null if and only if an error occurs" type.'}),"\n",(0,i.jsx)(n.p,{children:"With error propagation enabled (the traditional GraphQL behavior), it's\nrecommended that fields are marked nullable if errors may happen there, even if\nthe underlying value is semantically non-nullable. If we allow error-handling\nclients to disable error propagation, then these traditionally nullable\npositions can be marked (semantically) non-nullable in that mode, since with\nerror propagation disabled the selection sets are no longer destroyed."}),"\n",(0,i.jsx)(n.p,{children:"Note: Traditional non-nullable types will effectively become semantically\nnon-nullable when error propagation is disabled no matter which solution is\nchosen, so this criteria is only concerned with traditionally nullable types."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"1"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-2-strict-semantic-nullability",children:"2"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-3-new-semantic-non-null-type-usurping--syntax",children:"3"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-4-new-semantic-non-null-type-with--used-for-nullable-types",children:"4"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"5"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-6-semanticnonnull-directive",children:"6"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-7-propagateerror-directive",children:"7"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-8-transitional-non-null-appendix",children:"8"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\ud83d\udeab\ud83d\udc4d"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"})]})})]}),"\n",(0,i.jsx)(n.p,{children:"Criteria score: \ud83e\udd48"}),"\n",(0,i.jsx)(n.h2,{id:"-b-existing-executable-documents-should-retain-validity-and-meaning",children:"\ud83c\udfaf B. Existing executable documents should retain validity and meaning"}),"\n",(0,i.jsx)(n.p,{children:"Users should be able to adopt semantic nullability into an existing schema, and\nwhen doing so all existing operations should remain valid, and should have the\nsame meaning as they always did."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"1"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-2-strict-semantic-nullability",children:"2"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-3-new-semantic-non-null-type-usurping--syntax",children:"3"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-4-new-semantic-non-null-type-with--used-for-nullable-types",children:"4"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"5"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-6-semanticnonnull-directive",children:"6"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-7-propagateerror-directive",children:"7"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-8-transitional-non-null-appendix",children:"8"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\ud83d\udeab"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"})]})})]}),"\n",(0,i.jsx)(n.p,{children:"Criteria score: \ud83e\udd48"}),"\n",(0,i.jsx)(n.h2,{id:"-c-unadorned-type-should-mean-nullable",children:"\ud83c\udfaf C. Unadorned type should mean nullable"}),"\n",(0,i.jsx)(n.p,{children:"GraphQL has been public for 10 years and there's a lot of content out there\nnoting that GraphQL types are nullable by default (unadorned type is nullable)\nand our changes should not invalidate this content."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"1"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-2-strict-semantic-nullability",children:"2"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-3-new-semantic-non-null-type-usurping--syntax",children:"3"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-4-new-semantic-non-null-type-with--used-for-nullable-types",children:"4"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"5"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-6-semanticnonnull-directive",children:"6"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-7-propagateerror-directive",children:"7"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-8-transitional-non-null-appendix",children:"8"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\ud83d\udeab"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\ud83d\udeab"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"})]})})]}),"\n",(0,i.jsx)(n.p,{children:"Criteria score: \ud83e\udd49"}),"\n",(0,i.jsx)(n.h2,{id:"-d-syntax-should-be-obvious-to-programmers",children:"\ud83c\udfaf D. Syntax should be obvious to programmers"}),"\n",(0,i.jsx)(n.p,{children:"The GraphQL languages similarity to JSON is one of its strengths, making it\nimmediately feel familiar. Syntax used should feel obvious to developers new to\nGraphQL."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"1"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-2-strict-semantic-nullability",children:"2"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-3-new-semantic-non-null-type-usurping--syntax",children:"3"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-4-new-semantic-non-null-type-with--used-for-nullable-types",children:"4"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"5"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-6-semanticnonnull-directive",children:"6"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-7-propagateerror-directive",children:"7"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-8-transitional-non-null-appendix",children:"8"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\ud83d\udeab"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u26a0\ufe0f"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"})]})})]}),"\n",(0,i.jsx)(n.p,{children:"Criteria score: \ud83e\udd47"}),"\n",(0,i.jsx)(n.h2,{id:"-e-syntax-used-in-sdl-and-in-executable-documents-should-be-consistent-with-sdl",children:"\ud83c\udfaf E. Syntax used in SDL and in executable documents should be consistent with SDL"}),"\n",(0,i.jsx)(n.p,{children:"When a user wishes to replace the value for an input field or argument with a\nvariable in their GraphQL operation, the type syntax should be either identical\nor similar, and should carry the same meaning."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"1"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-2-strict-semantic-nullability",children:"2"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-3-new-semantic-non-null-type-usurping--syntax",children:"3"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-4-new-semantic-non-null-type-with--used-for-nullable-types",children:"4"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"5"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-6-semanticnonnull-directive",children:"6"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-7-propagateerror-directive",children:"7"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-8-transitional-non-null-appendix",children:"8"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\ud83d\udeab"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"})]})})]}),"\n",(0,i.jsx)(n.p,{children:"Criteria score: \ud83e\udd47"}),"\n",(0,i.jsx)(n.h2,{id:"-f-alternative-syntaxes-should-not-cause-confusion",children:"\ud83c\udfaf F. Alternative syntaxes should not cause confusion"}),"\n",(0,i.jsx)(n.p,{children:"Where a proposal allows alternative syntaxes to be used, the two syntaxes should\nnot cause confusion."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"1"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-2-strict-semantic-nullability",children:"2"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-3-new-semantic-non-null-type-usurping--syntax",children:"3"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-4-new-semantic-non-null-type-with--used-for-nullable-types",children:"4"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"5"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-6-semanticnonnull-directive",children:"6"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-7-propagateerror-directive",children:"7"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-8-transitional-non-null-appendix",children:"8"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\ud83d\udeab"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"})]})})]}),"\n",(0,i.jsx)(n.p,{children:"Criteria score: \ud83e\udd47"}),"\n",(0,i.jsx)(n.h2,{id:"-g-error-propagation-boundaries-should-not-change-in-existing-executable-documents",children:"\ud83c\udfaf G. Error propagation boundaries should not change in existing executable documents"}),"\n",(0,i.jsx)(n.p,{children:'An expansion of B, this states that the proposal will not change where errors\npropagate to when error propagation is enabled (i.e. existing documents will\nstill keep errors local to the same positions that they did when they were\npublished), allowing for the "partial success" feature of GraphQL to continue to\nshine and not compromising the resiliency of legacy deployed app versions.'}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"1"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-2-strict-semantic-nullability",children:"2"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-3-new-semantic-non-null-type-usurping--syntax",children:"3"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-4-new-semantic-non-null-type-with--used-for-nullable-types",children:"4"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"5"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-6-semanticnonnull-directive",children:"6"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-7-propagateerror-directive",children:"7"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-8-transitional-non-null-appendix",children:"8"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\ud83d\udeab"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u26a0\ufe0f"}),(0,i.jsx)(n.td,{children:"\u2705"})]})})]}),"\n",(0,i.jsx)(n.p,{children:"Criteria score: \ud83e\udd48"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2702\ufe0f Objection: proposal to lower the score to \ud83e\udd48. With enough advance notice and a clear upgrade\npath for legacy apps, the tradeoff might be acceptable."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"-h-implementation-and-spec-simplicity",children:"\ud83c\udfaf H. Implementation and spec simplicity"}),"\n",(0,i.jsx)(n.p,{children:"The implementation required to make the proposal work should be simple."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"1"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-2-strict-semantic-nullability",children:"2"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-3-new-semantic-non-null-type-usurping--syntax",children:"3"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-4-new-semantic-non-null-type-with--used-for-nullable-types",children:"4"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"5"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-6-semanticnonnull-directive",children:"6"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-7-propagateerror-directive",children:"7"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-8-transitional-non-null-appendix",children:"8"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\ud83d\udeab"}),(0,i.jsx)(n.td,{children:"\ud83d\udeab"}),(0,i.jsx)(n.td,{children:"\ud83d\udeab"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"})]})})]}),"\n",(0,i.jsx)(n.p,{children:"Criteria score: \ud83e\udd47"}),"\n",(0,i.jsx)(n.h2,{id:"-i-syntax-used-in-executable-documents-should-be-unchanged",children:"\ud83c\udfaf I. Syntax used in executable documents should be unchanged"}),"\n",(0,i.jsx)(n.p,{children:'Executable documents do not differentiate between semantic and strict non-null\nsince inputs never handle "errors" ("null only on error" is the same as "not\nnull" on input). As such, there\'s no benefit to clients for the syntax of\nexecutable documents to change.'}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"1"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-2-strict-semantic-nullability",children:"2"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-3-new-semantic-non-null-type-usurping--syntax",children:"3"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-4-new-semantic-non-null-type-with--used-for-nullable-types",children:"4"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"5"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-6-semanticnonnull-directive",children:"6"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-7-propagateerror-directive",children:"7"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-8-transitional-non-null-appendix",children:"8"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\ud83d\udeab"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"})]})})]}),"\n",(0,i.jsx)(n.p,{children:"Criteria score: \ud83e\udd48"}),"\n",(0,i.jsx)(n.h2,{id:"-j-type-reasoning-should-remain-local",children:"\ud83c\udfaf J. Type reasoning should remain local"}),"\n",(0,i.jsxs)(n.p,{children:["The type of a field (",(0,i.jsx)(n.code,{children:"foo: Int"}),") can be determined by looking at the field and\nits type; the reader should not have to read a document or schema directive to\ndetermine how the type should be interpreted."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"1"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-2-strict-semantic-nullability",children:"2"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-3-new-semantic-non-null-type-usurping--syntax",children:"3"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-4-new-semantic-non-null-type-with--used-for-nullable-types",children:"4"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"5"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-6-semanticnonnull-directive",children:"6"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-7-propagateerror-directive",children:"7"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-8-transitional-non-null-appendix",children:"8"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u26a0\ufe0f"}),(0,i.jsx)(n.td,{children:"\ud83d\udeab"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u26a0\ufe0f"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"})]})})]}),"\n",(0,i.jsx)(n.p,{children:"Criteria score: \ud83e\udd47"}),"\n",(0,i.jsx)(n.h2,{id:"-k-introspection-must-be-backwards-compatible",children:"\ud83c\udfaf K. Introspection must be backwards compatible"}),"\n",(0,i.jsx)(n.p,{children:"We do not want to break existing tooling."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"1"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-2-strict-semantic-nullability",children:"2"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-3-new-semantic-non-null-type-usurping--syntax",children:"3"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-4-new-semantic-non-null-type-with--used-for-nullable-types",children:"4"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"5"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-6-semanticnonnull-directive",children:"6"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-7-propagateerror-directive",children:"7"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-8-transitional-non-null-appendix",children:"8"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u26a0\ufe0f"}),(0,i.jsx)(n.td,{children:"\u2705"})]})})]}),"\n",(0,i.jsx)(n.p,{children:"Criteria score: \ud83e\udd48"}),"\n",(0,i.jsx)(n.h2,{id:"-l-general-graphql-consumers-should-only-need-to-think-about-nullable-vs-non-nullable",children:"\ud83c\udfaf L. General GraphQL consumers should only need to think about nullable vs non-nullable"}),"\n",(0,i.jsx)(n.p,{children:"Schema authors and client frameworks can handle different types of nullability based around\nerror handling and error propagation, but consumers (frontend developers) should only need\nto deal with nullable or non-nullable as presented to them by their client framework of choice."}),"\n",(0,i.jsx)(n.p,{children:"May contradict: M"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"1"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-2-strict-semantic-nullability",children:"2"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-3-new-semantic-non-null-type-usurping--syntax",children:"3"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-4-new-semantic-non-null-type-with--used-for-nullable-types",children:"4"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"5"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-6-semanticnonnull-directive",children:"6"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-7-propagateerror-directive",children:"7"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-8-transitional-non-null-appendix",children:"8"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u26a0\ufe0f"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"})]})})]}),"\n",(0,i.jsx)(n.p,{children:"Criteria score: \ud83e\udd48"}),"\n",(0,i.jsx)(n.h2,{id:"-m-the-sdl-should-have-exactly-one-form-used-by-all-producers-and-consumers",children:"\ud83c\udfaf M. The SDL should have exactly one form used by all producers and consumers"}),"\n",(0,i.jsx)(n.p,{children:"The SDL should not be influenced by client features such as local extensions and\nerror propagation mechanics, and should always represent the true full source\nschema SDL."}),"\n",(0,i.jsx)(n.p,{children:"May contradict: L"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"1"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-2-strict-semantic-nullability",children:"2"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-3-new-semantic-non-null-type-usurping--syntax",children:"3"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-4-new-semantic-non-null-type-with--used-for-nullable-types",children:"4"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"5"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-6-semanticnonnull-directive",children:"6"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-7-propagateerror-directive",children:"7"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-8-transitional-non-null-appendix",children:"8"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u26a0\ufe0f"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"})]})})]}),"\n",(0,i.jsx)(n.p,{children:"Criteria score: \ud83e\udd47"}),"\n",(0,i.jsx)(n.h2,{id:"-n-the-solution-should-add-value-even-with-error-propagation-enabled",children:"\ud83c\udfaf N. The solution should add value even with error propagation enabled"}),"\n",(0,i.jsx)(n.p,{children:"Even when error propagation is enabled, it's valuable to be able to tell the\ndifference between a field that is truly (semantically) nullable, and one\nthat's only nullable because errors may occur. GraphQL-TOE can be used in such\nsituations so that codegen can safely use non-nullable types in semantically\nnon-nullable positions."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"1"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-2-strict-semantic-nullability",children:"2"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-3-new-semantic-non-null-type-usurping--syntax",children:"3"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-4-new-semantic-non-null-type-with--used-for-nullable-types",children:"4"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"5"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-6-semanticnonnull-directive",children:"6"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-7-propagateerror-directive",children:"7"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-8-transitional-non-null-appendix",children:"8"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\ud83d\udeab"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"})]})})]}),"\n",(0,i.jsx)(n.p,{children:"Criteria score: \ud83e\udd49"}),"\n",(0,i.jsx)(n.h2,{id:"-o-should-not-have-breaking-changes-for-existing-executable-documents",children:"\ud83c\udfaf O. Should not have breaking changes for existing executable documents"}),"\n",(0,i.jsx)(n.p,{children:"It should be possible to enable the solution without negatively impacting\nexisting deployed clients."}),"\n",(0,i.jsx)(n.p,{children:"Per Lee:"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"A breaking change is a client observable change in behavior. The decade old\nGraphQL query should work in the same way as it always has.  (We sometimes\nallow inconsequential changes in behavior, but bubbling the error up isn't\ninconsequential.)"}),"\n"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"1"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-2-strict-semantic-nullability",children:"2"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-3-new-semantic-non-null-type-usurping--syntax",children:"3"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-4-new-semantic-non-null-type-with--used-for-nullable-types",children:"4"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"5"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-6-semanticnonnull-directive",children:"6"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-7-propagateerror-directive",children:"7"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-8-transitional-non-null-appendix",children:"8"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\ud83d\udeab"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u26a0\ufe0f"}),(0,i.jsx)(n.td,{children:"\u2705"})]})})]}),"\n",(0,i.jsxs)(n.p,{children:["Note: though this criteria is currently not considered due to overlap with B\nand G, it acts as a reminder to look for other forms of breaking change, and\nhelps to reason ",(0,i.jsx)(n.em,{children:"why"})," B and G are important."]}),"\n",(0,i.jsx)(n.p,{children:"Criteria score: X (not considered - covered by B and G)"}),"\n",(0,i.jsx)(n.h2,{id:"-p-the-solution-should-result-in-users-marking-all-semantically-non-null-fields-as-such",children:"\ud83c\udfaf P. The solution should result in users marking all semantically non-null fields as such"}),"\n",(0,i.jsx)(n.p,{children:"When a field returns data that the business logic dictates does not and will\nnever return a legitimate (non-error) null, the schema authors should have no\nhesitation over marking it as semantically non-nullable - and thus all\nsemantically non-nullable fields should be marked as such."}),"\n",(0,i.jsx)(n.p,{children:"Per Benoit:"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Not sure how to express it well, but I feel there should be a criteria to\nmean something like \u201cthe solution encourages that eventually most fields in\nmost schemas are semantically non null\u201d. As a client developer that\u2019s kind of\nan outcome of this whole effort I\u2019d like to see happening."}),"\n"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"1"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-2-strict-semantic-nullability",children:"2"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-3-new-semantic-non-null-type-usurping--syntax",children:"3"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-4-new-semantic-non-null-type-with--used-for-nullable-types",children:"4"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"5"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-6-semanticnonnull-directive",children:"6"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-7-propagateerror-directive",children:"7"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-8-transitional-non-null-appendix",children:"8"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\ud83d\udeab"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\ud83d\udeab"}),(0,i.jsx)(n.td,{children:"\u2705"})]})})]}),"\n",(0,i.jsx)(n.p,{children:"Criteria score: \ud83e\udd47"}),"\n",(0,i.jsx)(n.h2,{id:"-q-migrating-the-unadorned-output-type-to-other-forms-of-nullability-should-be-non-breaking",children:"\ud83c\udfaf Q. Migrating the unadorned output type to other forms of nullability should be non-breaking"}),"\n",(0,i.jsx)(n.p,{children:"The default (unadorned) type should be a type that you can migrate away from,\nonce nullability expectations become more concrete, without breaking existing\nclient queries."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"1"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-2-strict-semantic-nullability",children:"2"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-3-new-semantic-non-null-type-usurping--syntax",children:"3"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-4-new-semantic-non-null-type-with--used-for-nullable-types",children:"4"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"5"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-6-semanticnonnull-directive",children:"6"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-7-propagateerror-directive",children:"7"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-8-transitional-non-null-appendix",children:"8"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\ud83d\udeab"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\ud83d\udeab"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"})]})})]}),"\n",(0,i.jsxs)(n.p,{children:["Note: this is not necessarily a duplicate of C as it doesn't specifically\nrequire\u200b the unadorned type be nullable, however no proposal currently proposes\na mechanism for moving from any non-nullable type to a nullable type in a\nnon-breaking way, and thus this criteria is ",(0,i.jsx)(n.em,{children:"currently"})," discounted."]}),"\n",(0,i.jsx)(n.p,{children:"Criteria score: X (not considered)"}),"\n",(0,i.jsx)(n.h2,{id:"-r-semantic-nullability-should-only-impact-outputs-not-inputs",children:"\ud83c\udfaf R. Semantic nullability should only impact outputs, not inputs"}),"\n",(0,i.jsx)(n.p,{children:'There\'s no meaningful difference between semantic non-null and strict non-null\non input, since inputs do not handle errors (and thus "null only on error"\ndescribes a situation that cannot occur).'}),"\n",(0,i.jsx)(n.p,{children:"Inputs include: field arguments, directive arguments, and input fields."}),"\n",(0,i.jsx)(n.p,{children:"As such:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["the syntax used to represent input nullability in SDL (",(0,i.jsx)(n.code,{children:"Int"})," = nullable, and\n",(0,i.jsx)(n.code,{children:"Int!"})," = non-nullable) should be unchanged"]}),"\n",(0,i.jsxs)(n.li,{children:["the representation in introspection for inputs (namely the ",(0,i.jsx)(n.code,{children:"NON_NULL"})," type\nwrapper) should be unchanged"]}),"\n"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"1"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-2-strict-semantic-nullability",children:"2"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-3-new-semantic-non-null-type-usurping--syntax",children:"3"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-4-new-semantic-non-null-type-with--used-for-nullable-types",children:"4"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"5"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-6-semanticnonnull-directive",children:"6"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-7-propagateerror-directive",children:"7"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-8-transitional-non-null-appendix",children:"8"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\ud83d\udeab"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2705"})]})})]}),"\n",(0,i.jsx)(n.p,{children:"Criteria score: \ud83e\udd48"}),"\n",(0,i.jsx)(n.h2,{id:"-s-should-be-incrementally-adoptable",children:"\ud83c\udfaf S. Should be incrementally adoptable"}),"\n",(0,i.jsx)(n.p,{children:"We want to enable schema designers to solve developers pain points with the minimum of fuss;\nlarge scale schema transforms are expensive - especially when they cascade to subschemas and/or schemas you don't control.\nA schema designer should be able to mark an individual response position as semantically non-null without requiring a big lift.\nError-handling clients should see value from this very first interaction."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"1"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-2-strict-semantic-nullability",children:"2"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-3-new-semantic-non-null-type-usurping--syntax",children:"3"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-4-new-semantic-non-null-type-with--used-for-nullable-types",children:"4"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"5"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-6-semanticnonnull-directive",children:"6"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-7-propagateerror-directive",children:"7"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-8-transitional-non-null-appendix",children:"8"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\ud83d\udeab"}),(0,i.jsx)(n.td,{children:"\u2705"})]})})]}),"\n",(0,i.jsx)(n.p,{children:"Criteria score: \u2754"}),"\n",(0,i.jsx)(n.h2,{id:"-t-should-be-incrementally-removable",children:"\ud83c\udfaf T. Should be incrementally removable"}),"\n",(0,i.jsx)(n.p,{children:"Once no legacy clients are using a field,\na schema designer should be able to update its types to use true nullability (removing its semantic nullability concerns) without impacting other fields that are still in use by legacy clients.\nOver time, the number of fields having explicit semantic nullability markups should trend downwards.\nNo big-bang multi-subschema orchastrated transition should be required."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"1"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-2-strict-semantic-nullability",children:"2"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-3-new-semantic-non-null-type-usurping--syntax",children:"3"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-4-new-semantic-non-null-type-with--used-for-nullable-types",children:"4"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"5"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-6-semanticnonnull-directive",children:"6"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-7-propagateerror-directive",children:"7"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-8-transitional-non-null-appendix",children:"8"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2705"})]})})]}),"\n",(0,i.jsx)(n.p,{children:"Criteria score: \u2754"}),"\n",(0,i.jsx)(n.h2,{id:"-u-legacy-tooling-and-clients-should-safely-interpret-sdl-even-when-ignoring-directives",children:"\ud83c\udfaf U. Legacy tooling and clients should safely interpret SDL even when ignoring directives"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://github.com/graphql/nullability-wg/discussions/98",children:"Meta's evaluation of semantic nullability proposals"})," has revealed that Meta deal heavily in SDL,\nand that their various tooling ignores directives that they don't recognize.\nA field such as solution 8's ",(0,i.jsx)(n.code,{children:"foo: Int! @noPropagate"})," or solution 7's ",(0,i.jsx)(n.code,{children:"foo: Int!"})," would be interpreted by existing such tooling as strictly non-nullable,\nwhich is incorrect since these positions may be null on error.\nThis would require\u200b all tooling to be migrated before such solutions could be used.\nIt would be very hard to detect tooling that was missed if the syntax remained valid - issues would be discovered in production - so\nif the response nullability would change then a syntax error should be thrown (which should score as \u26a0\ufe0f)."]}),"\n",(0,i.jsx)(n.p,{children:"For the avoidance of doubt:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Interpretting Semantic Non-Null as Nullable is safe for existing clients and tooling."}),"\n",(0,i.jsx)(n.li,{children:"Interpretting Semantic Non-Null as Non-Null is unsafe for existing clients and tooling."}),"\n"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"1"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-2-strict-semantic-nullability",children:"2"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-3-new-semantic-non-null-type-usurping--syntax",children:"3"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-4-new-semantic-non-null-type-with--used-for-nullable-types",children:"4"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"5"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-6-semanticnonnull-directive",children:"6"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-7-propagateerror-directive",children:"7"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-8-transitional-non-null-appendix",children:"8"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u2705\u26a0\ufe0f"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2705"}),(0,i.jsx)(n.td,{children:"\ud83d\udeab"}),(0,i.jsx)(n.td,{children:"\u2705\ud83d\udeab"})]})})]}),"\n",(0,i.jsx)(n.p,{children:"Criteria score: \u2754"}),"\n",(0,i.jsx)(n.p,{children:"\x3c!--"}),"\n",(0,i.jsx)(n.p,{children:"Template for new items:"}),"\n",(0,i.jsx)(n.h2,{id:"-x-title",children:"\ud83c\udfaf X. Title"}),"\n",(0,i.jsx)(n.p,{children:"DESCRIPTION"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"1"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-2-strict-semantic-nullability",children:"2"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-3-new-semantic-non-null-type-usurping--syntax",children:"3"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-4-new-semantic-non-null-type-with--used-for-nullable-types",children:"4"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"5"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-6-semanticnonnull-directive",children:"6"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-7-propagateerror-directive",children:"7"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.a,{href:"#-8-transitional-non-null-appendix",children:"8"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2754"}),(0,i.jsx)(n.td,{children:"\u2754"})]})})]}),"\n",(0,i.jsx)(n.p,{children:"Criteria score: \u2754"}),"\n",(0,i.jsx)(n.p,{children:"--\x3e"}),"\n",(0,i.jsx)(n.h1,{id:"-possible-solutions",children:"\ud83d\udea7 Possible Solutions"}),"\n",(0,i.jsx)(n.p,{children:"The community has imagined a variety of possible solutions, synthesized here."}),"\n",(0,i.jsxs)(n.p,{children:["Each solution is identified with a ",(0,i.jsx)(n.code,{children:"Number"})," so they can be referenced in the\nrest of the document. New solutions must be added to the end of the list."]}),"\n",(0,i.jsxs)(n.p,{children:["Some of the solutions have been ruled out and are kept here for historical\nreasons. Those solutions are folded in a ",(0,i.jsx)(n.code,{children:"<details>"})," tag."]}),"\n",(0,i.jsx)(n.p,{children:"Semantic nullability is only relevant to output positions, so when comparing\nsyntax we will look for changes versus the current syntax used to represent\nthese types:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{}),(0,i.jsx)(n.th,{children:"Input syntax"}),(0,i.jsx)(n.th,{children:"Output syntax"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Semantically nullable"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Semantically non-nullable"}),(0,i.jsx)(n.td,{children:"-"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Strictly non-nullable"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int!"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int!"})})]})]})]}),"\n",(0,i.jsxs)(n.h2,{id:"-1-new-semantic-non-null-type-represented-by-",children:['\ud83d\udca1 1. New "Semantic Non-Null" type, represented by ',(0,i.jsx)(n.code,{children:"*"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Champion"}),": @benjie"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Spec edits: ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/pull/1065",children:"https://github.com/graphql/graphql-spec/pull/1065"})]}),"\n",(0,i.jsxs)(n.li,{children:["GraphQL.js implementation: ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-js/pull/4192",children:"https://github.com/graphql/graphql-js/pull/4192"})]}),"\n",(0,i.jsxs)(n.li,{children:["Additional tools:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://www.npmjs.com/package/graphql-toe",children:"GraphQL-TOE"})," - throw on error\nwhen reading from an errored field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://www.npmjs.com/package/graphql-sock",children:"GraphQL-SOCK"})," - Semantic Output\nConversion Kit - takes a schema involving semanantic non-null type and\nconverts it to a schema using traditional syntax (respecting the client's\nerror handling behaviors) for compatibility with existing (semantic non-null\nunaware) tooling"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["This proposal introduces a new Semantic Non-Null type using a prefix or postfix\nsymbol (currently ",(0,i.jsx)(n.code,{children:"*"})," postfix) to indicate a field that will be null only on\nerror. Existing types and operations are unaffected, and usage can be migrated\non a per-type-position basis. Moving from a nullable type to a semantic\nnon-nullable type (on output) is a non-breaking change. Semantic non-nullable is\nmeaningless on input."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"type Post {\n  # Every post belongs to a topic, however don't blow the post up if retrieval of the topic fails.\n  topic: Topic*\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Querying a semantic non-null field is the same as querying any other field."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{}),(0,i.jsx)(n.th,{children:"Input syntax"}),(0,i.jsx)(n.th,{children:"Output syntax"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Semantically nullable"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Semantically non-nullable"}),(0,i.jsx)(n.td,{children:"-"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"Int"})," \u21d2 ",(0,i.jsx)(n.code,{children:"Int*"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Strictly non-nullable"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int!"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int!"})})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"-variations",children:"\ud83c\udfb2 Variations"}),"\n",(0,i.jsxs)(n.p,{children:["Various\n",(0,i.jsx)(n.a,{href:"https://gist.github.com/benjie/19d784721d1658b89fd8954e7ee07034",children:"options for the syntax"}),"\nhave been discussed the choice of symbol comes down mostly to aesthetics."]}),"\n",(0,i.jsx)(n.h3,{id:"\ufe0f-evaluation",children:"\u2696\ufe0f Evaluation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-a-graphql-should-be-able-to-indicate-which-nullable-fields-should-become-non-nullable-when-error-propagation-is-disabled",children:"A"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-b-existing-executable-documents-should-retain-validity-and-meaning",children:"B"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Existing symbology unchanged."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-c-unadorned-type-should-mean-nullable",children:"C"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Existing symbology unchanged."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-d-syntax-should-be-obvious-to-programmers",children:"D"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\ud83d\udeab ",(0,i.jsx)(n.code,{children:"Int*"})," syntax is not immediately obvious."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-e-syntax-used-in-sdl-and-in-executable-documents-should-be-consistent-with-sdl",children:"E"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Same syntax."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-f-alternative-syntaxes-should-not-cause-confusion",children:"F"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Same syntax."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-g-error-propagation-boundaries-should-not-change-in-existing-executable-documents",children:"G"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Error capture positions unchanged when error propagation enabled"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-h-implementation-and-spec-simplicity",children:"H"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Implementation and spec simplicity."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-i-syntax-used-in-executable-documents-should-be-unchanged",children:"I"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.code,{children:"*"})," doesn't apply on input, so syntax is unchanged."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-j-type-reasoning-should-remain-local",children:"J"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Local syntax only"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-k-introspection-must-be-backwards-compatible",children:"K"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 Introspection backwards compatible via ",(0,i.jsx)(n.code,{children:"__Field.type(includeSemanticNonNull: Boolean! = false)"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-l-general-graphql-consumers-should-only-need-to-think-about-nullable-vs-non-nullable",children:"L"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 Proposal encourages consumers to use client-produced SDL which only uses traditional nullability (",(0,i.jsx)(n.code,{children:"Type"}),"/",(0,i.jsx)(n.code,{children:"Type!"}),")"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-m-the-sdl-should-have-exactly-one-form-used-by-all-producers-and-consumers",children:"M"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 You can use the same SDL everywhere, but that's not what this solution\nencourages."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-n-the-solution-should-add-value-even-with-error-propagation-enabled",children:"N"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Indicates semantically non-null and strictly non-null types separately"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-o-should-not-have-breaking-changes-for-existing-executable-documents",children:"O"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Client syntax unchanged"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-p-the-solution-should-result-in-users-marking-all-semantically-non-null-fields-as-such",children:"P"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 There are no drawbacks to adding semantically non-nullable fields"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-q-migrating-the-unadorned-output-type-to-other-forms-of-nullability-should-be-non-breaking",children:"Q"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-r-semantic-nullability-should-only-impact-outputs-not-inputs",children:"R"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.code,{children:"*"})," only needed in output positions, input positions unchanged"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-s-should-be-incrementally-adoptable",children:"S"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 Add a ",(0,i.jsx)(n.code,{children:"*"})," and a type is now semantic non-nullable, no other changes needed."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-t-should-be-incrementally-removable",children:"T"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 Change a ",(0,i.jsx)(n.code,{children:"*"})," to a ",(0,i.jsx)(n.code,{children:"!"})," and the type is now simply non-nullable, no other changes needed."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-u-legacy-tooling-and-clients-should-safely-interpret-sdl-even-when-ignoring-directives",children:"U"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 If you use client-generated SDL then there is no change in meaning or syntax."}),"\n",(0,i.jsx)(n.li,{children:"\u26a0\ufe0f  If you use common SDL across all clients (new and old) then a syntax error will be raised."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"-2-strict-semantic-nullability",children:'\ud83d\udca1 2. "Strict Semantic Nullability"'}),"\n",(0,i.jsxs)(l,{children:[(0,i.jsx)("summary",{children:"Rejected - click for details"}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Champion"}),": @leebyron"]}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Discussion: ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/discussions/1410",children:"https://github.com/graphql/graphql-wg/discussions/1410"})]}),"\n"]}),(0,i.jsxs)(n.p,{children:["This proposal introduces a ",(0,i.jsx)(n.code,{children:"@strictNullability"})," directive on the schema. Types\nin schemas using this directive would now be semantically non-nullable by\ndefault, and a new semantically nullable type is introduced (using the ",(0,i.jsx)(n.code,{children:"?"}),"\nsymbol) to indicate that a position may semantically be null."]}),(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{}),(0,i.jsx)(n.th,{children:"Input syntax"}),(0,i.jsx)(n.th,{children:"Output syntax"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Semantically nullable"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"Int"})," \u21d2 ???"]}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"Int"})," \u21d2 ",(0,i.jsx)(n.code,{children:"Int?"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Semantically non-nullable"}),(0,i.jsx)(n.td,{children:"-"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Strictly non-nullable"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"Int!"})," \u21d2 ???"]}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int!"})})]})]})]}),(0,i.jsx)(n.h3,{id:"\ufe0f-evaluation-1",children:"\u2696\ufe0f Evaluation"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-a-graphql-should-be-able-to-indicate-which-nullable-fields-should-become-non-nullable-when-error-propagation-is-disabled",children:"A"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-b-existing-executable-documents-should-retain-validity-and-meaning",children:"B"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\ud83d\udeab Though existing documents remain ",(0,i.jsx)(n.em,{children:"valid"}),', input variables using the\nunadorned type now mean "semantically non-nullable" and will no longer\naccept ',(0,i.jsx)(n.code,{children:"null"})," values? {Confirmation by Lee pending.}"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-c-unadorned-type-should-mean-nullable",children:"C"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:['\ud83d\udeab GraphQL is no longer "nullable by default", and ',(0,i.jsx)(n.code,{children:"Int"})," no longer\nrepresents a nullable integer."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-d-syntax-should-be-obvious-to-programmers",children:"D"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.code,{children:"Int?"})," is commonly used to indicate nullablility in programming languages\nand ",(0,i.jsx)(n.code,{children:"Int!"})," indicating non-nullable or danger is common. ",(0,i.jsx)(n.code,{children:"Int"})," is less\nobvious when ",(0,i.jsx)(n.code,{children:"?"})," and ",(0,i.jsx)(n.code,{children:"!"})," variants exist."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-e-syntax-used-in-sdl-and-in-executable-documents-should-be-consistent-with-sdl",children:"E"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 The same syntax is used on input and output."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-f-alternative-syntaxes-should-not-cause-confusion",children:"F"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 There is no alternative syntax."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-g-error-propagation-boundaries-should-not-change-in-existing-executable-documents",children:"G"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Error capture positions unchanged when error propagation enabled"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-h-implementation-and-spec-simplicity",children:"H"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\ud83d\udeab Implementation and spec simplicity."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-i-syntax-used-in-executable-documents-should-be-unchanged",children:"I"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2754"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-j-type-reasoning-should-remain-local",children:"J"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2754"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-k-introspection-must-be-backwards-compatible",children:"K"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2754"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-l-general-graphql-consumers-should-only-need-to-think-about-nullable-vs-non-nullable",children:"L"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2754"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-m-the-sdl-should-have-exactly-one-form-used-by-all-producers-and-consumers",children:"M"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2754"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-n-the-solution-should-add-value-even-with-error-propagation-enabled",children:"N"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Indicates semantically non-null and strictly non-null types separately"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-o-should-not-have-breaking-changes-for-existing-executable-documents",children:"O"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2754"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-p-the-solution-should-result-in-users-marking-all-semantically-non-null-fields-as-such",children:"P"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2754"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-q-migrating-the-unadorned-output-type-to-other-forms-of-nullability-should-be-non-breaking",children:"Q"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\ud83d\udeab ",(0,i.jsx)(n.code,{children:"Int"})," \u2192 ",(0,i.jsx)(n.code,{children:"Int?"})," is breaking"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-r-semantic-nullability-should-only-impact-outputs-not-inputs",children:"R"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2754"}),"\n"]}),"\n"]}),"\n"]})]}),"\n",(0,i.jsxs)(n.h2,{id:"-3-new-semantic-non-null-type-usurping--syntax",children:['\ud83d\udca1 3. New "Semantic Non-Null" type, usurping ',(0,i.jsx)(n.code,{children:"!"})," syntax"]}),"\n",(0,i.jsxs)(l,{children:[(0,i.jsx)("summary",{children:"Rejected - click for details"}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Champion"}),": @benjie"]}),(0,i.jsx)(n.p,{children:"This proposal is similar to proposal 1, but:"}),(0,i.jsxs)(n.p,{children:["It introduces a document-level directive, ",(0,i.jsx)(n.code,{children:"@semanticNullability"}),", which when\npresent on a document allows the ",(0,i.jsx)(n.code,{children:"!"})," suffix to be used to represent\nsemantically non-nullable output types, and a new ",(0,i.jsx)(n.code,{children:"!!"})," suffix to be used to\nrepresent strictly non-nullable output types."]}),(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Int!"}),' syntax simply means "non-nullable" on input, as it always has.\n(Note: input types are always either semantically nullable or strictly\nnon-nullable.)']}),(0,i.jsxs)(n.p,{children:["Syntax only changes when ",(0,i.jsx)(n.code,{children:"@semanticNullability"})," directive is present:"]}),(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{}),(0,i.jsx)(n.th,{children:"Input syntax"}),(0,i.jsx)(n.th,{children:"Output syntax"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Semantically nullable"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Semantically non-nullable"}),(0,i.jsx)(n.td,{children:"-"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"Int"})," \u21d2 ",(0,i.jsx)(n.code,{children:"Int!"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Strictly non-nullable"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int!"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"Int!"})," \u21d2 ",(0,i.jsx)(n.code,{children:"Int!!"})]})]})]})]}),(0,i.jsx)(n.p,{children:"All documents (both SDL and executable documents) retain their current meaning,\nand the semantically non-null type can be adopted in output positions on a\nper-document basis by adding the document directive."}),(0,i.jsx)(n.p,{children:'Since there\'s no difference between whether a type is "semantically" or\n"strictly" non-nullable on input (input does not represent errors), executable\ndocuments will retain their existing syntax in perpetuity and never need to use\nthis new directive - it\'s only used in the SDL.'}),(0,i.jsxs)(n.p,{children:["Further, it's proposed that the SDL production responsibility be pushed to the\nclient framework (Relay, Apollo, URQL, etc), which can reflect their own SDL for\nthe schema that honours their error behavior (e.g. throw on error), null\nhandling, and any client-local modifications (e.g. additional client-side\nfields/types). This client-produced SDL can use the traditional syntax and\nshould be used by tooling such as code generation - this further limits the\n",(0,i.jsx)(n.code,{children:"@semanticNullability"})," directive to only be used by schema and tooling authors,\nmeaning the vast majority of GraphQL consumers do not need to see it in their\nday-to-day work."]}),(0,i.jsx)(n.h3,{id:"\ufe0f-evaluation-2",children:"\u2696\ufe0f Evaluation"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-a-graphql-should-be-able-to-indicate-which-nullable-fields-should-become-non-nullable-when-error-propagation-is-disabled",children:"A"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-b-existing-executable-documents-should-retain-validity-and-meaning",children:"B"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Executable documents are not impacted by this proposal."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-c-unadorned-type-should-mean-nullable",children:"C"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.code,{children:"Int"})," means nullable still."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-d-syntax-should-be-obvious-to-programmers",children:"D"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.code,{children:"Int!"})," to indicate non-nullable is common in programming languages; and\n",(0,i.jsx)(n.code,{children:"Int!!"}),' looks like it indicates "danger".']}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-e-syntax-used-in-sdl-and-in-executable-documents-should-be-consistent-with-sdl",children:"E"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 Executable documents do not use ",(0,i.jsx)(n.code,{children:"!!"}),", and ",(0,i.jsx)(n.code,{children:"!"})," means non-nullable on both\ninput and output (the difference between semantic an strict non-null does\nnot occur on input)"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-f-alternative-syntaxes-should-not-cause-confusion",children:"F"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.code,{children:"Int"})," reatains its meaning across both modes, and ",(0,i.jsx)(n.code,{children:"Int!"})," means\nnon-nullable in both modes. Only the SDL ever uses ",(0,i.jsx)(n.code,{children:"Int!!"}),' and it still\nmeans non-null, just with the additional "kills parent on exception"\nbehavior.']}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-g-error-propagation-boundaries-should-not-change-in-existing-executable-documents",children:"G"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Error capture positions unchanged when error propagation enabled"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-h-implementation-and-spec-simplicity",children:"H"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\ud83d\udeab Implementation and spec simplicity."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-i-syntax-used-in-executable-documents-should-be-unchanged",children:"I"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Semantic non-null not relevant to inputs, so no reason to use directive in executable documents -> syntax unchanged."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-j-type-reasoning-should-remain-local",children:"J"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u26a0\ufe0f  Local reasoning holds for all but the schema authors; this is enabled\nthrough the use of client-generated SDL reflecting client extensions and\nerror propagation behavior. For schema authors, local reasoning in the\nsource SDL returns whether a field is nullable or non-nullable, but does\nnot differentiate between ",(0,i.jsx)(n.em,{children:"semantically"})," non-nullable and ",(0,i.jsx)(n.em,{children:"strictly"}),"\nnon-nullable."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-k-introspection-must-be-backwards-compatible",children:"K"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 Introspection backwards compatible via ",(0,i.jsx)(n.code,{children:"__Field.type(includeSemanticNonNull: Boolean! = false)"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-l-general-graphql-consumers-should-only-need-to-think-about-nullable-vs-non-nullable",children:"L"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 Proposal encourages consumers to use client-produced SDL which only uses traditional nullability (",(0,i.jsx)(n.code,{children:"Type"}),"/",(0,i.jsx)(n.code,{children:"Type!"}),")"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-m-the-sdl-should-have-exactly-one-form-used-by-all-producers-and-consumers",children:"M"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u26a0\ufe0f You can use the same SDL everywhere, but that's not what this solution\nencourages."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-n-the-solution-should-add-value-even-with-error-propagation-enabled",children:"N"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Indicates semantically non-null and strictly non-null types separately"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-o-should-not-have-breaking-changes-for-existing-executable-documents",children:"O"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Client syntax unchanged"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-p-the-solution-should-result-in-users-marking-all-semantically-non-null-fields-as-such",children:"P"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 There are no drawbacks to adding semantically non-nullable fields"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-q-migrating-the-unadorned-output-type-to-other-forms-of-nullability-should-be-non-breaking",children:"Q"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-r-semantic-nullability-should-only-impact-outputs-not-inputs",children:"R"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Syntax used for inputs is unchanged with or without the directive."}),"\n"]}),"\n"]}),"\n"]})]}),"\n",(0,i.jsxs)(n.h2,{id:"-4-new-semantic-non-null-type-with--used-for-nullable-types",children:['\ud83d\udca1 4. New "Semantic Non-Null" type, with ',(0,i.jsx)(n.code,{children:"?"})," used for nullable types"]}),"\n",(0,i.jsxs)(l,{children:[(0,i.jsx)("summary",{children:"Rejected - click for details"}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Champion"}),": none (put your name here to become the champion!)"]}),(0,i.jsxs)(n.p,{children:["This proposal builds on solution 3, but with a syntactic shuffle such that the\nunadorned type may be used as the semantically non-nullable type when the\ndirective is present, and a ",(0,i.jsx)(n.code,{children:"?"})," symbol is used to indicate a nullable position."]}),(0,i.jsxs)(n.p,{children:["Syntax only changes when ",(0,i.jsx)(n.code,{children:"@semanticNullability"})," directive is present:"]}),(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{}),(0,i.jsx)(n.th,{children:"Input syntax"}),(0,i.jsx)(n.th,{children:"Output syntax"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Semantically nullable"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"Int"})," \u21d2 ",(0,i.jsx)(n.code,{children:"Int?"})]}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"Int"})," \u21d2 ",(0,i.jsx)(n.code,{children:"Int?"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Semantically non-nullable"}),(0,i.jsx)(n.td,{children:"-"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Strictly non-nullable"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"Int!"})," \u21d2 ",(0,i.jsx)(n.code,{children:"Int"})]}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int!"})})]})]})]}),(0,i.jsx)(n.h3,{id:"\ufe0f-evaluation-3",children:"\u2696\ufe0f Evaluation"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-a-graphql-should-be-able-to-indicate-which-nullable-fields-should-become-non-nullable-when-error-propagation-is-disabled",children:"A"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-b-existing-executable-documents-should-retain-validity-and-meaning",children:"B"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Existing documents don't use the directive, and thus are not impacted."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-c-unadorned-type-should-mean-nullable",children:"C"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:['\ud83d\udeab With the directive present, GraphQL is no longer "nullable by default",\nand ',(0,i.jsx)(n.code,{children:"Int"})," no longer represents a nullable integer."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-d-syntax-should-be-obvious-to-programmers",children:"D"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.code,{children:"Int?"})," is commonly used to indicate nullablility in programming languages\nand ",(0,i.jsx)(n.code,{children:"Int!"})," indicating non-nullable or danger is common. ",(0,i.jsx)(n.code,{children:"Int"})," is less\nobvious when ",(0,i.jsx)(n.code,{children:"?"})," and ",(0,i.jsx)(n.code,{children:"!"})," variants exist."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-e-syntax-used-in-sdl-and-in-executable-documents-should-be-consistent-with-sdl",children:"E"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\ud83d\udeab If the schema uses ",(0,i.jsx)(n.code,{children:"@semanticNullability"})," but an operation document does\nnot, ",(0,i.jsx)(n.code,{children:"Int"})," has vastly different meanings: nullable on input but non-nullable\non output."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-f-alternative-syntaxes-should-not-cause-confusion",children:"F"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\ud83d\udeab ",(0,i.jsx)(n.code,{children:"Int"})," being nullable in one mode and non-nullable in the other mode is\nunexpected and will likely lead to confusion."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-g-error-propagation-boundaries-should-not-change-in-existing-executable-documents",children:"G"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Error capture positions unchanged when error propagation enabled"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-h-implementation-and-spec-simplicity",children:"H"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\ud83d\udeab Implementation and spec simplicity."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-i-syntax-used-in-executable-documents-should-be-unchanged",children:"I"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\ud83d\udeab Clients will need to move to using new syntax (",(0,i.jsx)(n.code,{children:"Type?"}),"/",(0,i.jsx)(n.code,{children:"Type"}),") or have syntax incongruent with schema SDL"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-j-type-reasoning-should-remain-local",children:"J"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\ud83d\udeab The nullability of ",(0,i.jsx)(n.code,{children:"Type"})," cannot be determined without checking for a document directive"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-k-introspection-must-be-backwards-compatible",children:"K"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 Introspection backwards compatible via ",(0,i.jsx)(n.code,{children:"__Field.type(includeSemanticNonNull: Boolean! = false)"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-l-general-graphql-consumers-should-only-need-to-think-about-nullable-vs-non-nullable",children:"L"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2754"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-m-the-sdl-should-have-exactly-one-form-used-by-all-producers-and-consumers",children:"M"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2754"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-n-the-solution-should-add-value-even-with-error-propagation-enabled",children:"N"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Indicates semantically non-null and strictly non-null types separately"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-o-should-not-have-breaking-changes-for-existing-executable-documents",children:"O"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Clients must opt in to new syntax with document directive"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-p-the-solution-should-result-in-users-marking-all-semantically-non-null-fields-as-such",children:"P"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 There are no drawbacks to adding semantically non-nullable fields"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-q-migrating-the-unadorned-output-type-to-other-forms-of-nullability-should-be-non-breaking",children:"Q"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\ud83d\udeab ",(0,i.jsx)(n.code,{children:"Int"})," \u2192 ",(0,i.jsx)(n.code,{children:"Int?"})," is breaking"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-r-semantic-nullability-should-only-impact-outputs-not-inputs",children:"R"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\ud83d\udeab Input positions have changed ",(0,i.jsx)(n.code,{children:"Int"})," \u21d2 ",(0,i.jsx)(n.code,{children:"Int?"}),", ",(0,i.jsx)(n.code,{children:"Int!"})," \u21d2 ",(0,i.jsx)(n.code,{children:"Int"})]}),"\n"]}),"\n"]}),"\n"]})]}),"\n",(0,i.jsx)(n.h2,{id:"-5-use-non-null-in-semantically-non-nullable-places-and-encourage-disabling-error-propagation",children:"\ud83d\udca1 5. Use non-null in semantically non-nullable places and encourage disabling error propagation"}),"\n",(0,i.jsxs)(l,{children:[(0,i.jsx)("summary",{children:"Rejected - click for details"}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Champion"}),": @martinbonnin"]}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Discussion: ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/nullability-wg/discussions/85",children:"https://github.com/graphql/nullability-wg/discussions/85"})]}),"\n"]}),(0,i.jsxs)(n.p,{children:["This proposal relies on the ability of clients to opt out of error propagation; instead of introducing a new type it instructs schema authors to optimize for error-handling clients and use the traditional non-null type (",(0,i.jsx)(n.code,{children:"!"}),") on all semantically non-null fields."]}),(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{}),(0,i.jsx)(n.th,{children:"Input syntax"}),(0,i.jsx)(n.th,{children:"Output syntax"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Semantically nullable"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Semantically non-nullable"}),(0,i.jsx)(n.td,{children:"-"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"Int"})," \u21d2 ",(0,i.jsx)(n.code,{children:"Int!"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Strictly non-nullable"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int!"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int!"})})]})]})]}),(0,i.jsx)(n.h3,{id:"\ufe0f-evaluation-4",children:"\u2696\ufe0f Evaluation"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-a-graphql-should-be-able-to-indicate-which-nullable-fields-should-become-non-nullable-when-error-propagation-is-disabled",children:"A"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\ud83d\udeab\ud83d\udc4d The nullability used in both error-propagation and no-error-propagation modes are the same. This is a feature, not a bug!"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-b-existing-executable-documents-should-retain-validity-and-meaning",children:"B"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 The change from nullable to non-nullable on output is backwards compatible from a type perspective; for impact on error boundaries see G."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-c-unadorned-type-should-mean-nullable",children:"C"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.code,{children:"Int"})," means nullable still."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-d-syntax-should-be-obvious-to-programmers",children:"D"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u26a0\ufe0f Adding ",(0,i.jsx)(n.code,{children:"@onError"})," to operations is not immediately intuitive but most error-handling clients should add it automatically, making it transparent to end users."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-e-syntax-used-in-sdl-and-in-executable-documents-should-be-consistent-with-sdl",children:"E"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Same syntax."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-f-alternative-syntaxes-should-not-cause-confusion",children:"F"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Same syntax."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-g-error-propagation-boundaries-should-not-change-in-existing-executable-documents",children:"G"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\ud83d\udeab Using non-null in more positions will change the error boundary positions when error propagation is enabled."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-h-implementation-and-spec-simplicity",children:"H"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Implementation and spec simplicity."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-i-syntax-used-in-executable-documents-should-be-unchanged",children:"I"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 No change"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-j-type-reasoning-should-remain-local",children:"J"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 No change"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-k-introspection-must-be-backwards-compatible",children:"K"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 No change"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-l-general-graphql-consumers-should-only-need-to-think-about-nullable-vs-non-nullable",children:"L"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 No change"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-m-the-sdl-should-have-exactly-one-form-used-by-all-producers-and-consumers",children:"M"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 No change"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-n-the-solution-should-add-value-even-with-error-propagation-enabled",children:"N"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\ud83d\udeab Solution actually decreases value when error propagation is enabled due to lowered resilience to errors."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-o-should-not-have-breaking-changes-for-existing-executable-documents",children:"O"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\ud83d\udeab Changing fields to strictly non-null causes errors to propagate further, a breaking change. (Duplicate of G.)"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-p-the-solution-should-result-in-users-marking-all-semantically-non-null-fields-as-such",children:"P"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\ud83d\udeab Though the solution states it encourages the adoption of non-null, doing so is a breaking change for existing clients and so adopters are likely to hesitate when marking some semantically non-nullable positions as such"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-q-migrating-the-unadorned-output-type-to-other-forms-of-nullability-should-be-non-breaking",children:"Q"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Same syntax."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-r-semantic-nullability-should-only-impact-outputs-not-inputs",children:"R"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Same syntax."}),"\n"]}),"\n"]}),"\n"]})]}),"\n",(0,i.jsxs)(n.h2,{id:"-6-semanticnonnull-directive",children:["\ud83d\udca1 6. ",(0,i.jsx)(n.code,{children:"@semanticNonNull"})," directive"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Champion"}),": @benjie"]}),"\n",(0,i.jsxs)(n.p,{children:["Outline: ",(0,i.jsx)(n.a,{href:"https://specs.apollo.dev/nullability/v0.4/#@semanticNonNull",children:"https://specs.apollo.dev/nullability/v0.4/#@semanticNonNull"})]}),"\n",(0,i.jsx)(n.p,{children:"This proposal relies on:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A new directive, ",(0,i.jsx)(n.code,{children:"@semanticNonNull"})]}),"\n",(0,i.jsxs)(n.li,{children:["Either:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A new introspection argument, ",(0,i.jsx)(n.code,{children:"includeSemanticNonNull"})," (",(0,i.jsx)(n.code,{children:"__Field.type(includeSemanticNonNull: Boolean! = false)"}),"), if represented as a type, or"]}),"\n",(0,i.jsxs)(n.li,{children:["A new introspection field, ",(0,i.jsx)(n.code,{children:"__Field.semanticNonNullLevels: [Int!]"}),", if represented as field metadata"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The directive (which is already adopted in a few places!) can be added to\nfields to indicate their semantic nullability (and that of their nested list positions)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"directive @semanticNonNull(levels: [Int!]! = [0]) on FIELD_DEFINITION\n\ntype Query {\n  nonNullListOfNonNullInt: [Int] @semanticNonNull(levels: [0, 1])\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The proposal is broadly similar to ",(0,i.jsx)(n.a,{href:"#-1-new-semantic-non-null-type-represented-by-",children:"solution 1"}),", but avoids\nintroducing new syntax. Interestingly, since the directive only applies on\n",(0,i.jsx)(n.code,{children:"FIELD_DEFINITION"})," it explicitly limits semantic nullability to output\npositions."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{}),(0,i.jsx)(n.th,{children:"Input syntax"}),(0,i.jsx)(n.th,{children:"Output syntax"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Semantically nullable"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Semantically non-nullable"}),(0,i.jsx)(n.td,{children:"-"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"Int"})," \u21d2 ",(0,i.jsx)(n.code,{children:"Int @semanticNotNull"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Strictly non-nullable"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int!"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int!"})})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"\ufe0f-evaluation-5",children:"\u2696\ufe0f Evaluation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-a-graphql-should-be-able-to-indicate-which-nullable-fields-should-become-non-nullable-when-error-propagation-is-disabled",children:"A"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-b-existing-executable-documents-should-retain-validity-and-meaning",children:"B"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Existing symbology unchanged."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-c-unadorned-type-should-mean-nullable",children:"C"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Existing symbology unchanged."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-d-syntax-should-be-obvious-to-programmers",children:"D"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 No syntax change (directive syntax already exists)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-e-syntax-used-in-sdl-and-in-executable-documents-should-be-consistent-with-sdl",children:"E"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Same syntax."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-f-alternative-syntaxes-should-not-cause-confusion",children:"F"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Same syntax."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-g-error-propagation-boundaries-should-not-change-in-existing-executable-documents",children:"G"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Error capture positions unchanged when error propagation enabled"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-h-implementation-and-spec-simplicity",children:"H"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Implementation and spec simplicity."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-i-syntax-used-in-executable-documents-should-be-unchanged",children:"I"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Directive does not apply to input positions."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-j-type-reasoning-should-remain-local",children:"J"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u26a0\ufe0f Though the directives are local to the field, the reader must still correlate the directive and the passed indexes with the types specified to conclude what the final type is."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-k-introspection-must-be-backwards-compatible",children:"K"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 Introspection backwards compatible via ",(0,i.jsx)(n.code,{children:"__Field.type(includeSemanticNonNull: Boolean! = false)"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-l-general-graphql-consumers-should-only-need-to-think-about-nullable-vs-non-nullable",children:"L"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u26a0\ufe0f  Depends whether we advise using client-generated SDL or not."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-m-the-sdl-should-have-exactly-one-form-used-by-all-producers-and-consumers",children:"M"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Same SDL everywhere."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-n-the-solution-should-add-value-even-with-error-propagation-enabled",children:"N"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Indicates semantically non-null and strictly non-null types separately."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-o-should-not-have-breaking-changes-for-existing-executable-documents",children:"O"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-p-the-solution-should-result-in-users-marking-all-semantically-non-null-fields-as-such",children:"P"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 Though there's no technical reason not to do so, though the mechanics of adding the directive (particularly when referencing positions inside lists) are tiresome in SDL-first schemas, decreasing likeliness that positions will be updated. (Code-first schemas are unaffected.) Further, the directives are likely to have a significant impact on the formatting of the SDL (",(0,i.jsx)(n.code,{children:"@semanticNonNull"})," is 16 characters, almost quarter of a line if wrap at 80), so designers may wish to only add them in the most critical of locations."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-q-migrating-the-unadorned-output-type-to-other-forms-of-nullability-should-be-non-breaking",children:"Q"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-r-semantic-nullability-should-only-impact-outputs-not-inputs",children:"R"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Directive is only valid on output positions."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-s-should-be-incrementally-adoptable",children:"S"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 Just add ",(0,i.jsx)(n.code,{children:"@semanticNonNull"})," directive to the field, no other changes needed."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-t-should-be-incrementally-removable",children:"T"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 Just remove ",(0,i.jsx)(n.code,{children:"@semanticNonNull"})," directive from the field and mark the relevant types non-nullable, no other changes needed."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-u-legacy-tooling-and-clients-should-safely-interpret-sdl-even-when-ignoring-directives",children:"U"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Stripping the directive results in types being interpreted as nullable, which is safe."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"-7-propagateerror-directive",children:["\ud83d\udca1 7. ",(0,i.jsx)(n.code,{children:"@propagateError"})," directive"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Champion"}),": @leebyron"]}),"\n",(0,i.jsxs)(n.p,{children:["Discussion: ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/discussions/1700",children:"https://github.com/graphql/graphql-wg/discussions/1700"})]}),"\n",(0,i.jsxs)(n.p,{children:["This proposal changes the ",(0,i.jsx)(n.code,{children:"!"})," symbol and the ",(0,i.jsx)(n.code,{children:"NON_NULL"}),' introspection kind both to mean "semantic non null" (allowing for ',(0,i.jsx)(n.code,{children:"null"})," on error). It introduces the ",(0,i.jsx)(n.code,{children:"@propagateError"})," directive that can be added to fields to indicate that they should propagate errors in order to provide backwards compatibility with existing deployed clients."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:" type Person {\n   id: ID! @propagateError\n   name: String\n   age: Int\n   picture: Url\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"\ufe0f-evaluation-6",children:"\u2696\ufe0f Evaluation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-a-graphql-should-be-able-to-indicate-which-nullable-fields-should-become-non-nullable-when-error-propagation-is-disabled",children:"A"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 semantically non-null without propagateError"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-b-existing-executable-documents-should-retain-validity-and-meaning",children:"B"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"~\u2705 This is true when existing services must ensure propagateError is set when adopting this behavior."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-c-unadorned-type-should-mean-nullable",children:"C"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Existing symbology unchanged."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-d-syntax-should-be-obvious-to-programmers",children:"D"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 No new symbols. No new types. Error bubbling was previously implicit behavior, now it is explicit."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-e-syntax-used-in-sdl-and-in-executable-documents-should-be-consistent-with-sdl",children:"E"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 No change to input types"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-f-alternative-syntaxes-should-not-cause-confusion",children:"F"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-g-error-propagation-boundaries-should-not-change-in-existing-executable-documents",children:"G"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u26a0\ufe0f With propagateErrorOnAllNonNullFields: true, adding ! (semantic non-null) in existing positions will change error propagation boundaries in existing (deployed) executable documents, in the same way that it would for solution 6, so semantic non-null could not be added until propagateErrorOnAllNonNullFields is set to false (i.e. after all clients and tooling migrate)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-h-implementation-and-spec-simplicity",children:"H"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"~\u2705 One new directive/introspection field. Behavior change is straightforward. Managing adoption/migration requires careful consideration."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-i-syntax-used-in-executable-documents-should-be-unchanged",children:"I"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 This proposes no change to executable documents"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-j-type-reasoning-should-remain-local",children:"J"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 The propagateError introspection/directive is local to the field (the optional propagateErrorOnAllNonNullFields config just does this for you)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-k-introspection-must-be-backwards-compatible",children:"K"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Adds one new field. Migration path supports existing semantics for shipped clients."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-l-general-graphql-consumers-should-only-need-to-think-about-nullable-vs-non-nullable",children:"L"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 There are only two types and they remain the same as they are today. This proposal is about changing error bubbling behavior, not nullability."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-m-the-sdl-should-have-exactly-one-form-used-by-all-producers-and-consumers",children:"M"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 First party APIs have a clear path to introduce propagateError for all consumers."}),"\n",(0,i.jsx)(n.li,{children:"\u26a0\ufe0f Third party APIs have a more challenging migration path, and may wish to expose different Schema to different clients."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-n-the-solution-should-add-value-even-with-error-propagation-enabled",children:"N"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Separating nullability from error bubbling allows for more control. Clients should preferably disable error bubbling, but even if they do not - this unlocks the ability for a semantically non-null type which does not error propagate."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-o-should-not-have-breaking-changes-for-existing-executable-documents",children:"O"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-p-the-solution-should-result-in-users-marking-all-semantically-non-null-fields-as-such",children:"P"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\ud83d\udeab If propagateErrorOnAllNonNullFields: true is set, then adding ! to more fields changes the error boundaries, and thus means that existing users cannot add ! in more places without breaking existing clients error resilience."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-q-migrating-the-unadorned-output-type-to-other-forms-of-nullability-should-be-non-breaking",children:"Q"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-r-semantic-nullability-should-only-impact-outputs-not-inputs",children:"R"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 No proposed change to inputs"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-s-should-be-incrementally-adoptable",children:"S"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\ud83d\udeab Large up-front migration is needed before the first field can be marked semantically non-null"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-t-should-be-incrementally-removable",children:"T"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2754"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-u-legacy-tooling-and-clients-should-safely-interpret-sdl-even-when-ignoring-directives",children:"U"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["\ud83d\udeab ",(0,i.jsx)(n.code,{children:"T!"})," would be interpreted by existing tooling as strictly non-null, which would be incorrect once the migration is underway.\nThis change would not yield a syntax error, so it would be very hard to detect small tools or services that were missed during migration."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"-8-transitional-non-null-appendix",children:"\ud83d\udca1 8. Transitional Non-Null appendix"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Champion"}),": @benjie"]}),"\n",(0,i.jsxs)(n.p,{children:["Spec edits: ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/pull/1165",children:"https://github.com/graphql/graphql-spec/pull/1165"})]}),"\n",(0,i.jsx)(n.p,{children:"This solution revolves around a new appendix to the spec, implementation of\nwhich is optional. There are no changes to the main spec text."}),"\n",(0,i.jsxs)(n.p,{children:["It introduces a ",(0,i.jsx)(n.code,{children:"@noPropagate"}),' directive on fields, which is used to indicate\nthe non-null types in the field return type that must not propagate errors (even\nwhen error propagation is explicitly enabled); such positions are called\n"transitional" non-null positions.']}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{}),(0,i.jsx)(n.th,{children:"Input syntax"}),(0,i.jsx)(n.th,{children:"Output syntax"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Semantically nullable"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Semantically non-nullable"}),(0,i.jsx)(n.td,{children:"-"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"Int"})," \u21d2 ",(0,i.jsx)(n.code,{children:"Int! @noPropagate"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Strictly non-nullable"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int!"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Int!"})})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Clients and tooling that have error propagation enabled will see transitional\nnon-null positions as nullable, resulting in no breaking changes for existing\nclients or tooling."}),"\n",(0,i.jsx)(n.h3,{id:"\ufe0f-evaluation-7",children:"\u2696\ufe0f Evaluation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-a-graphql-should-be-able-to-indicate-which-nullable-fields-should-become-non-nullable-when-error-propagation-is-disabled",children:"A"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-b-existing-executable-documents-should-retain-validity-and-meaning",children:"B"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Existing symbology unchanged."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-c-unadorned-type-should-mean-nullable",children:"C"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Existing symbology unchanged."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-d-syntax-should-be-obvious-to-programmers",children:"D"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Directive."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-e-syntax-used-in-sdl-and-in-executable-documents-should-be-consistent-with-sdl",children:"E"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Directive only."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-f-alternative-syntaxes-should-not-cause-confusion",children:"F"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Same syntax."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-g-error-propagation-boundaries-should-not-change-in-existing-executable-documents",children:"G"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.code,{children:"Int"})," and ",(0,i.jsx)(n.code,{children:"Int! @noPropagate"})," both act as error boundaries in error propagation mode."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-h-implementation-and-spec-simplicity",children:"H"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Just an appendix!"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-i-syntax-used-in-executable-documents-should-be-unchanged",children:"I"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Syntax unchanged."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-j-type-reasoning-should-remain-local",children:"J"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Field directive is local."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-k-introspection-must-be-backwards-compatible",children:"K"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 Introspection backwards compatible via ",(0,i.jsx)(n.code,{children:"__Field.type"})," returning filtered type when error propagation is enabled."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-l-general-graphql-consumers-should-only-need-to-think-about-nullable-vs-non-nullable",children:"L"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 Proposal encourages consumers to use client-produced SDL which only uses traditional nullability (",(0,i.jsx)(n.code,{children:"Type"}),"/",(0,i.jsx)(n.code,{children:"Type!"}),")"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-m-the-sdl-should-have-exactly-one-form-used-by-all-producers-and-consumers",children:"M"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 You can use the same SDL everywhere, but better to split SDL based on error propagation setting."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-n-the-solution-should-add-value-even-with-error-propagation-enabled",children:"N"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.code,{children:"! @noPropagate"})," can be treated as semantically non-null by legacy clients"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-o-should-not-have-breaking-changes-for-existing-executable-documents",children:"O"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Client syntax unchanged"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-p-the-solution-should-result-in-users-marking-all-semantically-non-null-fields-as-such",children:"P"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-q-migrating-the-unadorned-output-type-to-other-forms-of-nullability-should-be-non-breaking",children:"Q"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-r-semantic-nullability-should-only-impact-outputs-not-inputs",children:"R"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Field directive."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-s-should-be-incrementally-adoptable",children:"S"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 Can add ",(0,i.jsx)(n.code,{children:"! @noPropagate"})," to a position without requiring any other changes."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-t-should-be-incrementally-removable",children:"T"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 Can remove ",(0,i.jsx)(n.code,{children:"@noPropagate"})," from a position without requiring any other changes."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#-u-legacy-tooling-and-clients-should-safely-interpret-sdl-even-when-ignoring-directives",children:"U"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 Using ",(0,i.jsx)(n.code,{children:"graphql-sock"}),", different (traditional) SDL can be produced for legacy and error-handling clients; existing tooling would use the legacy SDL."]}),"\n",(0,i.jsxs)(n.li,{children:["\ud83d\udeab If you're not using different SDL for legacy vs error-handling clients, then ",(0,i.jsx)(n.code,{children:"T! @noPropagate"}),", ignoring directives,\nwould be interpreted by existing tooling as strictly non-null, which would be incorrect.\nThis change would not yield a syntax error, so it would be very hard to detect small tools or services that were missed during migration."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]})]})}function o(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},1151:(e,n,l)=>{l.d(n,{Z:()=>a,a:()=>t});var i=l(7294);const s={},r=i.createContext(s);function t(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);