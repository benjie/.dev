"use strict";(self.webpackChunk_localrepo_benjie_dev=self.webpackChunk_localrepo_benjie_dev||[]).push([[9397],{9558:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var i=t(5893),s=t(1151),r=t(768);t(4664);const o={type:"page",title:"Normalized Stores",description:"Rendering consistent data across your application",tag:"graphql",author:"Benjie",breadcrumb:!1,sidebar_position:60},a="Normalized Stores",c={id:"graphql/normalized",title:"Normalized Stores",description:"Rendering consistent data across your application",source:"@site/pages/graphql/normalized.mdx",sourceDirName:"graphql",slug:"/graphql/normalized",permalink:"/graphql/normalized",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:60,frontMatter:{type:"page",title:"Normalized Stores",description:"Rendering consistent data across your application",tag:"graphql",author:"Benjie",breadcrumb:!1,sidebar_position:60},sidebar:"defaultSidebar",previous:{title:"Graph Traversal",permalink:"/graphql/traversal"},next:{title:"Referencing Ancestors",permalink:"/graphql/ancestors"}},d={},l=[{value:"Object identification",id:"object-identification",level:2},{value:"Normalized storage",id:"normalized-storage",level:2},{value:"Example 1: Profile Fetch",id:"example-1-profile-fetch",level:3},{value:"Example 2: Fetching more comments",id:"example-2-fetching-more-comments",level:3},{value:"Merging normalized stores",id:"merging-normalized-stores",level:3},{value:"Mutations",id:"mutations",level:2},{value:"Subscriptions",id:"subscriptions",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"normalized-stores",children:"Normalized Stores"}),"\n",(0,i.jsx)(r.u,{children:(0,i.jsx)(n.p,{children:"Normalized stores are used in many GraphQL clients (for example Relay, Apollo\nClient, urql) to ensure that data is always rendered consistently across the\napplication. They work by storing just one copy of each entity using its unique\nidentity, and then referencing this copy everywhere it's needed (normalization).\nThis allows changes to an entity detected in one place (a query, mutation or\nsubscription) to be retroactively applied to all previous results automatically\nby virtue of updating the single copy of the entity and then re-rendering."})}),"\n",(0,i.jsx)(n.p,{children:"It's extremely common in a web application for a change made in one place to\nneed to be reflected in other places in order to maintain consistency for the\nviewer. For example, imagine you're viewing the posts on the profile page for\nyour friend Rebecca:"}),"\n",(0,i.jsxs)("div",{class:"socialProfilePage",children:[(0,i.jsx)("h1",{children:"Rebecca"}),(0,i.jsx)("h3",{children:"Gotta get down on Friday!"}),(0,i.jsxs)("div",{class:"post",children:[(0,i.jsx)("p",{class:"author",children:"Rebecca"}),(0,i.jsx)("p",{children:"Heading to the studio now, just gotta grab a quick Starbucks first..."}),(0,i.jsxs)("p",{class:"likes-comments",children:["Likes: ",(0,i.jsx)("span",{id:"post2-likes",children:"30"})," | Comments: ",(0,i.jsx)("span",{id:"post2-comments",children:"12"})]}),(0,i.jsxs)("div",{class:"comments",children:[(0,i.jsxs)("p",{class:"comment",children:[(0,i.jsx)("span",{class:"friend",children:"Friend1:"})," Get their Pumpkin Spiced Latte!"]}),(0,i.jsxs)("p",{class:"comment",children:[(0,i.jsx)("span",{class:"friend",children:"Friend2:"})," Sing your heart out!"]}),(0,i.jsx)("p",{class:"more",children:"Show more\u2026"})]})]}),(0,i.jsxs)("div",{class:"post",children:[(0,i.jsx)("p",{class:"author",children:"Rebecca"}),(0,i.jsx)("p",{children:"The new album is coming along nicely!"}),(0,i.jsxs)("p",{class:"likes-comments",children:["Likes: ",(0,i.jsx)("span",{id:"post1-likes",children:"42"})," | Comments: ",(0,i.jsx)("span",{id:"post1-comments",children:"0"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:'After you load the page, but before you click "Show more", Rebecca decides to\nchange her name to "Becky". You click "Show more" and new comments render,\nincluding one from Becky. Seemingly magically, the entire page updates to render\n"Becky" everywhere:'}),"\n",(0,i.jsxs)("div",{class:"socialProfilePage",children:[(0,i.jsx)("h1",{children:"Becky"}),(0,i.jsx)("h3",{children:"Gotta get down on Friday!"}),(0,i.jsxs)("div",{class:"post",children:[(0,i.jsx)("p",{class:"author",children:"Becky"}),(0,i.jsx)("p",{children:"Heading to the studio now, just gotta grab a quick Starbucks first..."}),(0,i.jsxs)("p",{class:"likes-comments",children:["Likes: ",(0,i.jsx)("span",{id:"post2-likes",children:"30"})," | Comments: ",(0,i.jsx)("span",{id:"post2-comments",children:"18"})]}),(0,i.jsxs)("div",{class:"comments",children:[(0,i.jsxs)("p",{class:"comment",children:[(0,i.jsx)("span",{class:"friend",children:"Friend1:"})," Get their Pumpkin Spiced Latte!"]}),(0,i.jsxs)("p",{class:"comment",children:[(0,i.jsx)("span",{class:"friend",children:"Friend2:"})," Sing your heart out!"]}),(0,i.jsxs)("p",{class:"comment",children:[(0,i.jsx)("span",{class:"author",children:"Becky:"})," Pumpkin Spiced Latte FTW!"]}),(0,i.jsxs)("p",{class:"comment",children:[(0,i.jsx)("span",{class:"friend",children:"Friend2:"})," I prefer the Cinnamon one."]}),(0,i.jsx)("p",{class:"more",children:"Show more\u2026"})]})]}),(0,i.jsxs)("div",{class:"post",children:[(0,i.jsx)("p",{class:"author",children:"Becky"}),(0,i.jsx)("p",{children:"The new album is coming along nicely!"}),(0,i.jsxs)("p",{class:"likes-comments",children:["Likes: ",(0,i.jsx)("span",{id:"post1-likes",children:"42"})," | Comments: ",(0,i.jsx)("span",{id:"post1-comments",children:"0"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Is this because all the data for the entire page was refetched? No! It's due to\nthe combined magics of object identification and normalized stores."}),"\n",(0,i.jsx)(n.h2,{id:"object-identification",children:"Object identification"}),"\n",(0,i.jsxs)(n.p,{children:["One of the common patterns you'll see in GraphQL schemas is the\n",(0,i.jsx)(n.a,{href:"https://relay.dev/graphql/objectidentification.htm",children:"GraphQL Global Object Identification Specification"}),".\nThis specification gives a standard way of identifying your entities (users,\nposts, comments, etc) via an ",(0,i.jsx)(n.code,{children:"id: ID!"})," field. Each entity that supports this may\ndeclare so by its type implementing the ",(0,i.jsx)(n.code,{children:"Node"})," interface. With this, you can\nuniquely reference any entity of any type using a single, stable, unique\nidentifier. This pattern is used by the Relay GraphQL client among others."]}),"\n",(0,i.jsxs)(n.p,{children:["This isn't the only way of identifying entities though; for example Apollo\nClient lets you identify an entity via a combination of attributes using the\n",(0,i.jsx)(n.a,{href:"https://www.apollographql.com/docs/react/caching/cache-configuration/#dataidfromobject",children:(0,i.jsx)(n.code,{children:"dataIdFromObject()"})}),"\ncallback (there are other options in newer versions of Apollo Client also). This\ndefaults to combining the ",(0,i.jsx)(n.code,{children:"__typename"})," and ",(0,i.jsx)(n.code,{children:"id"})," field of the object into a\nunique identifier, which works assuming your entities have an ",(0,i.jsx)(n.code,{children:"id"})," field, and\nthat you always fetch both the ",(0,i.jsx)(n.code,{children:"id"})," and the ",(0,i.jsx)(n.code,{children:"__typename"}),". Apollo Client will\nautomatically ask for ",(0,i.jsx)(n.code,{children:"__typename"})," even if you forget, but it's up to you to ask\nfor ",(0,i.jsx)(n.code,{children:"id"}),"."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"Some other GraphQL clients, such as urql, also support normalized caching.\nPlease see your GraphQL client's documentation for how to enable such a feature\nif it exists."})}),"\n",(0,i.jsxs)(n.p,{children:["In this example, when you fetch the profile for Rebecca you find that the entity\nrepresenting her is the User with ID ",(0,i.jsx)(n.code,{children:"U9DB7"}),". Later, when you fetch the\ncomments, you see the commenter 'Becky' has this same ID, and so you can\ndetermine that Rebecca must have changed her name to Becky. But going through\nand manually updating this everywhere that you've already fetched would be a lot\nof work; what you need is a normalized store."]}),"\n",(0,i.jsx)(n.h2,{id:"normalized-storage",children:"Normalized storage"}),"\n",(0,i.jsx)(n.p,{children:"A normalized store stores the entire information fetched across all of your\nGraphQL requests (queries, mutations, subscriptions) in a format that means that\nwhen an entity is updated in one place, it's automatically updated everywhere."}),"\n",(0,i.jsxs)(n.p,{children:["As different normalized stores work in different ways, this article covers an\nextremely rough approximation; in order to keep things simple, the following\nexample assumes the store is configured (and the schema is written) such that\n",(0,i.jsx)(n.code,{children:"id"})," is always a globally unique identifier."]}),"\n",(0,i.jsx)(n.p,{children:'As you know the globally unique identifier for each entity, and you know that\nthe value of a node in the graph is independent of the path through which it was\nfetched, you can break a response up into its constituent entities, store these\nentities and the references between them into a "normalized store", and then\nlater reconstitute the query response from the store when needed.'}),"\n",(0,i.jsx)(n.h3,{id:"example-1-profile-fetch",children:"Example 1: Profile Fetch"}),"\n",(0,i.jsx)(n.p,{children:"For example, imagine the initial profile fetch is:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"query ProfileFetch($id: ID!) {\n  user(id: $id) {\n    id\n    name\n    tagline\n    posts(first: 2) {\n      id\n      author {\n        id\n        name\n      }\n      body\n      likeCount\n      commentCount\n      comments(first: 2) {\n        id\n        author {\n          id\n          name\n        }\n        body\n      }\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"The response to this query is something like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:"{3-4,10-11,38-39}",children:'{\n  "user": {\n    "id": "U9DB7",\n    "name": "Rebecca",\n    "tagline": "Gotta get down on Friday",\n    "posts": [\n      {\n        "id": "P3Q41",\n        "author": {\n          "id": "U9DB7",\n          "name": "Rebecca"\n        },\n        "body": "Heading to the studio now, just gotta grab a quick Starbucks first...",\n        "likeCount": 30,\n        "commentCount": 12,\n        "comments": [\n          {\n            "id": "C2PL1",\n            "author": {\n              "id": "U6EA1",\n              "name": "Friend1"\n            },\n            "body": "Get their Pumpkin Spiced Latte!"\n          },\n          {\n            "id": "C3YZ3",\n            "author": {\n              "id": "U7BZ3",\n              "name": "Friend2"\n            },\n            "body": "Sing your heart out!"\n          }\n        ]\n      },\n      {\n        "id": "P3Q43",\n        "author": {\n          "id": "U9DB7",\n          "name": "Rebecca"\n        },\n        "body": "The new album is coming along nicely!",\n        "likeCount": 42,\n        "commentCount": 0,\n        "comments": []\n      }\n    ]\n  }\n}\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"I've highlighted redundant data about the same entity (Rebecca) referenced in\nmultiple positions."})}),"\n",(0,i.jsx)(n.p,{children:"The goal is to write this to a normalized store, wherein there's a single entry\nfor each entity in the result. You do this by reading through the results layer\nby layer, and when you see an entity you extract it, store it, and replace the\noriginal with a reference to the entity's id."}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:['This is similar to "normalization" in databases: rather than storing repeated\nauthor data in a ',(0,i.jsx)(n.code,{children:"posts"})," table, you instead store the ",(0,i.jsx)(n.code,{children:"author_id"})," into ",(0,i.jsx)(n.code,{children:"posts"}),"\nand have a separate table for authors where you can look up the data for each\nauthor by their unique ",(0,i.jsx)(n.code,{children:"id"}),"."]})}),"\n",(0,i.jsxs)(n.p,{children:["The very first entity is the root Query object itself; it can be identified as\nsimply ",(0,i.jsx)(n.code,{children:"Query"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsonc",children:'{\n  "Query": {\n    /* ... */\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["There's only one field in this, but critically that field accepts arguments\nwhich would likely change the result of the field, so you must factor the\narguments into the identity of the field; thus you can replace ",(0,i.jsx)(n.code,{children:"user"})," with\n",(0,i.jsx)(n.code,{children:"user(id:'U9DB7')"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsonc",metastring:"{3-5}",children:'{\n  "Query": {\n    "user(id:\'U9DB7\')": {\n      /* ... */\n    }\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["You can see from the data inside of this ",(0,i.jsx)(n.code,{children:"user"})," field that it is an entity (it\nhas an ",(0,i.jsx)(n.code,{children:"id"}),", the entity identifier), so you can replace it with a reference.\nThere are many ways of building a normalized store, but this one will leverage\nthe fact that a response key in GraphQL can never contain a ",(0,i.jsx)(n.code,{children:"$"})," symbol and thus\nuse an object with a ",(0,i.jsx)(n.code,{children:"$ref"})," key to indicate a reference."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsonc",metastring:"{4,7-9}",children:'{\n  "Query": {\n    "user(id:\'U9DB7\')": {\n      "$ref": "U9DB7"\n    }\n  },\n  "U9DB7": {\n    /* ... */\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.admonition,{title:"Don't use this as a basis for your own normalized store",type:"danger",children:[(0,i.jsxs)(n.p,{children:["If you are actually looking to build your own normalized store, this isn't safe\nsince custom scalars such as ",(0,i.jsx)(n.code,{children:"JSON"})," ",(0,i.jsx)(n.em,{children:"are"})," allowed to have ",(0,i.jsx)(n.code,{children:"$ref"})," keys. If you\nare writing your normalized store in JS then you could use a Symbol or a class\ninstance for references as examples of things that cannot be constructed from\nJSON."]}),(0,i.jsxs)(n.p,{children:["Another thing: since ",(0,i.jsx)(n.code,{children:"id"})," is an arbitrary string, the schema designer ",(0,i.jsx)(n.em,{children:"could"}),"\nset the ",(0,i.jsx)(n.code,{children:"id"})," of a ",(0,i.jsx)(n.code,{children:"User"})," record to ",(0,i.jsx)(n.code,{children:"Query"})," which would cause issues with the\ndesign here. This is easy to solve by either prepending all identifiers (except\nthe root operation type identifiers you choose yourself) with a specific symbol\ne.g. ",(0,i.jsx)(n.code,{children:"@"})," or ",(0,i.jsx)(n.code,{children:"$"}),"."]})]}),"\n",(0,i.jsxs)(n.p,{children:["The value of the ",(0,i.jsx)(n.code,{children:"user"})," with id ",(0,i.jsx)(n.code,{children:"U9DB7"})," can now be written into the normalized\nstore, and the next entity can be considered:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsonc",metastring:"{7-12}",children:'{\n  "Query": {\n    "user(id:\'U9DB7\')": {\n      "$ref": "U9DB7"\n    }\n  },\n  "U9DB7": {\n    "id": "U9DB7",\n    "name": "Rebecca",\n    "tagline": "Gotta get down on Friday",\n    "posts(first:2)": [{ "$ref": "P3Q41" }, { "$ref": "P3Q43" }]\n  },\n  "P3Q41": {\n    /* ... */\n  },\n  "P3Q43": {\n    /* ... */\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Continuing like this, the completed normalized store will end up something like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "Query": {\n    "user(id:\'U9DB7\')": {\n      "$ref": "U9DB7"\n    }\n  },\n  "U9DB7": {\n    "id": "U9DB7",\n    "name": "Rebecca",\n    "tagline": "Gotta get down on Friday",\n    "posts(first:2)": [\n      { "$ref": "P3Q41" },\n      { "$ref": "P3Q43" },\n    ]\n  },\n  "P3Q41": {\n    "id": "P3Q41",\n    "author": { "$ref": "U9DB7" }\n    "body": "Heading to the studio now, just gotta grab a quick Starbucks first...",\n    "likeCount": 30,\n    "commentCount": 12,\n    "comments(first:2)": [\n      { "$ref": "C2PL1" },\n      { "$ref": "C3YZ3" }\n    ]\n  },\n  "C2PL1": {\n    "id": "C2PL1",\n    "author": { "$ref": "U6EA1" },\n    "body": "Get their Pumpkin Spiced Latte!"\n  },\n  "C3YZ3": {\n    "id": "C3YZ3",\n    "author": { "$ref": "U7BZ3" },\n    "body": "Sing your heart out!"\n  },\n  "U6EA1": {\n    "id": "U6EA1",\n    "name": "Friend1"\n  },\n  "U7BZ3": {\n    "id": "U7BZ3",\n    "name": "Friend2"\n  },\n  "P3Q43": {\n    "id": "P3Q43",\n    "author": { "$ref": "U9DB7" }\n    "body": "The new album is coming along nicely!",\n    "likeCount": 42,\n    "commentCount": 0,\n    "comments(first:2)": []\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"When you come to render this data in your application, you can regenerate the\nquery response from the normalized cache by walking through the GraphQL document\nand extracting the specified entity for each field/arguments combo referenced."}),"\n",(0,i.jsx)(n.h3,{id:"example-2-fetching-more-comments",children:"Example 2: Fetching more comments"}),"\n",(0,i.jsx)(n.p,{children:"To fetch more comments, you can issue a request such as:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"query LoadMoreComments($postId: ID!, $offset: Int!) {\n  post(id: $postId) {\n    id\n    comments(first: 2, offset: $offset) {\n      id\n      author {\n        id\n        name\n      }\n      body\n    }\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["using variables ",(0,i.jsx)(n.code,{children:'{"postId": "P3Q41", "offset": 2}'})," and receive a response like:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:"{8-9}",children:'{\n  "post": {\n    "id": "P3Q41",\n    "comments": [\n      {\n        "id": "C4NR1",\n        "author": {\n          "id": "U9DB7",\n          "name": "Becky"\n        },\n        "body": "Pumpkin Spiced Latte FTW!"\n      },\n      {\n        "id": "C4NR6",\n        "author": {\n          "id": "U7BZ3",\n          "name": "Friend2"\n        },\n        "body": "I prefer the Cinnamon one."\n      }\n    ]\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Note that the ",(0,i.jsx)(n.code,{children:"name"})," has changed for the entity ",(0,i.jsx)(n.code,{children:"U9DB7"})," (previously: Rebecca)."]}),"\n",(0,i.jsx)(n.p,{children:"The normalized result for this query is something like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:"{21-24}",children:'{\n  "Query": {\n    "post(id:\'P3Q41\')": {\n      "$ref": "P3Q41"\n    }\n  },\n  "P3Q41": {\n    "id": "P3Q41",\n    "comments(first:2,offset:2)": [{ "$ref": "C4NR1" }, { "$ref": "C4NR6" }]\n  },\n  "C4NR1": {\n    "id": "C4NR1",\n    "author": { "$ref": "U9DB7" },\n    "body": "Pumpkin Spiced Latte FTW!"\n  },\n  "C4NR6": {\n    "id": "C4NR6",\n    "author": { "$ref": "U7BZ3" },\n    "body": "I prefer the Cinnamon one."\n  },\n  "U9DB7": {\n    "id": "U9DB7",\n    "name": "Becky"\n  },\n  "U7BZ3": {\n    "id": "U7BZ3",\n    "name": "Friend2"\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"merging-normalized-stores",children:"Merging normalized stores"}),"\n",(0,i.jsx)(n.p,{children:"As you merge the above store into the main normalized store, you will overwrite\nstale keys, resulting in:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-diff",metastring:"{10,12-13}",children:' {\n   "Query": {\n     "user(id:\'U9DB7\')": {\n       "$ref": "U9DB7"\n+    },\n+    "post(id:\'P3Q41\')": {\n+      "$ref": "P3Q41"\n     }\n   },\n   "U9DB7": {\n     "id": "U9DB7",\n-    "name": "Rebecca",\n+    "name": "Becky",\n     "tagline": "Gotta get down on Friday",\n     "posts(first:2)": [\n       { "$ref": "P3Q41" },\n       { "$ref": "P3Q43" },\n     ]\n   },\n   "P3Q41": {\n     "id": "P3Q41",\n     "author": { "$ref": "U9DB7" }\n     "body": "Heading to the studio now, just gotta grab a quick Starbucks first...",\n     "likeCount": 30,\n     "commentCount": 12,\n+    "comments(first:2,offset:2)": [ { "$ref": "C4NR1" }, { "$ref": "C4NR6" } ],\n     "comments(first:2)": [\n       { "$ref": "C2PL1" },\n       { "$ref": "C3YZ3" }\n     ]\n   },\n   "C2PL1": {\n     "id": "C2PL1",\n     "author": { "$ref": "U6EA1" },\n     "body": "Get their Pumpkin Spiced Latte!"\n   },\n   "C3YZ3": {\n     "id": "C3YZ3",\n     "author": { "$ref": "U7BZ3" },\n     "body": "Sing your heart out!"\n   },\n+  "C4NR1": {\n+    "id": "C4NR1",\n+    "author": { "$ref": "U9DB7" },\n+    "body": "Pumpkin Spiced Latte FTW!"\n+  },\n+  "C4NR6": {\n+    "id": "C4NR6",\n+    "author": { "$ref": "U7BZ3" },\n+    "body": "I prefer the Cinnamon one."\n+  },\n   "U6EA1": {\n     "id": "U6EA1",\n     "name": "Friend1"\n   },\n   "U7BZ3": {\n     "id": "U7BZ3",\n     "name": "Friend2"\n   },\n   "P3Q43": {\n     "id": "P3Q43",\n     "author": { "$ref": "U9DB7" }\n     "body": "The new album is coming along nicely!",\n     "likeCount": 42,\n     "commentCount": 0,\n     "comments(first:2)": []\n   }\n }\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Now when the first query re-renders, it will re-read the normalized data from\nthe store and pick up Becky's new name, and render it everywhere, as we saw\nabove in ",(0,i.jsx)(n.a,{href:"/graphql/normalized",children:"the introduction"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"mutations",children:"Mutations"}),"\n",(0,i.jsx)(n.p,{children:"Normalized caches really shine when used with mutations; it's generally the case\nthat when you perform a mutation you're modifying data that is related to what\nyou have rendered (updating a record, adding an entry to or removing an entry\nfrom a list, etc), and so having the results of that mutation display\nconsistently throughout your application makes for a consistent experience for\nthe user - by fetching the resulting data on the mutation payload and updating\nit in the normalized store, this can happen automatically for you."}),"\n",(0,i.jsx)(n.p,{children:'This experience can be enhanced further with the usage of the "optimistic\nupdates" technique: the application can guess what the server is going to say,\nwrite the guess to the normalized store, and instantly re-render showing the\nuser the new data everywhere in a consistent fashion. Assuming everything went\nright, this is a very pleasant low-latency experience for the user. If something\ngoes wrong, you need to roll back this change and inform the user of the\nerror... so it\'s generally best to use it only in situations where the happy\npath is the likely path!'}),"\n",(0,i.jsx)(n.h2,{id:"subscriptions",children:"Subscriptions"}),"\n",(0,i.jsx)(n.p,{children:"Subscriptions also benefit significantly from normalized caches; in fact you\ndon't even need to \"render\" your subscription results anywhere! If your\nsubscription queries data that you have already fetched and rendered via a\nregular query, then when the subscription yields data, it can automatically be\nwritten to the normalized store, which will trigger the application to re-render\nwith the new values everywhere. GraphQL's real-time features can be fantastic\nwhen backed with a normalized store!"})]})}function u(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},4664:(e,n,t)=>{t.d(n,{Z:()=>r});t(7294);const i="pullquote_fEhA";var s=t(5893);const r=e=>{let{children:n}=e;return(0,s.jsx)("aside",{className:i,children:(0,s.jsx)("blockquote",{children:n})})}},768:(e,n,t)=>{t.d(n,{u:()=>o});t(7294);const i="tldr_fcon",s="inner_JkE_";var r=t(5893);const o=e=>{let{children:n}=e;return(0,r.jsx)("aside",{className:i,children:(0,r.jsx)("div",{className:s,children:n})})}},1151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>o});var i=t(7294);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);