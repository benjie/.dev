"use strict";(self.webpackChunk_localrepo_benjie_dev=self.webpackChunk_localrepo_benjie_dev||[]).push([[6316],{8966:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>d,default:()=>p,frontMatter:()=>a,metadata:()=>h,toc:()=>u});var s=n(5893),r=n(1151),o=n(4664),i=n(768);const a={type:"page",title:"Trusted Documents",description:"A standard way to prevent malicious GraphQL documents being issued to a GraphQL endpoint by only allowing documents that you trust (written by your developers, passing your CI checks, etc).\nAt client build time, make the documents available to the server and receive an identifier for each; at run time issue this identifier to the server and have it look up the associated document.",image:"https://benjie.dev/img/graphql/trusted-documents/business_card.png",tag:"graphql",author:"Benjie",breadcrumb:!1,sidebar_position:20},d="GraphQL Trusted Documents",h={id:"graphql/trusted-documents",title:"Trusted Documents",description:"A standard way to prevent malicious GraphQL documents being issued to a GraphQL endpoint by only allowing documents that you trust (written by your developers, passing your CI checks, etc).\nAt client build time, make the documents available to the server and receive an identifier for each; at run time issue this identifier to the server and have it look up the associated document.",source:"@site/pages/graphql/trusted-documents.mdx",sourceDirName:"graphql",slug:"/graphql/trusted-documents",permalink:"/graphql/trusted-documents",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:20,frontMatter:{type:"page",title:"Trusted Documents",description:"A standard way to prevent malicious GraphQL documents being issued to a GraphQL endpoint by only allowing documents that you trust (written by your developers, passing your CI checks, etc).\nAt client build time, make the documents available to the server and receive an identifier for each; at run time issue this identifier to the server and have it look up the associated document.",image:"https://benjie.dev/img/graphql/trusted-documents/business_card.png",tag:"graphql",author:"Benjie",breadcrumb:!1,sidebar_position:20},sidebar:"defaultSidebar",previous:{title:"GraphQL Security",permalink:"/graphql/security"},next:{title:"Static Documents",permalink:"/graphql/static-documents"}},c={},u=[{value:"Who should be using a GraphQL allowlist?",id:"who-should-be-using-a-graphql-allowlist",level:2},{value:"Why isn&#39;t everyone using GraphQL allowlists already?",id:"why-isnt-everyone-using-graphql-allowlists-already",level:2},{value:"What is a &quot;trusted document&quot;?",id:"what-is-a-trusted-document",level:2},{value:"How do I add trusted documents to my stack?",id:"how-do-i-add-trusted-documents-to-my-stack",level:2},{value:"Does my client support trusted documents?",id:"does-my-client-support-trusted-documents",level:2},{value:"Does my server support trusted documents?",id:"does-my-server-support-trusted-documents",level:2},{value:"Do trusted documents have more benefits?",id:"do-trusted-documents-have-more-benefits",level:2},{value:"Are trusted documents a silver bullet?",id:"are-trusted-documents-a-silver-bullet",level:2},{value:"Share the news of trusted documents today!",id:"share-the-news-of-trusted-documents-today",level:2}];function l(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"graphql-trusted-documents",children:"GraphQL Trusted Documents"}),"\n",(0,s.jsxs)(i.u,{children:[(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Use trusted documents"})," if your GraphQL API is only for your own apps (most\nGraphQL APIs!) for a ",(0,s.jsx)(t.strong,{children:"massively decreased attack-surface"}),", increased\nperformance, and decreased bandwidth usage."]}),(0,s.jsxs)(t.p,{children:["At app build time, extract the GraphQL documents (queries, mutations,\nsubscriptions) and make them available to the server. At run time, send\n",(0,s.jsx)(t.code,{children:"documentId"})," instead of the whole document; only accept requests with a\n",(0,s.jsx)(t.code,{children:"documentId"}),"."]})]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"https://graphql.org/conf/",children:"GraphQLConf 2023"})," was an absolute delight! I finally\nmet many of the people that I've worked with at the GraphQL Working Group over\nthe past few years, and they're even nicer in person! And the attendees were\ndelightful; it was really interesting hearing about how they use GraphQL."]}),"\n",(0,s.jsx)(t.p,{children:"My biggest takeaway from the first day of the conference was that almost\neveryone should be protecting their GraphQL endpoints with an allowlist, but\nalmost no-one is!"}),"\n",(0,s.jsx)(o.Z,{children:(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"almost everyone should"})," be protecting their GraphQL endpoints with an\nallowlist, but ",(0,s.jsx)(t.strong,{children:"almost no-one is"}),"!"]})}),"\n",(0,s.jsx)(t.h2,{id:"who-should-be-using-a-graphql-allowlist",children:"Who should be using a GraphQL allowlist?"}),"\n",(0,s.jsx)(t.p,{children:"Anyone who"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"exposes their GraphQL endpoint to the internet or a wide area network (WAN),\nand"}),"\n",(0,s.jsx)(t.li,{children:"doesn't intend third parties to be able to issue arbitrary queries to their\nGraphQL API."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"This is anyone who is using GraphQL to power their own websites, mobile apps and\ndesktop apps but isn't deliberately exposing their API for others to use. Those\nof you who this applies to (and that is the vast majority of GraphQL users!)\nshould be using an allowlist so that only GraphQL operations that your own\ndevelopers write can be executed against your GraphQL schema."}),"\n",(0,s.jsx)(t.p,{children:"Adopting a GraphQL allowlist significantly decreases the attack surface of your\nGraphQL API since only operations that your developers have written can be\nexecuted. This technique has been used within Facebook since before GraphQL was\nopen sourced, it's very much a best practice if you meet the criteria above!"}),"\n",(0,s.jsx)(o.Z,{children:(0,s.jsxs)(t.p,{children:["a GraphQL allowlist ",(0,s.jsx)(t.strong,{children:"significantly decreases the attack surface"})," of your API"]})}),"\n",(0,s.jsx)(t.h2,{id:"why-isnt-everyone-using-graphql-allowlists-already",children:"Why isn't everyone using GraphQL allowlists already?"}),"\n",(0,s.jsx)(t.p,{children:'Many haven\'t heard of the technique. Of those who have, many knew that they\nshould be doing it, but failed to find resources on the "how," or expected it to\nbe a lot of work. Another issue was people confusing the allowlist technique\nknown as "persisted queries" (aka "stored operations", "persisted documents",\nand various other names) for the bandwidth-saving technique "automatic persisted\nqueries (APQ)".'}),"\n",(0,s.jsxs)(t.p,{children:["Worst of all, some people felt they were already protecting their endpoints by\ndisabling query introspection, when in reality there are so many ways for an\nattacker to work around that: extracting hints from error messages, sniffing\nnetwork traffic, and fuzzing field names to name just a few. At best, disabling\nintrospection gives you\n",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Security_through_obscurity",children:"security through obscurity"}),"."]}),"\n",(0,s.jsx)(o.Z,{children:(0,s.jsxs)(t.p,{children:["if you're ",(0,s.jsx)(t.strong,{children:"disabling introspection"})," then you're ",(0,s.jsx)(t.strong,{children:"doing it wrong"})]})}),"\n",(0,s.jsx)(t.p,{children:"In my opinion, if you're disabling introspection then you're doing it wrong; you\nshould instead be using an operation allowlist such as \"trusted documents\" to\nprevent untrusted operations from running against your API."}),"\n",(0,s.jsx)(t.h2,{id:"what-is-a-trusted-document",children:'What is a "trusted document"?'}),"\n",(0,s.jsxs)(t.p,{children:["In GraphQL, an ",(0,s.jsx)(t.em,{children:"executable document"}),' is a text string that consists of one or\nmore query, mutation or subscription operations and their associated fragments\nusing the GraphQL language. People commonly refer to them as "queries", but that\nterm is a little ambiguous \u2014\n',(0,s.jsx)(t.a,{href:"https://spec.graphql.org/draft/#ExecutableDocument",children:'"executable document"'})," is\nthe precise term."]}),"\n",(0,s.jsxs)(t.p,{children:["A ",(0,s.jsx)(t.em,{children:"trusted document"})," is an executable document, identified via a unique\nidentifier (typically a hash), that you ",(0,s.jsx)(t.strong,{children:"trust"})," \u2014 in most cases because\nit was written as part of your regular software development cycle:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"they were written by your developers, who you trust;"}),"\n",(0,s.jsx)(t.li,{children:"they have passed through your CI checks, which you trust;"}),"\n",(0,s.jsx)(t.li,{children:"they have been approved via your code review process, which you trust;"}),"\n",(0,s.jsx)(t.li,{children:"they have been stored into a secure location, which you trust."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Since these documents are trusted, if you only allow your server to execute\ntrusted documents then you no longer need to concern yourself with malicious\ndocuments."}),"\n",(0,s.jsx)(o.Z,{children:(0,s.jsxs)(t.p,{children:["a ",(0,s.jsx)(t.strong,{children:"trusted document"})," is a GraphQL document the server can trust, typically\nbecause it was ",(0,s.jsx)(t.strong,{children:"written by your developers"})]})}),"\n",(0,s.jsx)(t.p,{children:'Yes, a "trusted document" is an instance of what we\'ve traditionally called a\n"persisted query" (or persisted document/stored operation/etc); but specifically\nit is one the server can trust (typically because it was written by your\ndevelopers) and thus can be used to form an allowlist that prevents the server\nfrom executing malicious documents.'}),"\n",(0,s.jsx)(t.p,{children:'I hope that the entire GraphQL ecosystem can move towards using the term\n"trusted document" when referring to this concept. It\'s much more obvious what\nthe term "trusted document" implies, and it clearly differentiates this use from\n"automatic persisted queries" (a bandwidth optimization), and "registered\ndocuments" (an untrusted allowlist, requiring greater run-time scrutiny).'}),"\n",(0,s.jsxs)(t.p,{children:["Very much related, I recently wrote up\n",(0,s.jsx)(t.a,{href:"https://github.com/graphql/graphql-over-http/pull/264/files?short_path=9be5577#diff-9be5577e05ae2112d2b8f95584b162d0dec01453bf6c85df58bf5db4f2c9727a",children:"a specification for Persisted Documents"}),"\nwhich can be used to implement trusted documents (or automatic persisted\nqueries)."]}),"\n",(0,s.jsx)(t.h2,{id:"how-do-i-add-trusted-documents-to-my-stack",children:"How do I add trusted documents to my stack?"}),"\n",(0,s.jsx)(t.p,{children:"If you already use code generation with your GraphQL clients (e.g. for type\nsafety) then it's relatively easy. When you build your application (after you've\nensured that all the GraphQL documents it contains are trusted):"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Have the code generator write out the document(s) that your client is using,"}),"\n",(0,s.jsx)(t.li,{children:"Generate a hash for each of these documents using SHA256, and"}),"\n",(0,s.jsx)(t.li,{children:"Have your server store into a trusted key-value store the GraphQL document as\nthe value and the SHA256 hash as the key."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["When the client issues a request to the GraphQL endpoint, it should replace the\n",(0,s.jsx)(t.code,{children:"query"})," parameter with a ",(0,s.jsx)(t.code,{children:"documentId"})," parameter which is ",(0,s.jsx)(t.code,{children:"sha256:"})," followed by\nthe SHA256 hash of your document."]}),"\n",(0,s.jsxs)(t.p,{children:["When the server receives a request, it should look for this ",(0,s.jsx)(t.code,{children:"documentId"}),". If\nthere is no ",(0,s.jsx)(t.code,{children:"documentId"})," in the request, it should raise an exception* and stop\nprocessing the request. Otherwise, it should look up the GraphQL document for\nthis ",(0,s.jsx)(t.code,{children:"documentId"})," in the key-value store, and continue executing the request as\nif this were the ",(0,s.jsx)(t.code,{children:"query"})," the client submitted all along."]}),"\n",(0,s.jsxs)(t.p,{children:["* ",(0,s.jsx)(t.em,{children:"If you're doing this for existing GraphQL APIs then you may wish to capture\nthe hashes of all documents in use for the next month or so, and explicitly\nallow these through to avoid breaking existing clients."})]}),"\n",(0,s.jsx)(o.Z,{children:(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"clients send hash to server, server finds associated document"})," and continues\nas normal"]})}),"\n",(0,s.jsx)(t.p,{children:"That's really all there is to it. Choosing what to use as a key-value store is\nentirely up to you; but here's a couple of ideas:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["If you have a monorepo for your server and client(s), you could store the\noperations as ",(0,s.jsx)(t.code,{children:".trusted_documents/<hash>.graphql"})," into the git repository;\nthis will even help you know when and why the given document was generated."]}),"\n",(0,s.jsx)(t.li,{children:"Otherwise, maybe from CI, your client build process should issue the queries\nthat are needed (and their hashes) to an authenticated endpoint on the server.\nThe server should then store these wherever it finds convenient: a database, a\npersistent key-value store service (e.g. Redis), or maybe an external service\nlike DynoDB or S3."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Trusted documents: if you can, you should!",src:n(1627).Z+"",width:"1600",height:"1035"})}),"\n",(0,s.jsx)(t.h2,{id:"does-my-client-support-trusted-documents",children:"Does my client support trusted documents?"}),"\n",(0,s.jsxs)(t.p,{children:["Almost all clients that use ",(0,s.jsx)(t.a,{href:"/graphql/static-documents",children:"static documents"})," support\ntrusted documents, typically via a tweak to their networking layer where instead\nof sending the ",(0,s.jsx)(t.code,{children:"query"})," parameter containing the document, you instead send a\n",(0,s.jsx)(t.code,{children:"documentId"}),' parameter with the relevant identifier. Most clients refer to the\nbroader concept of "persisted queries", the trust is something that you bring\nwith you.']}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://github.com/valu-digital/graphql-codegen-persisted-query-ids#integrating-with-apollo-client",children:"Apollo Client"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://relay.dev/docs/guides/persisted-queries/",children:"Relay"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://www.npmjs.com/package/@urql/exchange-persisted",children:"URQL"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://gql-tada.0no.co/guides/persisted-documents",children:"gql.tada"})}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"https://github.com/jasonkuhrt/graffle/issues/269",children:"clients that support replacing fetch()"}),"\n(e.g. ",(0,s.jsx)(t.code,{children:"graphql-request"}),"/",(0,s.jsx)(t.code,{children:"graffle"}),")"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"does-my-server-support-trusted-documents",children:"Does my server support trusted documents?"}),"\n",(0,s.jsxs)(t.p,{children:['Many servers support trusted documents with a little additional configuration -\nsometimes it\'s referred to as "persisted queries" or "persisted documents".\nBeware: "',(0,s.jsx)(t.em,{children:"automatic"}),' persisted queries" are not a security feature, so be sure\nto disable this feature.']}),"\n",(0,s.jsx)(o.Z,{children:(0,s.jsxs)(t.p,{children:["Beware: ",(0,s.jsx)(t.strong,{children:"automatic"})," persisted queries are ",(0,s.jsx)(t.strong,{children:"not"})," a security feature"]})}),"\n",(0,s.jsx)(t.p,{children:"If your server does not support trusted documents/persisted queries (or if it\ncharges for support) then you can add support yourself with a small intermediary\nserver or middleware:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Receive ",(0,s.jsx)(t.code,{children:"{ documentId, variables, operationName, extensions }"})]}),"\n",(0,s.jsxs)(t.li,{children:["Look up the document associated with ",(0,s.jsx)(t.code,{children:"documentId"})," - throw an error if not\nfound"]}),"\n",(0,s.jsxs)(t.li,{children:["Forward the request on to your GraphQL server, substituting the ",(0,s.jsx)(t.code,{children:"documentId"}),"\nwith the ",(0,s.jsx)(t.code,{children:"query"})," text you just found."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Here's an example in a Node.js Express middleware; implementation of\n",(0,s.jsx)(t.code,{children:"loadDocumentByIdentifier"})," is left as an exercise for the reader (but I\nrecommend you use an LRU cache or similar):"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:'app.post("/graphql", async (req, res, next) => {\n  try {\n    // Extract `documentId` from the request; throw if not found\n    const documentId = req.body?.documentId;\n    if (typeof documentId !== "string") {\n      throw new Error("This server only allows trusted documents.");\n    }\n\n    // Fetch the given document by this identifier\n    const document = await loadDocumentByIdentifier(documentId);\n    if (!document) {\n      throw new Error("That document identifier couldn\'t be found.");\n    }\n\n    // Substitute `documentId` for `query` in the request body\n    delete req.body.documentId;\n    req.body.query = document;\n\n    // Process the request as normal\n    return next();\n  } catch (e) {\n    next(e);\n  }\n});\n'})}),"\n",(0,s.jsx)(t.h2,{id:"do-trusted-documents-have-more-benefits",children:"Do trusted documents have more benefits?"}),"\n",(0,s.jsx)(t.p,{children:"Besides security, you mean? Well, as it happens, yes!"}),"\n",(0,s.jsx)(o.Z,{children:(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"security"}),", ",(0,s.jsx)(t.strong,{children:"bandwidth"}),", ",(0,s.jsx)(t.strong,{children:"caching"}),", and ",(0,s.jsx)(t.strong,{children:"schema evolution"})]})}),"\n",(0,s.jsx)(t.p,{children:"Trusted documents can help reduce network bandwidth because you don't need to\nsend the (rather long, at times) GraphQL documents from the client to the server\neach time \u2014 just a short hash instead."}),"\n",(0,s.jsxs)(t.p,{children:["If you set your server up such that it accepts GraphQL queries (but NOT\nmutations!) via GET requests, you can easily make your queries HTTP cacheable:\nuse a dedicated URL for each trusted document/operationName combo (e.g.\n",(0,s.jsx)(t.code,{children:"https://example.com/graphql/<hash>/<operationName>"}),") and set the relevant\ncaching headers (don't forget to use ",(0,s.jsx)(t.code,{children:"Vary"})," if you have your client send\nvariables via headers!) and voila! You could even combine this with a content\ndelivery network to get caching on the edge; though this is quite coarse\nwhole-response caching. (For a more powerful take on GraphQL caching at the\nedge, check out ",(0,s.jsx)(t.a,{href:"https://github.com/sponsors/benjie",children:"my sponsor"})," Stellate's\n",(0,s.jsx)(t.a,{href:"https://stellate.co/blog/partial-query-caching",children:"partial query caching"})," \u2014 it\nlooks fantastic!)"]}),"\n",(0,s.jsx)(t.p,{children:"One huge benefit of trusted documents that's not talked about enough is that\nthey give you a great insight into exactly which fields are used, and by which\nclients. Want to remove a field from your GraphQL API, but you're not sure it's\nsafe to do so? Simply remove it and then validate all of your trusted documents\nagainst the new GraphQL API \u2014 if the validations pass then you know it's safe to\nremove."}),"\n",(0,s.jsx)(t.h2,{id:"are-trusted-documents-a-silver-bullet",children:"Are trusted documents a silver bullet?"}),"\n",(0,s.jsx)(t.p,{children:"It might seem at first that with persisted operations there's no need for the\nserver to:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"disable introspection"}),"\n",(0,s.jsx)(t.li,{children:"apply depth limits"}),"\n",(0,s.jsx)(t.li,{children:"apply pagination limits"}),"\n",(0,s.jsx)(t.li,{children:"perform query cost analysis"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"And you're right; those needs are significantly diminished! But you still need\nto be careful about the documents you write. Though an attacker can no longer\nissue arbitrary documents against your GraphQL API, they can still take the\ndocuments you already have and issue them with their own carefully crafted\ninputs."}),"\n",(0,s.jsx)(o.Z,{children:(0,s.jsxs)(t.p,{children:["you still need to ",(0,s.jsx)(t.strong,{children:"be careful"})," about the documents you write"]})}),"\n",(0,s.jsx)(t.p,{children:"Each of the above concerns still exists, but now it applies to just the trusted\ndocuments that your developers are writing, rather than runtime checks against\narbitrary operations your server is receiving. You should check your documents\nbefore you persist them to ensure that they meet your requirements for safety;\nthis is a one-time cost at document persistence time rather than a cost incurred\nfor every request."}),"\n",(0,s.jsx)(t.p,{children:'You should also train your developers on the writing of "safe" operations.\nImagine you trusted a document such as:'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-graphql",children:"query TopUsers($limit: Int! = 10) {\n  topUsers(first: $limit) {\n    id\n    name\n    avatar\n  }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["An attacker could issue this query with a ",(0,s.jsx)(t.code,{children:"$limit"})," of ",(0,s.jsx)(t.code,{children:"2147483647"})," and now your\nserver is on the hook to return up to 2 billion results. Teaching your\ndevelopers to hardcode pagination limits into the query itself is one solution\nto this, another is to maintain limits in the server and throw out requests that\nclearly exceed sensible bounds."]}),"\n",(0,s.jsx)(t.p,{children:'Similarly if you have large input object trees (for example "filter" objects)\nthen it\'s best to specify as much as you can into the query itself, and make the\nvariables only for the "leaves" - this way an attacker can\'t make a punishingly\ncomplex filter for your server to execute.'}),"\n",(0,s.jsx)(t.h2,{id:"share-the-news-of-trusted-documents-today",children:"Share the news of trusted documents today!"}),"\n",(0,s.jsxs)(t.p,{children:['"Persisted queries" has been an imprecise technique that is widely adopted; on\nthe client side Relay\n',(0,s.jsx)(t.a,{href:"https://relay.dev/docs/guides/persisted-queries/",children:"has a specification for their Persisted Queries"}),",\nand Apollo also\n",(0,s.jsx)(t.a,{href:"https://www.apollographql.com/docs/kotlin/advanced/persisted-queries/",children:"has their own"}),".\nThe Guild (another of the companies\n",(0,s.jsx)(t.a,{href:"https://github.com/sponsors/benjie",children:"sponsoring my open source work"}),") also\n",(0,s.jsx)(t.a,{href:"https://the-guild.dev/graphql/yoga-server/docs/features/persisted-operations",children:"specifies persisted operations for GraphQL Yoga"}),"\nand Valu Digital have\n",(0,s.jsx)(t.a,{href:"https://github.com/valu-digital/graphql-codegen-persisted-query-ids",children:"a plugin for GraphQL Code Generator"}),"\nto generate the persisted query IDs for you."]}),"\n",(0,s.jsx)(t.p,{children:"With the introduction of a vendor agnostic GraphQL Foundation-hosted\nspecification for persisted documents as part of the GraphQL-over-HTTP project,\nI aim to work with the maintainers of these projects to maximize compatibility\nand ease adoption of trusted documents across the entire ecosystem."}),"\n",(0,s.jsx)(o.Z,{children:(0,s.jsxs)(t.p,{children:["aim to ",(0,s.jsx)(t.strong,{children:"maximize compatibility"})," and ",(0,s.jsx)(t.strong,{children:"ease adoption"})," of trusted documents\nacross the entire ecosystem"]})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsxs)(t.em,{children:["I'm a community-funded open source developer; if you would like to support the\nwork I'm doing please consider\n",(0,s.jsx)(t.a,{href:"https://github.com/sponsors/benjie",children:"becoming a sponsor"})," for as little or as\nmuch as you can afford each month. I couldn't do what I do without the support\nof my sponsors. Thank you!"]})})]})}function p(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},4664:(e,t,n)=>{n.d(t,{Z:()=>o});n(7294);const s="pullquote_fEhA";var r=n(5893);const o=e=>{let{children:t}=e;return(0,r.jsx)("aside",{className:s,children:(0,r.jsx)("blockquote",{children:t})})}},768:(e,t,n)=>{n.d(t,{u:()=>i});n(7294);const s="tldr_fcon",r="inner_JkE_";var o=n(5893);const i=e=>{let{children:t}=e;return(0,o.jsx)("aside",{className:s,children:(0,o.jsx)("div",{className:r,children:t})})}},1627:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/business_card-7935ff66e665c10b5864af7e319b5558.png"},1151:(e,t,n)=>{n.d(t,{Z:()=>a,a:()=>i});var s=n(7294);const r={},o=s.createContext(r);function i(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);