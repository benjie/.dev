"use strict";(self.webpackChunk_localrepo_benjie_dev=self.webpackChunk_localrepo_benjie_dev||[]).push([[2428],{7130:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var s=n(5893),r=n(1151);const i={identifier:"Struct",stage:"0",title:"Polymorphic-capable composite symmetric input/output type (`struct`)",events:[{type:"docUpdated",date:new Date("2023-11-28T17:56:45.000Z"),href:"https://github.com/graphql/graphql-wg/blob/c46f67dad4154c3b693d337c815900a5c7909423/rfcs/Struct.md",actor:"Benjie"},{type:"docUpdated",date:new Date("2023-08-24T13:14:37.000Z"),href:"https://github.com/graphql/graphql-wg/blob/c599436ddf5737dcee28d46e77eec567921c0ac1/rfcs/Struct.md",actor:"Tushar Mathur"},{type:"docUpdated",date:new Date("2023-01-19T10:17:18.000Z"),href:"https://github.com/graphql/graphql-wg/blob/a64fd6caea23299587aba7a66cd0d157ad9bcc3e/rfcs/Struct.md",actor:"Benjie"},{type:"docUpdated",date:new Date("2022-10-24T10:21:35.000Z"),href:"https://github.com/graphql/graphql-wg/blob/ab192ae0b078566ad2d2fafafb24248aab017968/rfcs/Struct.md",actor:"Alexander Varwijk"},{type:"docUpdated",date:new Date("2022-10-20T17:26:24.000Z"),href:"https://github.com/graphql/graphql-wg/blob/e9e292f62912f36e75bd201901a4556e4b1128b0/rfcs/Struct.md",actor:"Mark Larah"},{type:"docUpdated",date:new Date("2022-07-22T09:23:36.000Z"),href:"https://github.com/graphql/graphql-wg/blob/b95adab903828251dd2006c6dd1c2c3b67f58d00/rfcs/Struct.md",actor:"Benjie Gillam"},{type:"docCreated",date:new Date("2022-07-07T16:52:49.000Z"),href:"https://github.com/graphql/graphql-wg/blob/ab0985750e561225fedaf322157e974c631aadda/rfcs/Struct.md",actor:"Benjie Gillam"}],related:"127, 147, 237, 688, 929, 942, InputUnion, wg1071",shortname:"Polymorphic-capable composite symmetric input/output type (`struct`)",image:"/img/rfc_tracker.png"},a=void 0,o={id:"Struct",title:"Polymorphic-capable composite symmetric input/output type (`struct`)",description:"At a glance",source:"@site/rfcs/Struct.md",sourceDirName:".",slug:"/Struct",permalink:"/rfcs/Struct",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{identifier:"Struct",stage:"0",title:"Polymorphic-capable composite symmetric input/output type (`struct`)",events:[{type:"docUpdated",date:"2023-11-28T17:56:45.000Z",href:"https://github.com/graphql/graphql-wg/blob/c46f67dad4154c3b693d337c815900a5c7909423/rfcs/Struct.md",actor:"Benjie"},{type:"docUpdated",date:"2023-08-24T13:14:37.000Z",href:"https://github.com/graphql/graphql-wg/blob/c599436ddf5737dcee28d46e77eec567921c0ac1/rfcs/Struct.md",actor:"Tushar Mathur"},{type:"docUpdated",date:"2023-01-19T10:17:18.000Z",href:"https://github.com/graphql/graphql-wg/blob/a64fd6caea23299587aba7a66cd0d157ad9bcc3e/rfcs/Struct.md",actor:"Benjie"},{type:"docUpdated",date:"2022-10-24T10:21:35.000Z",href:"https://github.com/graphql/graphql-wg/blob/ab192ae0b078566ad2d2fafafb24248aab017968/rfcs/Struct.md",actor:"Alexander Varwijk"},{type:"docUpdated",date:"2022-10-20T17:26:24.000Z",href:"https://github.com/graphql/graphql-wg/blob/e9e292f62912f36e75bd201901a4556e4b1128b0/rfcs/Struct.md",actor:"Mark Larah"},{type:"docUpdated",date:"2022-07-22T09:23:36.000Z",href:"https://github.com/graphql/graphql-wg/blob/b95adab903828251dd2006c6dd1c2c3b67f58d00/rfcs/Struct.md",actor:"Benjie Gillam"},{type:"docCreated",date:"2022-07-07T16:52:49.000Z",href:"https://github.com/graphql/graphql-wg/blob/ab0985750e561225fedaf322157e974c631aadda/rfcs/Struct.md",actor:"Benjie Gillam"}],related:"127, 147, 237, 688, 929, 942, InputUnion, wg1071",shortname:"Polymorphic-capable composite symmetric input/output type (`struct`)",image:"/img/rfc_tracker.png"},sidebar:"rfcsSidebar",previous:{title:"Feature Discovery",permalink:"/rfcs/FeatureDiscovery"},next:{title:"Introduce SourceSchemaDocument and FullSchemaDocument",permalink:"/rfcs/1049"}},l={},c=[{value:"At a glance",id:"at-a-glance",level:2},{value:"Timeline",id:"timeline",level:2},{value:"Why?",id:"why",level:2},{value:"Scalar with structure",id:"scalar-with-structure",level:3},{value:"Composite type capable of input polymorphism",id:"composite-type-capable-of-input-polymorphism",level:3},{value:"Symmetric polymorphism",id:"symmetric-polymorphism",level:3},{value:"Non-infinite recursion",id:"non-infinite-recursion",level:3},{value:"Symmetric transput composite type",id:"symmetric-transput-composite-type",level:3},{value:"Wildcard selection",id:"wildcard-selection",level:3},{value:"What could it look like?",id:"what-could-it-look-like",level:2},{value:"<code>struct</code>",id:"struct",level:3},{value:"Pure structured data",id:"pure-structured-data",level:3},{value:"<code>__typename</code>",id:"__typename",level:3},{value:"Struct union",id:"struct-union",level:3},{value:"Example schema",id:"example-schema",level:3},{value:"Selection sets",id:"selection-sets",level:3},{value:"Why doesn&#39;t GraphQL support wildcards over object types?",id:"why-doesnt-graphql-support-wildcards-over-object-types",level:3},{value:"Should <code>struct</code> replace input objects?",id:"should-struct-replace-input-objects",level:2},{value:"Use cases",id:"use-cases",level:2},{value:"Server Driven UI",id:"server-driven-ui",level:3},{value:"Enabling cross-platform user content",id:"enabling-cross-platform-user-content",level:3},{value:"Simplified client queries",id:"simplified-client-queries",level:4}];function h(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",section:"section",strong:"strong",sup:"sup",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"at-a-glance",children:"At a glance"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Identifier"}),": Struct"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Stage"}),": ",(0,s.jsx)(t.a,{href:"https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md#stage-0-strawman",children:"RFC0: Strawman"})]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Champion"}),": -"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"PR"}),": -"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Related"}),":","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"/rfcs/InputUnion",title:"GraphQL Input Union / RFC0",children:"InputUnion"})," (GraphQL Input Union)"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"/rfcs/wg1071",title:"Struct type / RFC0",children:"wg#1071"})," (Struct type)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"timeline",children:"Timeline"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"https://github.com/graphql/graphql-wg/blob/c46f67dad4154c3b693d337c815900a5c7909423/rfcs/Struct.md",children:"RFC document updated"})})," on 2023-11-28 by Benjie"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"https://github.com/graphql/graphql-wg/blob/c599436ddf5737dcee28d46e77eec567921c0ac1/rfcs/Struct.md",children:"RFC document updated"})})," on 2023-08-24 by Tushar Mathur"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"https://github.com/graphql/graphql-wg/blob/a64fd6caea23299587aba7a66cd0d157ad9bcc3e/rfcs/Struct.md",children:"RFC document updated"})})," on 2023-01-19 by Benjie"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"https://github.com/graphql/graphql-wg/blob/ab192ae0b078566ad2d2fafafb24248aab017968/rfcs/Struct.md",children:"RFC document updated"})})," on 2022-10-24 by Alexander Varwijk"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"https://github.com/graphql/graphql-wg/blob/e9e292f62912f36e75bd201901a4556e4b1128b0/rfcs/Struct.md",children:"RFC document updated"})})," on 2022-10-20 by Mark Larah"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"https://github.com/graphql/graphql-wg/blob/b95adab903828251dd2006c6dd1c2c3b67f58d00/rfcs/Struct.md",children:"RFC document updated"})})," on 2022-07-22 by Benjie Gillam"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.a,{href:"https://github.com/graphql/graphql-wg/blob/ab0985750e561225fedaf322157e974c631aadda/rfcs/Struct.md",children:"RFC document created"})})," on 2022-07-07 by Benjie Gillam"]}),"\n"]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.h1,{id:"polymorphic-capable-composite-symmetric-inputoutput-type-struct",children:["Polymorphic-capable composite symmetric input/output type (",(0,s.jsx)(t.code,{children:"struct"}),")"]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.em,{children:'a.k.a "Structured, Type-safe, Returnable and Union-Capable Type" S.T.R.U.C.T.'})}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:['GraphQL currently has two types that are suitable for both input and output:\nscalar and enum. These are both "leaf" types that generally',(0,s.jsx)(t.sup,{children:(0,s.jsx)(t.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})," possess no\nstructure."]}),"\n",(0,s.jsxs)(t.p,{children:["GraphQL currently has one ",(0,s.jsx)(t.em,{children:"composite"})," type that is suitable for input: the input\nobject type. This type possesses structure, but is only available on input (and\ndoes not support polymorphism)."]}),"\n",(0,s.jsx)(t.p,{children:"This proposal is for a composite type (a type with structure) which is available\non both input and output, and which supports polymorphism."}),"\n",(0,s.jsx)(t.h2,{id:"why",children:"Why?"}),"\n",(0,s.jsx)(t.p,{children:"A polymorphic-capable composite type that's available on both input and output\nwould address a number of use cases, so lets dig into them individually:"}),"\n",(0,s.jsx)(t.h3,{id:"scalar-with-structure",children:"Scalar with structure"}),"\n",(0,s.jsxs)(t.p,{children:["Sometimes the data that a leaf field resolver returns may have structure,\nrepresented via something like a custom scalar (e.g. 'JSON'). It would be nice\nto share the schema of this data with the client to enable the client to\nunderstand it better; this may be solved in part with ",(0,s.jsx)(t.code,{children:"@specifiedBy"}),", but it\nwould be beneficial to leverage the capabilities that GraphQL already has."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://www.npmjs.com/package/graphql-type-json",children:"https://www.npmjs.com/package/graphql-type-json"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://github.com/graphql/graphql-spec/issues/688",children:"https://github.com/graphql/graphql-spec/issues/688"})}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"composite-type-capable-of-input-polymorphism",children:"Composite type capable of input polymorphism"}),"\n",(0,s.jsxs)(t.p,{children:['The search for an "input union" type has been around for a long time; many of\nthe use cases and proposed solutions to this problem are discussed in the\n',(0,s.jsx)(t.a,{href:"https://github.com/graphql/graphql-wg/blob/main/rfcs/InputUnion.md",children:"InputUnion RFC"}),".\nThe author of this RFC was also the author of three other RFCs to address the\ninput union problem, the leading one at this time being the ",(0,s.jsx)(t.code,{children:"@oneOf"})," type.\nPlease see the InputUnion RFC for more details of why this feature is desired in\nGraphQL."]}),"\n",(0,s.jsx)(t.h3,{id:"symmetric-polymorphism",children:"Symmetric polymorphism"}),"\n",(0,s.jsx)(t.p,{children:'One of the "high priority" desires for an InputUnion solution is "input\npolymorphism matches output polymorphism." A union of structs would be suitable\nfor use on both input and output, since structs themselves are.'}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://github.com/graphql/graphql-wg/blob/main/rfcs/InputUnion.md#-b-input-polymorphism-matches-output-polymorphism",children:"https://github.com/graphql/graphql-wg/blob/main/rfcs/InputUnion.md#-b-input-polymorphism-matches-output-polymorphism"})}),"\n",(0,s.jsx)(t.h3,{id:"non-infinite-recursion",children:"Non-infinite recursion"}),"\n",(0,s.jsx)(t.p,{children:"There have been a good few times that non-infinite recursion has been asked for\nin GraphQL. Here's just a couple of the conversations on this topic:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://github.com/graphql/graphql-spec/issues/237",children:"https://github.com/graphql/graphql-spec/issues/237"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://github.com/graphql/graphql-spec/issues/929",children:"https://github.com/graphql/graphql-spec/issues/929"})}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Even introspection would benefit from non-infinite recursion - it would allow to\nrequest the full type of a field no matter how many list wrappers the type\ncontained. Currently the best we have is to repeat a structure in the query:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://github.com/graphql/graphql-js/blob/cfbc023296a1a596429a6312abede040c9353644/src/utilities/getIntrospectionQuery.ts#L131-L162",children:"https://github.com/graphql/graphql-js/blob/cfbc023296a1a596429a6312abede040c9353644/src/utilities/getIntrospectionQuery.ts#L131-L162"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-graphql",children:"fragment TypeRef on __Type {\n  kind\n  name\n  ofType {\n    kind\n    name\n    ofType {\n      kind\n      name\n      ofType {\n        # repeated 5 more times...\n"})}),"\n",(0,s.jsxs)(t.p,{children:['A use case that I\'ve had for this non-infinite recursion is trying to generate a\n"table of contents" for a tree structure (a DAG in my case). I resorted to the\n',(0,s.jsx)(t.code,{children:"JSON"})," type, another solution is to turn the tree into a list, and turn the list\nback into a tree on the client. A better solution would be to stick to the\ntenets of GraphQL and return the data in the shape that the client needs, fully\ntype-safe."]}),"\n",(0,s.jsx)(t.h3,{id:"symmetric-transput-composite-type",children:"Symmetric transput composite type"}),"\n",(0,s.jsx)(t.p,{children:"Currently when a user wants to be able to input and output the exact same data\nin a future-proof way, they must use a scalar or enum. This is one of the things\nthat has made solutions like the 'JSON' scalar quite popular, but it lacks\nstrong type safety guarantees."}),"\n",(0,s.jsxs)(t.p,{children:["In the GraphQL spec we use ",(0,s.jsx)(t.code,{children:"String"})," to represent things like the ",(0,s.jsx)(t.code,{children:"defaultValue"}),"\nof an argument or input field. Having to parse a string is not ideal; a type\nthat is symmetric over input and output would allow us to represent\n",(0,s.jsx)(t.code,{children:"defaultValue"})," in a much easier to consume way."]}),"\n",(0,s.jsx)(t.p,{children:"When thinking about schema metadata, a type that can both be input (e.g. via\ndirectives or similar) and output identically would be quite desirable."}),"\n",(0,s.jsx)(t.p,{children:"If your GraphQL API supports complex filtering or aggregate queries (for example\nif you're building a reporting dashboard or similar), you may want to be able to\nboth issue queries using these advanced parameters, and to store them to/load\nsaved versions of them from the backend. Having the data for this be symmetric\nwould be beneficial. Doing this with object type and input type is currently\nunsafe as your API evolves as older clients will not request properties they did\nnot know about, potentially resulting in data loss; if we adopt wildcard\nselection over structs (as discussed below) we may solve this issue."}),"\n",(0,s.jsx)(t.h3,{id:"wildcard-selection",children:"Wildcard selection"}),"\n",(0,s.jsx)(t.p,{children:"This has been discussed many times:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://github.com/graphql/graphql-spec/issues/127",children:"https://github.com/graphql/graphql-spec/issues/127"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://github.com/graphql/graphql-spec/issues/147",children:"https://github.com/graphql/graphql-spec/issues/147"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://github.com/graphql/graphql-spec/issues/942",children:"https://github.com/graphql/graphql-spec/issues/942"})}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"GraphQL's reasoning for not performing wildcard selection with object types is\nvery sensible, and I do not argue against that in any way (I fully support it)."}),"\n",(0,s.jsxs)(t.p,{children:["However, imagine that you're dealing with a concrete piece of data that has\nstructure, such as a time interval. In this case, you might have something like:\n",(0,s.jsx)(t.code,{children:"{months: 2, days: 8, hours: 23}"}),'. Since this is pure data, it does not have\narguments, it does not have relations to other types (the entire type is\neffectively a "leaf" of our graph), and it only makes sense when you have the\nwhole value. If you were to add ',(0,s.jsx)(t.code,{children:"decades: Int"})," to this type, it would be\nessential that old clients pulled this field down, and baulked if they did not\nknow how to handle it - it would be unsafe for them to only process the\n",(0,s.jsx)(t.code,{children:"months"}),", ",(0,s.jsx)(t.code,{children:"days"})," and ",(0,s.jsx)(t.code,{children:"hours"})," if there was also a ",(0,s.jsx)(t.code,{children:"decades"})," field that they could\nnot have known about. Currently your best bet to deal with this is a custom\nscalar for the entire ",(0,s.jsx)(t.code,{children:"Interval"})," type, but that loses details about this\nstructure."]}),"\n",(0,s.jsxs)(t.p,{children:["It's possible to imagine deeper structures than ",(0,s.jsx)(t.code,{children:"Interval"})," that have these same\nconcerns, perhaps things like the save formats for WYSIWYG editors or similar,\nall of which want to act like a ",(0,s.jsx)(t.code,{children:"scalar"})," (i.e. no resolvers within them, no\narguments, just pure data), and yet have composite structure represented by the\nschema."]}),"\n",(0,s.jsxs)(t.p,{children:["On top of this, there are situations where you might ",(0,s.jsx)(t.em,{children:"want"})," to make explicit\nsub-selections. For example, consider a ",(0,s.jsx)(t.a,{href:"https://geojson.org/",children:(0,s.jsx)(t.code,{children:"GeoJSON"})}),"\nvalue - you may wish to only query the ",(0,s.jsx)(t.code,{children:"type"})," and ",(0,s.jsx)(t.code,{children:"geometry"})," so that you can\nplot it on a map, and not concern yourself with the (potentially multi-megabyte)\nadditional properties."]}),"\n",(0,s.jsx)(t.p,{children:"Allowing for wildcard selection along with explicit selection for these\nstructured scalar-like pure data types is desirable."}),"\n",(0,s.jsxs)(t.p,{children:["Another example of where this is useful is with traditional RESTful APIs which\nuse the ",(0,s.jsx)(t.code,{children:"PUT"})," (rather than ",(0,s.jsx)(t.code,{children:"PATCH"}),') mechanic - i.e. they replace the entire\nobject rather than "patching" it. To allow us to do this in a future compatible\nway (allowing for the object to gain more properties over time) we must be\ncareful not to accidentally drop properties that we do not understand, so we\nshould pull down the entire object, modify the parts that we want to (leaving\nparts we don\'t understand alone) and then send the entire (modified) object back\nto the server.']}),"\n",(0,s.jsx)(t.h2,{id:"what-could-it-look-like",children:"What could it look like?"}),"\n",(0,s.jsx)(t.p,{children:"There are two types that are close to solving this problem already:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Input objects are already a structured input that handle many of our concerns,\nbut they're only valid on input"}),"\n",(0,s.jsx)(t.li,{children:"Scalars are already available on both input and output, and users can define\ntheir own"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"I see three approaches that we could take that would all be broadly similar in\nterms of achieving our goals, but have slightly different trade-offs:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["give ",(0,s.jsx)(t.code,{children:"scalar"})," optional fields, turning it intro a ",(0,s.jsx)(t.code,{children:"struct"})]}),"\n",(0,s.jsxs)(t.li,{children:["enable ",(0,s.jsx)(t.code,{children:"input"})," to be used in output too, turning it into a ",(0,s.jsx)(t.code,{children:"struct"})]}),"\n",(0,s.jsxs)(t.li,{children:["introduce a new ",(0,s.jsx)(t.code,{children:"struct"})," type"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"I've gone full circle on this, and am currently thinking that option 1 is our\nbest bet."}),"\n",(0,s.jsxs)(t.p,{children:["Option 2 is tempting because in the other scenarios ",(0,s.jsx)(t.code,{children:"struct"})," and\n",(0,s.jsx)(t.code,{children:"input"})," will overlap significantly and it will be less than clear when to use\none rather than the other. However, it suffers from some backwards-compatibility\nconcerns - namely that an input object being used on output is likely to confuse\nexisting tooling such as GraphiQL, and it's entirely unknown to them whether an\ninput object should require\u200b a selection set or not."]}),"\n",(0,s.jsxs)(t.p,{children:["Option 1 feels like it could be done in a more backwards-compatible manner since\nthe majority of existing tools and clients would not look at the ",(0,s.jsx)(t.code,{children:"fields"})," entry\non a scalar (so would not be confused by it) and already handle custom scalars\nsuch as the ",(0,s.jsx)(t.code,{children:"JSON"})," scalar returning structured output, and can continue to omit\na selection set on this enhanced scalar, thus continuing to operate correctly."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"NOTE"}),": this syntax, these keywords, etc. are not set in stone. Discussion is\nvery welcome!"]}),"\n",(0,s.jsx)(t.h3,{id:"struct",children:(0,s.jsx)(t.code,{children:"struct"})}),"\n",(0,s.jsxs)(t.p,{children:["No matter which of the three approaches we take (scalar, input, new type), the\nresulting type (",(0,s.jsx)(t.code,{children:"struct"}),") will be composed of fields, each field has a type, and\nthe type of a ",(0,s.jsx)(t.code,{children:"struct"})," field can be a ",(0,s.jsx)(t.code,{children:"struct"}),", scalar, enum, struct union, or a\nwrapping type over any of these. (i.e. it is only composed of types that are\nvalid in both input and output.)"]}),"\n",(0,s.jsxs)(t.p,{children:["Importantly, when querying a ",(0,s.jsx)(t.code,{children:"struct"})," you can never reach an object type, union\nor interface from within a ",(0,s.jsx)(t.code,{children:"struct"})," - the entire ",(0,s.jsx)(t.code,{children:"struct"})," acts like a leaf (a\nleaf with structure)."]}),"\n",(0,s.jsxs)(t.p,{children:["Similarly, for input, a ",(0,s.jsx)(t.code,{children:"struct"})," may never contain an input object (unless that\ninput object is, itself, a struct)."]}),"\n",(0,s.jsxs)(t.p,{children:["Similar to input objects, a ",(0,s.jsx)(t.code,{children:"struct"})," may not contain an unbreakable cycle."]}),"\n",(0,s.jsx)(t.p,{children:"A struct might look something like this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-graphql",children:"struct Biography {\n  title: String!\n  socials: BiographySocials\n  paragraphs: [Paragraph!]!\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["(Note how this is basically identical to an ",(0,s.jsx)(t.code,{children:"input"})," definition.)"]}),"\n",(0,s.jsx)(t.h3,{id:"pure-structured-data",children:"Pure structured data"}),"\n",(0,s.jsxs)(t.p,{children:["Like scalars, structs represent pure data that is the same on input as on\noutput. Unlike scalars, however, structs have structure (and thus fields) - but\nsince they're just pure data their fields do not have resolvers, and do not\naccept arguments. They are ",(0,s.jsx)(t.strong,{children:"NOT"})," a replacement for Objects!"]}),"\n",(0,s.jsx)(t.h3,{id:"__typename",children:(0,s.jsx)(t.code,{children:"__typename"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"__typename"})," is available to query on all ",(0,s.jsx)(t.code,{children:"struct"}),"s. This ensures that clients\nthat automatically and silently add the ",(0,s.jsx)(t.code,{children:"__typename"})," meta-field to every\nselection set will not break, and is could also be useful for resolving the type\nof a struct union."]}),"\n",(0,s.jsxs)(t.p,{children:["On input of a ",(0,s.jsx)(t.code,{children:"struct"}),", ",(0,s.jsx)(t.code,{children:"__typename"})," is optional but recommended."]}),"\n",(0,s.jsxs)(t.p,{children:["Champion's note: if we were to make ",(0,s.jsx)(t.code,{children:"__typename"})," required on all ",(0,s.jsx)(t.code,{children:"struct"})," inputs\nthen changing an input type from ",(0,s.jsx)(t.code,{children:"struct"})," to struct union (see below) would be\nnon-breaking; this is a nice advantage, but is currently outweighed by the\ndesire to make input pleasant for users, and to make ",(0,s.jsx)(t.code,{children:"struct"})," compatible with\nexisting input objects."]}),"\n",(0,s.jsx)(t.h3,{id:"struct-union",children:"Struct union"}),"\n",(0,s.jsxs)(t.p,{children:["A struct union is an abstract type representing that the value may be one of\nmany possible ",(0,s.jsx)(t.code,{children:"struct"}),"s. Rather than requiring a new type, we can define a\nstruct union as a union that only contains structs:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-graphql",children:"union Paragraph =\n    TextParagraph\n  | PullquoteParagraph\n  | BlockquoteParagraph\n  | TweetParagraph\n  | GalleryParagraph\n"})}),"\n",(0,s.jsxs)(t.p,{children:["(A ",(0,s.jsx)(t.code,{children:"union"})," must only consist of object types, or only of structs, never a mix of\nthe two.)"]}),"\n",(0,s.jsxs)(t.p,{children:["Champion's note: We could use a different keyword, such as ",(0,s.jsx)(t.code,{children:"structUnion"}),", to\nenforce this, but I'm not convinced this is necessary.)"]}),"\n",(0,s.jsx)(t.p,{children:"Champion's note: I'm very open to dropping struct union and using a oneOf\napproach instead, or adding a oneOf approach in addition. I've gone with struct\nunion for now for greater similarity with the existing GraphQL types."}),"\n",(0,s.jsx)(t.p,{children:"A struct union is valid in both input and output."}),"\n",(0,s.jsxs)(t.p,{children:["On input of a struct union, ",(0,s.jsx)(t.code,{children:"__typename"})," is required in order to determine the\ntype of the ",(0,s.jsx)(t.code,{children:"struct"})," supplied."]}),"\n",(0,s.jsx)(t.h3,{id:"example-schema",children:"Example schema"}),"\n",(0,s.jsx)(t.p,{children:"Here's an example schema where a user can customise their biography by composing\ntogether paragraphs of different types. You could imagine that these paragraphs\nwere managed by an editor such as ProseMirror."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-graphql",children:"type Query {\n  user(id: ID!): User\n}\n\ntype Mutation {\n  setUserBio(userId: ID!, bio: Biography!): User\n}\n\ntype User {\n  id: ID!\n  username: String!\n  bio: Biography!\n}\n\nstruct Biography {\n  title: String!\n  socials: BiographySocials\n  paragraphs: [Paragraph!]!\n}\n\nstruct BiographySocials {\n  github: String\n  twitter: String\n  linkedIn: String\n  facebook: String\n}\n\nunion Paragraph =\n  | TextParagraph\n  | PullquoteParagraph\n  | BlockquoteParagraph\n  | TweetParagraph\n  | GalleryParagraph\n\nstruct TextParagraph {\n  text: String!\n}\nstruct PullquoteParagraph {\n  pullquote: String!\n  source: String\n}\nstruct BlockquoteParagraph {\n  paragraphs: [Paragraph!]!\n  source: String\n}\nstruct TweetParagraph {\n  message: String!\n  url: String!\n}\nstruct GalleryParagraph {\n  images: [Image!]!\n}\n\nstruct Image {\n  url: String!\n  caption: String\n}\n"})}),"\n",(0,s.jsx)(t.h3,{id:"selection-sets",children:"Selection sets"}),"\n",(0,s.jsxs)(t.p,{children:["Controversially, structs could be the first type in GraphQL that can act as both\na leaf ",(0,s.jsx)(t.em,{children:"and"})," a non-leaf type - i.e. a selection set over them is optional. If\nyou do not provide a selection set then the entire value is returned. If you do\nprovide a selection set then those fields will be selected and returned."]}),"\n",(0,s.jsx)(t.p,{children:"Struct selection sets are similar to, but not the same as, regular selection\nsets. In particular:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["struct fields are not ",(0,s.jsx)(t.code,{children:"FIELD"}),"s, i.e. they cannot have ",(0,s.jsx)(t.code,{children:"FIELD"})," directives\nattached (suggest we call them ",(0,s.jsx)(t.code,{children:"STRUCT_FIELD"}),")"]}),"\n",(0,s.jsx)(t.li,{children:"aliases are not allowed, otherwise the simple field merging (see below) does\nnot work (also there's no need for aliasing because struct fields are pure\ndata and do not accept arguments, so they cannot produce multiple values for\nthe same field)"}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Both inline and named fragments are supported on ",(0,s.jsx)(t.code,{children:"struct"}),"s and struct unions."]}),"\n",(0,s.jsx)(t.p,{children:"Field merging is very straightforward; for the example schema above, the\nfollowing query:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-graphql",children:'{\n  user(id: "1") {\n    bio {\n      title\n    }\n    bio {\n      socials {\n        twitter\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"would be equivalent to:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-graphql",children:'{\n  user(id: "1") {\n    bio {\n      title\n      socials {\n        twitter\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["(Note that the object with both ",(0,s.jsx)(t.code,{children:"title"})," and ",(0,s.jsx)(t.code,{children:"socials{twitter}"})," satisfies both\nselection sets.)"]}),"\n",(0,s.jsx)(t.p,{children:"And similarly, the following:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-graphql",children:'{\n  user(id: "1") {\n    ...A\n    ...B\n    ...C\n  }\n}\n\nfragment A on User {\n  bio {\n    title\n  }\n}\n\nfragment B on User {\n  bio {\n    socials {\n      twitter\n    }\n  }\n}\n\nfragment C on User {\n  # Select the entire field\n  bio\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"would be equivalent to:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-graphql",children:'{\n  user(id: "1") {\n    bio\n  }\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["(Note that because we're selecting the entire ",(0,s.jsx)(t.code,{children:"bio"})," field in ",(0,s.jsx)(t.code,{children:"C"}),", all possible\nsubselections are satisfied, and thus A and B are happy.)"]}),"\n",(0,s.jsx)(t.h3,{id:"why-doesnt-graphql-support-wildcards-over-object-types",children:"Why doesn't GraphQL support wildcards over object types?"}),"\n",(0,s.jsx)(t.p,{children:"In general GraphQL, wildcards have a lot of questions:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Which fields do we select?"}),"\n",(0,s.jsx)(t.li,{children:"What do we do for fields with arguments?"}),"\n",(0,s.jsx)(t.li,{children:"What do we do about deprecated fields?"}),"\n",(0,s.jsxs)(t.li,{children:["Do we automatically add subselections to non-leaf fields?","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"How deep do we go?"}),"\n",(0,s.jsx)(t.li,{children:"What happens if there's an infinite loop?"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.li,{children:"Etc."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:'They also impede the "versionless schema" desire of GraphQL - if a client uses\nwildcards then when new fields are added the client will start receiving these\ntoo, sending them data that they may not understand or desire and causing\nversioning problems.'}),"\n",(0,s.jsxs)(t.p,{children:["However, if we constrain the problem space down to that of pure structured data\n(treating it like an atom - like a ",(0,s.jsx)(t.code,{children:"scalar"})," is currently) then many of these\nconcerns lessen."]}),"\n",(0,s.jsxs)(t.h2,{id:"should-struct-replace-input-objects",children:["Should ",(0,s.jsx)(t.code,{children:"struct"})," replace input objects?"]}),"\n",(0,s.jsxs)(t.p,{children:["Maybe... They do seem to solve many of the same problems. However one major\ndifference is intent; because ",(0,s.jsx)(t.code,{children:"struct"})," is intended to be used for input/output\nit's intended that you pull it down, modify it as need be, and then send it back\nagain. As such, adding a non-nullable field to a struct used in this way may not\nbe a breaking change - existing clients should automatically receive the\nadditional fields, and send them back unmodified."]}),"\n",(0,s.jsxs)(t.p,{children:["The semantics of ",(0,s.jsx)(t.code,{children:"struct"})," and input objects are very similar, so it could be\nthat we repurpose input objects for struct usage. This will need careful\nthought, discussion and investigation. Not least because the term ",(0,s.jsx)(t.code,{children:"input"})," would\nmake it confusing ;)"]}),"\n",(0,s.jsx)(t.h2,{id:"use-cases",children:"Use cases"}),"\n",(0,s.jsx)(t.h3,{id:"server-driven-ui",children:"Server Driven UI"}),"\n",(0,s.jsx)(t.p,{children:"Server Driven UI (SDUI) is a not uncommon pattern for application data fetching,\nin which objects directly map to UI components."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://medium.com/airbnb-engineering/a-deep-dive-into-airbnbs-server-driven-ui-system-842244c5f5",children:"https://medium.com/airbnb-engineering/a-deep-dive-into-airbnbs-server-driven-ui-system-842244c5f5"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://engineeringblog.yelp.com/2021/11/building-a-server-driven-foundation-for-mobile-app-development.html",children:"https://engineeringblog.yelp.com/2021/11/building-a-server-driven-foundation-for-mobile-app-development.html"})}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Encoding SDUI responses as ",(0,s.jsx)(t.code,{children:"struct"}),"s would address query complexity issues that\nSDUI-over-GraphQL suffers from today, when adopted on a large scale. Specifically,\nselection sets have to (recursively) request all properties of all union memebers,\nwhich:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"blows up request payload sizes"}),"\n",(0,s.jsx)(t.li,{children:"how far do you limit the recursion?"}),"\n",(0,s.jsx)(t.li,{children:"client developers have to either keep the query in sync with what the server\noffers by hand, or introduce custom tooling and treat the query as a compile\ntarget"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"For example, imagine a schema with a very low level of abstraction over UI\nprimatives:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-graphql",children:'{ \n  sduiView(view: "my_cool_marketing_page") {\n    ... on SDUIBox {\n      ... on SDUIButton {\n        label\n        radius\n        action\n      }\n      ... on SDUIText {\n        font\n        weight\n        body\n      }\n      ... on SDUIBox {\n        ... on SDUIButton {\n          label\n          radius\n          action\n        }\n        ... on SDUIText {\n          font\n          weight\n          body\n        }\n        ... on SDUIBox {\n          ...\n        }\n      }\n    }\n    ...\n  }\n  ...\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"This clearly poses challanges for developers maintaining this query, who might\nreasonably prefer to write a query like this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-graphql",children:'{ \n  sduiView(view: "my_cool_marketing_page")\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"enabling-cross-platform-user-content",children:"Enabling cross-platform user content"}),"\n",(0,s.jsx)(t.p,{children:"In an application that allows creating user content (like a blog, or a social\nmedia platform) quite a few fields can be input using structured data such as a\ntitle, publishing date, hero image. However, the most important part, the body of\nthe content, is often structured but arbitrary content."}),"\n",(0,s.jsx)(t.p,{children:"Various services solve this in different ways but usually suffer from one of\nvarious drawbacks. Allowing either the raw input (e.g. Markdown) or providing\nspecific rendered formats. However, this means that either every client becomes\ntied to the input format and the service can no longer change this (e.g. upgrade\nto a newer Markdown format) or the client must jump through hoops to access data\nwithin the rendered blob (e.g. to load an optimised image or video embedded in\nthe content)."}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"struct"})," approach outlined in this RFC would solve these issues by allowing\nthe GraphQL server to provide this user data in a structured format. The server\ncan now change the input formats it accepts as the output can be normalised JSON\ncontent. Similarly clients can either request the whole document and render it as\nthey see fit or query for specific parts of the user content."]}),"\n",(0,s.jsx)(t.p,{children:"This allows different clients to render different formats (e.g. HTML for the web\nor native components for a mobile app) without being tied to the server's input\nformat (e.g. Markdown or HTML) and without having to parse a server rendered\nrepresentation (e.g. Plain-Text, HTML or Markdown)."}),"\n",(0,s.jsx)(t.p,{children:"The schema for this example would be similar to the schema provided in the Struct\nUnion excample. The use-case does highlight one drawback with respect to the\nconstraints outlined in the use-case."}),"\n",(0,s.jsxs)(t.p,{children:["Since ",(0,s.jsx)(t.code,{children:"struct"}),"s can not themselves contain ",(0,s.jsx)(t.code,{children:"object"}),"s providing the structured\ncontent in this manner would mean that the client could not request optimised\nmedia (one of the reasons why a pre-rendered output was undesirable in the first\nplace), or the image type itself must be a struct which seems to disallow\narguments fields which is a common pattern to request specific transformations of\nan image."]}),"\n",(0,s.jsx)(t.p,{children:"e.g. the following is a simplified example for a way to query images often used\nby Shopify or specific image-resizing services that support GraphQL."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-gql",children:'type Image implements Node {\n    id: ID!\n    """\n    The location of the image as a URL.\n\n    If no transform options are specified, then the original image will be preserved including any pre-applied transforms.\n\n    All transformation options are considered "best-effort". Any transformation that the original image type doesn\'t support will be ignored.\n\n    If you need multiple variations of the same image, then you can use [GraphQL aliases](https://graphql.org/learn/queries/#aliases).\n    """\n    url(transform: ImageTransformInput): Url!\n}\n\n"""\nThe available options for transforming an image.\n\nAll transformation options are considered "best-effort". Any transformation that the original image type doesn\'t support will be ignored.\n"""\ninput ImageTransformInput {\n    """\n    Image height in pixels between 1 and 5760.\n    """\n    width: Int\n    """\n    Image width in pixels between 1 and 5760.\n    """\n    height: Int\n}\n'})}),"\n",(0,s.jsx)(t.h4,{id:"simplified-client-queries",children:"Simplified client queries"}),"\n"]}),"\n",(0,s.jsxs)(t.section,{"data-footnotes":!0,className:"footnotes",children:[(0,s.jsx)(t.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{id:"user-content-fn-1",children:["\n",(0,s.jsxs)(t.p,{children:["Custom scalars may possess internal structure, a common example of this is\nthe 'JSON' scalar, however this structure is not defined by nor can it be\nqueried via GraphQL (",(0,s.jsx)(t.code,{children:"specifiedBy"})," notwithstanding). ",(0,s.jsx)(t.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>a});var s=n(7294);const r={},i=s.createContext(r);function a(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);