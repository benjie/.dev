"use strict";(self.webpackChunk_localrepo_benjie_dev=self.webpackChunk_localrepo_benjie_dev||[]).push([[7435],{9425:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>r});var i=t(5893),o=t(1151);const s={identifier:"ObjectIdentification",stage:"0",title:"Object Identification",events:[{type:"docCreated",date:new Date("2025-10-15T13:55:58.000Z"),href:"https://github.com/graphql/graphql-wg/blob/f30bf3559c4deccaf7822a0a96b5f081098d8b91/rfcs/ObjectIdentification.md",actor:"Lenz Weber-Tronic"}],shortname:"Object Identification",image:"/img/rfc_tracker.png"},l=void 0,c={id:"ObjectIdentification",title:"Object Identification",description:"At a glance",source:"@site/rfcs/ObjectIdentification.md",sourceDirName:".",slug:"/ObjectIdentification",permalink:"/rfcs/ObjectIdentification",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{identifier:"ObjectIdentification",stage:"0",title:"Object Identification",events:[{type:"docCreated",date:"2025-10-15T13:55:58.000Z",href:"https://github.com/graphql/graphql-wg/blob/f30bf3559c4deccaf7822a0a96b5f081098d8b91/rfcs/ObjectIdentification.md",actor:"Lenz Weber-Tronic"}],shortname:"Object Identification",image:"/img/rfc_tracker.png"},sidebar:"rfcsSidebar",previous:{title:"\x3c!-- This template is provided as a suggested starting point. You may alter the",permalink:"/rfcs/TEMPLATE"},next:{title:"Field Extensions",permalink:"/rfcs/FieldExtensions"}},a={},r=[{value:"At a glance",id:"at-a-glance",level:2},{value:"Timeline",id:"timeline",level:2},{value:"Problem statement",id:"problem-statement",level:2},{value:"Proposal",id:"proposal",level:2},{value:"Introduction of an <code>__id</code> introspection field",id:"introduction-of-an-__id-introspection-field",level:3},{value:"Intoduction of an <code>__Entity</code> interface",id:"intoduction-of-an-__entity-interface",level:3},{value:"Presence of globally identifiable types in the schema",id:"presence-of-globally-identifiable-types-in-the-schema",level:3},{value:"Suggested Spec addition",id:"suggested-spec-addition",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"at-a-glance",children:"At a glance"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Identifier"}),": ObjectIdentification"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stage"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md#stage-0-strawman",children:"RFC0: Strawman"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Champion"}),": -"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"PR"}),": -"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"timeline",children:"Timeline"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/f30bf3559c4deccaf7822a0a96b5f081098d8b91/rfcs/ObjectIdentification.md",children:"RFC document created"})})," on 2025-10-15 by Lenz Weber-Tronic"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.h1,{id:"rfc-object-identification",children:"RFC: Object Identification"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Proposed by:"})," ",(0,i.jsx)(n.a,{href:"https://github.com/phryneas",children:"Lenz Weber-Tronic"})," - Apollo"]}),"\n",(0,i.jsx)(n.h2,{id:"problem-statement",children:"Problem statement"}),"\n",(0,i.jsx)(n.p,{children:"Currently, there is no way for clients to know if an object can be uniquely identified. This makes it hard for clients to implement caching strategies that rely on object identity for normalization, or for AI agents that need to communicate with other systems, referencing objects returned from a GraphQL API."}),"\n",(0,i.jsxs)(n.p,{children:["This is in part solved by patterns like ",(0,i.jsx)(n.a,{href:"https://graphql.org/learn/global-object-identification/",children:"Global Object Identification"}),", but this is nothing clients can generally rely on, since there is no guarantee that a server actually follows this pattern or just accidentally overlaps with it, without actually fully implementing it."]}),"\n",(0,i.jsxs)(n.p,{children:["Also, the Global Object Identification pattern is not enough for the use case of a Client without schema knowledge - such a client couldn't inject a selection for ",(0,i.jsx)(n.code,{children:"id"})," into all object selections (as they usually do with ",(0,i.jsx)(n.code,{children:"__typename"}),"), since it doesn't know which objects actually have an ",(0,i.jsx)(n.code,{children:"id"})," field and the resulting query might be invalid."]}),"\n",(0,i.jsx)(n.h2,{id:"proposal",children:"Proposal"}),"\n",(0,i.jsxs)(n.h3,{id:"introduction-of-an-__id-introspection-field",children:["Introduction of an ",(0,i.jsx)(n.code,{children:"__id"})," introspection field"]}),"\n",(0,i.jsxs)(n.p,{children:["This proposal introduces a new introspection field ",(0,i.jsx)(n.code,{children:"__id"}),", which can be queried on any object, interface or union type.\nThe field is of type ",(0,i.jsx)(n.code,{children:"ID"})," and for each individual type, the field must either always return a non-null value or always return null."]}),"\n",(0,i.jsxs)(n.p,{children:["If an ",(0,i.jsx)(n.code,{children:"__id"})," field returns a non-null value for a type, this value must be guaranteed to uniquely identify the object when combined with the value of the ",(0,i.jsx)(n.code,{children:"__typename"})," field."]}),"\n",(0,i.jsxs)(n.p,{children:["This would allow clients without schema knowledge to query for ",(0,i.jsx)(n.code,{children:"__id"})," on selection set and use the returned value for caching or referencing the object in other systems, if it is not ",(0,i.jsx)(n.code,{children:"null"}),".\nAs a result, this would remove the need for manual configuration like Apollo Client's ",(0,i.jsxs)(n.a,{href:"https://www.apollographql.com/docs/react/caching/cache-configuration#customizing-cache-ids",children:[(0,i.jsx)(n.code,{children:"keyFields"})," type policies"]})," or urqls's ",(0,i.jsx)(n.a,{href:"https://nearform.com/open-source/urql/docs/graphcache/normalized-caching/#custom-keys-and-non-keyable-entities",children:"Custom Keys"}),", which are currently needed to tell the client which fields to use for identifying an object.\nThese configurations are often a source of bugs, since they can be forgotten or misconfigured, or simply may not keep up with an evolving schema."]}),"\n",(0,i.jsxs)(n.h3,{id:"intoduction-of-an-__entity-interface",children:["Intoduction of an ",(0,i.jsx)(n.code,{children:"__Entity"})," interface"]}),"\n",(0,i.jsxs)(n.p,{children:["In addition to the ",(0,i.jsx)(n.code,{children:"__id"})," field, this proposal also introduces a new introspection interface ",(0,i.jsx)(n.code,{children:"__Entity"}),", which is defined as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"interface __Entity {\n    __id: ID!\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"This interface could be used by clients with schema knowledge (such as Apollo Kotlin or Apollo iOS) at build time to decide if a certain type can be uniquely identified (and thus, stored in a normalized way) or not."}),"\n",(0,i.jsxs)(n.p,{children:["This interface may be implicitly added to objects that implement a way to resolve the ",(0,i.jsx)(n.code,{children:"__id"})," field to a non-null value, depending on the server implementation.\nAlternatively, implementers might also choose to explicitly add the interface to types that can be uniquely identified."]}),"\n",(0,i.jsx)(n.h3,{id:"presence-of-globally-identifiable-types-in-the-schema",children:"Presence of globally identifiable types in the schema"}),"\n",(0,i.jsxs)(n.p,{children:["To allow clients to detect if a server supports this feature, the value of the ",(0,i.jsx)(n.code,{children:"__id"})," field on the ",(0,i.jsx)(n.code,{children:"Query"})," type should be specified as well:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["If a server does not have any types with a non-null ",(0,i.jsx)(n.code,{children:"__id"})," field, the ",(0,i.jsx)(n.code,{children:"__id"})," field on the ",(0,i.jsx)(n.code,{children:"Query"})," type should return ",(0,i.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["If a server has at least one type with a non-null ",(0,i.jsx)(n.code,{children:"__id"})," field, the ",(0,i.jsx)(n.code,{children:"__id"})," field on the ",(0,i.jsx)(n.code,{children:"Query"})," type should return a non-null value (the suggestion would be ",(0,i.jsx)(n.code,{children:'"ROOT_QUERY"'}),", if we are to specify the exact value)."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["This could be used by clients to detect if the server supports the feature at all, and if it doesn't, they could choose to omit querying for the ",(0,i.jsx)(n.code,{children:"__id"})," field in future requests to save bandwidth."]}),"\n",(0,i.jsx)(n.h2,{id:"suggested-spec-addition",children:"Suggested Spec addition"}),"\n",(0,i.jsxs)(n.p,{children:['To be inserted after the "Type Name Introspection" section in ',(0,i.jsx)(n.code,{children:"spec/Section 4 -- Introspection.md"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-md",children:"## Object Identification\n\nGraphQL supports Object Identification via the meta-field `__id: ID` on any \nObject, Interface, or Union.\n\nThis field returns:\n* `null`, if the object does not have a unique identifier in the context of its \ntype, or if the schema doesn't support Object Identification in general.\n* a non-null ID that in combination with the object's type name is globally unique.\n\nFor every type, `__id` must either always return `null` or never return `null`.\n\nAs a meta-field, `__id` is implicit and does not appear in the fields list in\nany defined type.\n\nThe value of `__id` on the `Query` type is defined to either be `ROOT_QUERY` if \nthe schema supports Object Identification, or `null` if it does not. This guarantee \ncan be used to introspect whether a schema supports Object Identification in general.\n\nNote: `__id` may not be included as a root field in a subscription operation.\n\n## Identifiable types\n\nIdentifiable types may also implement the `__Entity` interface, which is defined as follows:\n\n```graphql\ninterface __Entity {\n    __id: ID!\n}\n```\n\nA server might choose to implicitly add this interface to types that implement a way to resolve the `__id` field to a non-null value.\n"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>l});var i=t(7294);const o={},s=i.createContext(o);function l(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);