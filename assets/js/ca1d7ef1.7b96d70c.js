"use strict";(self.webpackChunk_localrepo_benjie_dev=self.webpackChunk_localrepo_benjie_dev||[]).push([[1566],{4726:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>l,toc:()=>h});var r=n(5893),i=n(1151);const s={identifier:"wg857",title:"Fragment Modularity",stage:"0",champion:"mjmahone",wgDiscussionUrl:"https://github.com/graphql/graphql-wg/discussions/857",events:[{type:"wgDiscussionCreated",date:new Date("2022-01-07T15:29:59.000Z"),href:"https://github.com/graphql/graphql-wg/discussions/857",actor:"mjmahone"}],related:"895, FragmentModularity",shortname:"Fragment Modularity",image:"/img/rfc_tracker.png"},a=void 0,l={id:"wg857",title:"Fragment Modularity",description:"At a glance",source:"@site/rfcs/wg857.md",sourceDirName:".",slug:"/wg857",permalink:"/rfcs/wg857",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{identifier:"wg857",title:"Fragment Modularity",stage:"0",champion:"mjmahone",wgDiscussionUrl:"https://github.com/graphql/graphql-wg/discussions/857",events:[{type:"wgDiscussionCreated",date:"2022-01-07T15:29:59.000Z",href:"https://github.com/graphql/graphql-wg/discussions/857",actor:"mjmahone"}],related:"895, FragmentModularity",shortname:"Fragment Modularity",image:"/img/rfc_tracker.png"},sidebar:"rfcsSidebar",previous:{title:"New Intersection Type",permalink:"/rfcs/wg944"},next:{title:"Fragment Modularity",permalink:"/rfcs/FragmentModularity"}},o={},h=[{value:"At a glance",id:"at-a-glance",level:2},{value:"Timeline",id:"timeline",level:2}];function c(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"at-a-glance",children:"At a glance"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Identifier"}),": wg#857"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Stage"}),": ",(0,r.jsx)(t.a,{href:"https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md#stage-0-strawman",children:"RFC0: Strawman"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Champion"}),": ",(0,r.jsx)(t.a,{href:"https://github.com/mjmahone",children:"@mjmahone"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"PR"}),": -"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Related"}),":","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"/rfcs/895",title:"Client Controlled Nullability / RFCX",children:"#895"})," (Client Controlled Nullability)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"/rfcs/FragmentModularity",title:"Fragment Modularity / RFC0",children:"FragmentModularity"})," (Fragment Modularity)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"timeline",children:"Timeline"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsxs)(t.strong,{children:[(0,r.jsx)(t.a,{href:"https://github.com/graphql/graphql-wg/discussions/857",children:"WG discussion"})," created"]})," on 2022-01-07 by mjmahone"]}),"\n"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:["See This RFC for more details: ",(0,r.jsx)(t.a,{href:"https://github.com/graphql/graphql-wg/blob/main/rfcs/FragmentModularity.md",children:"https://github.com/graphql/graphql-wg/blob/main/rfcs/FragmentModularity.md"})]}),"\n",(0,r.jsxs)(t.p,{children:["In an ideal world, fragments would be ",(0,r.jsx)(t.em,{children:"so modular"})," that our validation rules would be inductive: if Query Q depends on Fragment B and C, then so long as we know fragments B and C are valid, and we run validation on Q against B and C's type declarations (i.e. just the ",(0,r.jsx)(t.code,{children:"fragment B on Foo"})," portion of the fragment definition, the stuff before the selection set brackets ",(0,r.jsx)(t.code,{children:"{ ... }"}),"), then we know Q is valid."]}),"\n",(0,r.jsxs)(t.p,{children:["I'm hoping this discussion helps us clarify the work required to set us in that direction, and makes sure related projects, like ",(0,r.jsx)(t.a,{href:"https://github.com/graphql/graphql-spec/pull/895",children:"Client Controlled Nullability"}),", are at least compatible with this evolution."]}),"\n",(0,r.jsx)(t.p,{children:'Currently I see three different "solution spaces" for addressing this problem:'}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Adding a ",(0,r.jsx)(t.a,{href:"https://github.com/graphql/graphql-wg/blob/main/rfcs/FragmentModularity.md#solution-space-modularity-via-fragment-response-keys",children:"new syntax"})," to have fragment names as keys in our existing tree-shaped responses."]}),"\n",(0,r.jsxs)(t.li,{children:["Creating an ",(0,r.jsx)(t.a,{href:"https://github.com/graphql/graphql-wg/blob/main/rfcs/FragmentModularity.md#solution-space-new-response-format",children:"alternative response format"})," that would bring the cost of including fragment information down"]}),"\n",(0,r.jsxs)(t.li,{children:["Adding ",(0,r.jsx)(t.a,{href:"https://github.com/graphql/graphql-wg/blob/main/rfcs/FragmentModularity.md#solution-space-modularity-via-metadata",children:"metadata to allow clients to know which fragments are fulfilled"})]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["Personally, I'm of the opinion that the metadata approach is a cudgel: it might give clients some hooks to help solve client-specific problems, but doesn't give us a clear path towards solving other, related problems like Error Boundaries. So I'm more focused on the other two paths: my favored approach would be one where you could safely opt-in to ",(0,r.jsx)(t.em,{children:"everything"})," being modular."]}),"\n",(0,r.jsx)(t.p,{children:"To get the discussion started, cc @josephsavona @captbaritone @hwillson @twof who have all explicitly expressed interest in this area."}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>l,a:()=>a});var r=n(7294);const i={},s=r.createContext(i);function a(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);