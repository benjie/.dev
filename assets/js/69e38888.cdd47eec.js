"use strict";(self.webpackChunk_localrepo_benjie_dev=self.webpackChunk_localrepo_benjie_dev||[]).push([[4742],{4013:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var t=i(5893),a=i(1151);const s={identifier:"ImplicitInheritance",stage:"0",title:"Implicit Inheritance",events:[{type:"docUpdated",date:new Date("2021-09-03T19:00:14.000Z"),href:"https://github.com/graphql/graphql-wg/blob/06122e6774b9c4237513187068f46be6fa67a26e/rfcs/ImplicitInheritance.md",actor:"Lee Byron"},{type:"docCreated",date:new Date("2021-09-02T21:37:06.000Z"),href:"https://github.com/graphql/graphql-wg/blob/7bd64884c6ec08547d810d3b2ade4fae2c01764d/rfcs/ImplicitInheritance.md",actor:"Tobias Diez"}],related:"500, 533",shortname:"Implicit Inheritance",image:"/img/rfc_tracker.png"},r=void 0,l={id:"ImplicitInheritance",title:"Implicit Inheritance",description:"At a glance",source:"@site/rfcs/ImplicitInheritance.md",sourceDirName:".",slug:"/ImplicitInheritance",permalink:"/rfcs/ImplicitInheritance",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{identifier:"ImplicitInheritance",stage:"0",title:"Implicit Inheritance",events:[{type:"docUpdated",date:"2021-09-03T19:00:14.000Z",href:"https://github.com/graphql/graphql-wg/blob/06122e6774b9c4237513187068f46be6fa67a26e/rfcs/ImplicitInheritance.md",actor:"Lee Byron"},{type:"docCreated",date:"2021-09-02T21:37:06.000Z",href:"https://github.com/graphql/graphql-wg/blob/7bd64884c6ec08547d810d3b2ade4fae2c01764d/rfcs/ImplicitInheritance.md",actor:"Tobias Diez"}],related:"500, 533",shortname:"Implicit Inheritance",image:"/img/rfc_tracker.png"},sidebar:"rfcsSidebar",previous:{title:"Nested GraphQL Mutations",permalink:"/rfcs/wg815"},next:{title:"Operation Expressions",permalink:"/rfcs/OperationExpressions"}},o={},c=[{value:"At a glance",id:"at-a-glance",level:2},{value:"Timeline",id:"timeline",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Proposed Solution",id:"proposed-solution",level:2},{value:"Advantages",id:"advantages",level:2},{value:"Disadvantages",id:"disadvantages",level:2},{value:"Evaluation against guiding principles",id:"evaluation-against-guiding-principles",level:2},{value:"Other relevant points, often mentioned in this context",id:"other-relevant-points-often-mentioned-in-this-context",level:2},{value:"Alternatives",id:"alternatives",level:2}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"at-a-glance",children:"At a glance"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Identifier"}),": ImplicitInheritance"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Stage"}),": ",(0,t.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md#stage-0-strawman",children:"RFC0: Strawman"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Champion"}),": -"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"PR"}),": -"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"timeline",children:"Timeline"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/06122e6774b9c4237513187068f46be6fa67a26e/rfcs/ImplicitInheritance.md",children:"RFC document updated"})})," on 2021-09-03 by Lee Byron"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/7bd64884c6ec08547d810d3b2ade4fae2c01764d/rfcs/ImplicitInheritance.md",children:"RFC document created"})})," on 2021-09-02 by Tobias Diez"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.h1,{id:"rfc-implicit-inheritance",children:"RFC: Implicit Inheritance"}),"\n",(0,t.jsx)(n.p,{children:"Related issues:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/issues/533",children:"graphql-spec: Proposal: Implicitly include properties of implemented interfaces"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/issues/500",children:'graphql-spec: [Proposal] Interface implementation violate "Don\'t Repeat Yourself"'})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/graphql/graphql-js/issues/703",children:"graphql-js: Thought: avoiding self-repitition when a schema is defined as a string"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,t.jsx)(n.p,{children:"Currently, when defining an interface that implements another interface, the implementing interface must define each field that is specified by the implemented interface.\nIf an interface contains more than a few properties and is used in multiple places, one ends up with a very significant amount of repetition of the same field definitions.\nThis becomes particularly apparent if you have deeper hierarchies of interfaces since fields are repeated on each level.\nThe following schema exhibits this exemplarily."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",children:"interface Vehicle {\n  id: ID!\n  make: VehicleMake\n  wheelCount: Int\n  acceleration: Float\n  topSpeed: Float\n  mass: Float\n}\n\ninterface Automobile implements Vehicle {\n  id: ID!\n  make: AutoMake\n  wheelCount: Int\n  acceleration: Float\n  topSpeed: Float\n  mass: Float\n  engineCylinders: Int\n  engineSize: Float\n}\n\ninterface AutomobileForPersonTransfer implements Automobile {\n  id: ID!\n  make: AutoMake\n  wheelCount: Int\n  acceleration: Float\n  topSpeed: Float\n  mass: Float\n  engineCylinders: Int\n  engineSize: Float\n  capacity: Int\n}\n\ntype Bicycle implements Vehicle {\n  id: ID!\n  make: BicycleMake #\n  wheelCount: Int\n  acceleration: Float\n  topSpeed: Float\n  mass: Float\n  capacity: Int\n  gearCount: Int\n}\n\ntype Car implements Vehicle & Automobile & AutomobileForPersonTransfer {\n  id: ID!\n  make: CarMake\n  wheelCount: Int\n  acceleration: Float\n  topSpeed: Float\n  mass: Float\n  capacity: Int\n  engineCylinders: Int\n  engineSize: Float\n  trunkSize: Float\n}\n\ntype Motorcycle implements Vehicle & Automobile & AutomobileForPersonTransfer {\n  id: ID!\n  make: MotorcycleMake\n  class: MotorcycleClass\n  wheelCount: Int\n  acceleration: Float\n  topSpeed: SmallFloat\n  mass: Float\n  capacity: Int\n  engineCylinders: Int\n  engineSize: Float\n}\n\ntype Truck implements Vehicle & Automobile {\n  id: ID!\n  make: TruckMake\n  wheelCount: Int\n  acceleration: Float\n  topSpeed: Float\n  mass: Float\n  engineCylinders: Int\n  engineSize: Float\n  maxLoad: Float\n}\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"The problems with the current behavior are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The DRY-principle is violated, resulting in well-known issues regarding maintainability and scalability.\nThis becomes especially apparent if the fields are documented using comments, which need to be repeated and then maintained as well.\nWhile there is good support for compile-checking that fields are indeed repeated in the inheriting type, something like this is not possible for the documentation because differences might be intentional."}),"\n",(0,t.jsx)(n.li,{children:"If a field in an implementing type differs from the field in the interface, it is not clear if that is due to carelessness/omission or if it is an intended overwrite.\nThe same applies to differences in documentation."}),"\n",(0,t.jsxs)(n.li,{children:["It is hard to recognize changes or overwrites (e.g. ",(0,t.jsx)(n.code,{children:"topSpeed: SmallFloat"})," in ",(0,t.jsx)(n.code,{children:"Motorcycle"})," doesn't stick out)."]}),"\n",(0,t.jsx)(n.li,{children:"Changes to a root interface require\u200b multiple repetitive changes in the implementing interfaces and types."}),"\n",(0,t.jsx)(n.li,{children:'Since there is no indication that a field is inherited, readers who are already aware of the interface fields don\'t know what to "skip" when reading other types, so they waste time.'}),"\n",(0,t.jsx)(n.li,{children:"The schema is longer due to the repetition, which makes reading the schema more intimidating and leads to skimming in place of actual reading."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"proposed-solution",children:"Proposed Solution"}),"\n",(0,t.jsxs)(n.p,{children:["This RFC proposes that interface fields may be automatically inherited if they are not explicitly repeated in the implementing type.\nEssentially, the proposal is to change ",(0,t.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/blame/main/spec/Section%203%20--%20Type%20System.md#L890-L891",children:"L890-L891"})," in ",(0,t.jsx)(n.code,{children:"IsValidImplementation(type, implementedType)"})," from"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"type must include a field of the same name for every field defined in implementedType."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"to"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"type may include a field of the same name for every field defined in implementedType."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Thus, types are no longer required to enumerate all fields from all implemented types, and missing fields are automatically copied into the type.\nOne can still specify a field in the implementing type, for example, narrow down the field's return type.\nFor backwards compatibility and to include different preferences, it is still possible to specify exactly the same field in an implementing type so that existing schema are still valid."}),"\n",(0,t.jsx)(n.p,{children:"With these changes, the above example may be written as follows."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",children:"interface Vehicle {\n  id: ID!\n  make: VehicleMake\n  wheelCount: Int\n  acceleration: Float\n  topSpeed: Float\n  mass: Float\n}\n\ninterface Automobile implements Vehicle {\n  engineCylinders: Int\n  engineSize: Float\n}\n\ninterface AutomobileForPersonTransfer implements Automobile {\n  capacity: Int\n}\n\ntype Bicycle implements Vehicle {\n  make: BicycleMake # We can still overwrite fields if needed\n  wheelCount: Int # Or repeat them 1:1, if preferred\n  capacity: Int\n  gearCount: Int\n}\n\ntype Car implements AutomobileForPersonTransfer {\n  make: CarMake\n  trunkSize: Float\n}\n\ntype Motorcycle implements AutomobileForPersonTransfer {\n  make: MotorcycleMake\n  topSpeed: SmallFloat\n  class: MotorcycleClass\n}\n\ntype Truck implements Automobile {\n  make: TruckMake\n  maxLoad: Float\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"advantages",children:"Advantages"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Fields that changed or that are new are highlighted and stand out, which makes reading and understanding the schema easier."}),"\n",(0,t.jsx)(n.li,{children:"No repetition in the definition of the fields."}),"\n",(0,t.jsx)(n.li,{children:"The schema is easier to scale and maintain.\nIn particular, addition of new types implementing multiple interfaces is easier and doesn't involve copy & paste."}),"\n",(0,t.jsx)(n.li,{children:"Changes to interface stay mostly local to that interface.\nThat is, addition or change of a field in an interface for the most part doesn't require\u200b changes in the implementing types."}),"\n",(0,t.jsxs)(n.li,{children:["Interfaces can be used as a kind of ",(0,t.jsx)(n.code,{children:"fragment"})," on the schema-side by extracting common structures and making them easy to reuse."]}),"\n",(0,t.jsx)(n.li,{children:"Shorter schema, which require\u200b less writing and are easier to skim/read."}),"\n",(0,t.jsxs)(n.li,{children:["Aligns with the handling of interfaces in other object-oriented languages such as TypeScript and with, e.g., the documentation of the Github GraphQL API which doesn't include inherited fields, see ",(0,t.jsx)(n.a,{href:"https://docs.github.com/en/graphql/reference/objects#issue",children:"for example"}),".\nFollowing established conventions leads to an easier knowledge transfer.\nMoreover, it also aligns the way the schema is defined with other alternatives to SDL like ",(0,t.jsx)(n.a,{href:"https://typegraphql.com/",children:"TypeGraphQL"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"disadvantages",children:"Disadvantages"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"It is no longer possible to immediately see all fields that are provided by a type (without traversing the inheritance hierarchy), which makes reading the schema more challenging in some aspects."}),"\n",(0,t.jsx)(n.li,{children:"If a type inherits multiple interfaces that declare a field with different but compatible types, the resulting type is not immediately clear."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"It should be noted that these disadvantages can mostly be mitigated using tools or IDE integrations that can easily determine all fields on the fly."}),"\n",(0,t.jsxs)(n.h2,{id:"evaluation-against-guiding-principles",children:["Evaluation against ",(0,t.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md#guiding-principles",children:"guiding principles"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Backwards compatibility: \u2705"}),"\n",(0,t.jsx)(n.p,{children:"Existing queries and schema are still valid."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Performance is a feature: \u2705\u26a0\ufe0f"}),"\n",(0,t.jsx)(n.p,{children:"There are no runtime issues, as schema are usually not used at runtime.\nDuring compilation or schema parsing, there is a small additional overhead since one needs to traverse the inheritance hierarchy to determine all fields of a type.\nThis cost is of the order of the existing check that all fields from interfaces are indeed repeated, which is no longer necessary.\nThus there shouldn't be any noticeable negative performance impact."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Favor no change: \u2705"}),"\n",(0,t.jsx)(n.p,{children:"The proposed changes are very minimal and do not require\u200b any new keywords or changes in parsing."}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Editor's rebuttal"})}),"\n",(0,t.jsx)(n.p,{children:"\u26a0\ufe0f Introduced changes imply high ecosystem cost and thus must meet a high bar of added value. It is the editor's opinion that at best low value is achieved, and potentially negative value for maintenance cost."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Enable new capabilities motivated by real use cases: \u2705"}),"\n",(0,t.jsx)(n.p,{children:"Maintainability and scalability of the schema are improved."}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Editor's rebuttal"})}),"\n",(0,t.jsx)(n.p,{children:"\u26a0\ufe0f There are no new advancements to expressiveness of the schema nor query capabilities by this proposal, only a more terse syntax for existing capabilities."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Simplicity and consistency over expressiveness and terseness: \u2705"}),"\n",(0,t.jsx)(n.p,{children:"The schema simplifies considerably, and the new behavior is consistent with other established object-oriented programming languages.\nOn the other hand, the existing behavior is more expressive."}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Editor's rebuttal"})}),"\n",(0,t.jsx)(n.p,{children:"\u26a0\ufe0f This proposal is an advocation of terseness at the expense of simplicity. It is simpler for a type definition to be locally defined, inherting field definitions is new complicating behavior introducing potential problems like inheritance conflicts."}),"\n",(0,t.jsxs)(n.p,{children:["This behavior is not consistent with most object-oriented languages which may be a surprise to users. Nearly all OOP languages require\u200b a type that declares it implements an interface to provide that implementation. See ",(0,t.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgJLIN4FgBQz-IzAQA2AJgFzIDOYUoA5rgL664IlzXXIDCywALYAHEhEERwPdNjwEA9POQA5APaRkYABbAeYAJ7CUwqKrIBXJDzghk0U1AA0AsMjKqIPEOoEgt0YFdAgHIeUEhYRAhQwmJyagA6FlwgA",children:"TypeScript example"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Preserve option value: \u2705"}),"\n",(0,t.jsx)(n.p,{children:"Since the proposed changes are essentially a relaxation of limits of the current rules (must => may), it opens more options now and in the future."}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Editor's rebuttal"})}),"\n",(0,t.jsx)(n.p,{children:"\u26a0\ufe0f Option value is lost when constraints are relaxed."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Understandability is just as important as correctness: \u2705"}),"\n",(0,t.jsx)(n.p,{children:"The GraphQL spec stay almost unchanged by the proposed changes (must => may)."}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Editor's rebuttal"})}),"\n",(0,t.jsx)(n.p,{children:"\u26a0\ufe0f This proposal would make type definitions harder to understand for a reader. Currently any type is fully locally defined: a reader can see exactly what fields are available and what types they return directly. After this proposal a reader would need to manually traverse through interface heirarchies to gather this same information."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"other-relevant-points-often-mentioned-in-this-context",children:"Other relevant points, often mentioned in this context"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"An interesting difference of the two approaches is if a field is removed from an interface."}),"\n",(0,t.jsx)(n.p,{children:"In the current implementation, one needs to manually go through each implementing type to remove the field there as well after double-checking.\nOn the other hand, if fields are automatically inherited, one needs to manually go through each implementing type to readd the field if necessary."}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Editor's rebuttal"})}),"\n",(0,t.jsx)(n.p,{children:"In the current implementation, removing a field from an interface (note: a potentially breaking schema change) requires no downstream changes if those types still implement that field and limits the breaking change. However after this proposal if a field was removed from an interface then the breaking change would cascade across all implemented types."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'A common argument against the automatic inheritance is the principle "Favor reading over writing".'}),"\n",(0,t.jsx)(n.p,{children:"With the rising popularity of schema explorer such as GraphiQL, GraphQL Playground or Apollo Studio Explorer, it may be argued that developers mainly use the SDL to write the schema and consume it via other ways.\nThis, depends strongly on the preference of the team and which kind of tools are used.\nThe proposed changes give teams the possibility to choose which option is best for them and then enforce this decision, for example, using build tools such as eslint."}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Editor's rebuttal"})}),"\n",(0,t.jsx)(n.p,{children:"Even among hand-edited schema files (or any other code) it is likely to be read far more than written over time. Long-term code maintainability is improved via explicitness and optimizing for readability over writability."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"alternatives",children:"Alternatives"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use a new keyword such as ",(0,t.jsx)(n.code,{children:"extends"})," to signal that fields should be automatically inherited."]}),"\n",(0,t.jsxs)(n.li,{children:["Post-process a schema to automatically add fields that are not repeated.\nSuch an approach is taken by ",(0,t.jsx)(n.a,{href:"https://github.com/Sydsvenskan/node-graphql-partials",children:"node-graphql-partials"}),", using new concepts ",(0,t.jsx)(n.code,{children:"partial"})," (similar to ",(0,t.jsx)(n.code,{children:"interface"}),") and ",(0,t.jsx)(n.code,{children:"using"})," (similar to ",(0,t.jsx)(n.code,{children:"implements"}),")."]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>l,a:()=>r});var t=i(7294);const a={},s=t.createContext(a);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);