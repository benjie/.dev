"use strict";(self.webpackChunk_localrepo_benjie_dev=self.webpackChunk_localrepo_benjie_dev||[]).push([[551],{704:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var i=t(5893),o=t(1151);const a={identifier:"AnnotationStructs",stage:"0",title:"Annotation Structs",events:[{type:"docUpdated",date:new Date("2022-08-31T08:45:25.000Z"),href:"https://github.com/graphql/graphql-wg/blob/b7c9e683ea40b776dceb560bac46b7937cdcbeac/rfcs/AnnotationStructs.md",actor:"Benjie"},{type:"docCreated",date:new Date("2022-08-16T09:36:49.000Z"),href:"https://github.com/graphql/graphql-wg/blob/6883f460ae07a954e5c9cc240bb280733e2a184b/rfcs/AnnotationStructs.md",actor:"Benjie"}],related:"300, wg1096",shortname:"Annotation Structs",image:"/img/rfc_tracker.png"},r=void 0,s={id:"AnnotationStructs",title:"Annotation Structs",description:"At a glance",source:"@site/rfcs/AnnotationStructs.md",sourceDirName:".",slug:"/AnnotationStructs",permalink:"/rfcs/AnnotationStructs",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{identifier:"AnnotationStructs",stage:"0",title:"Annotation Structs",events:[{type:"docUpdated",date:"2022-08-31T08:45:25.000Z",href:"https://github.com/graphql/graphql-wg/blob/b7c9e683ea40b776dceb560bac46b7937cdcbeac/rfcs/AnnotationStructs.md",actor:"Benjie"},{type:"docCreated",date:"2022-08-16T09:36:49.000Z",href:"https://github.com/graphql/graphql-wg/blob/6883f460ae07a954e5c9cc240bb280733e2a184b/rfcs/AnnotationStructs.md",actor:"Benjie"}],related:"300, wg1096",shortname:"Annotation Structs",image:"/img/rfc_tracker.png"},sidebar:"rfcsSidebar",previous:{title:"Expanding Subtyping (for output types)",permalink:"/rfcs/ExpandingSubtyping"},next:{title:"Metadata Structs",permalink:"/rfcs/MetadataStructs"}},l={},c=[{value:"At a glance",id:"at-a-glance",level:2},{value:"Timeline",id:"timeline",level:2},{value:"Problems",id:"problems",level:2},{value:"Granularity",id:"granularity",level:3},{value:"Solution",id:"solution",level:2},{value:"SDL",id:"sdl",level:3},{value:"Introspection",id:"introspection",level:3}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"at-a-glance",children:"At a glance"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Identifier"}),": AnnotationStructs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stage"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md#stage-0-strawman",children:"RFC0: Strawman"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Champion"}),": -"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"PR"}),": -"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Related"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/rfcs/wg1096",title:'"Metadata Directives" Proposal / RFC0',children:"wg#1096"}),' ("Metadata Directives" Proposal)']}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"timeline",children:"Timeline"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/b7c9e683ea40b776dceb560bac46b7937cdcbeac/rfcs/AnnotationStructs.md",children:"RFC document updated"})})," on 2022-08-31 by Benjie"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/6883f460ae07a954e5c9cc240bb280733e2a184b/rfcs/AnnotationStructs.md",children:"RFC document created"})})," on 2022-08-16 by Benjie"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.h1,{id:"annotation-structs",children:"Annotation Structs"}),"\n",(0,i.jsx)(n.p,{children:"Schema annotations has long been desired, please see this long discussion:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/issues/300",children:"https://github.com/graphql/graphql-spec/issues/300"})}),"\n",(0,i.jsx)(n.p,{children:"I digested many of the currently proposed (and in the wild) solutions to this\nproblem in my talk at the GraphQL Conference, you can see the talk here:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://youtu.be/c1oa7p73rTw",children:"https://youtu.be/c1oa7p73rTw"})}),"\n",(0,i.jsx)(n.p,{children:"It covers:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"custom introspection extensions"}),"\n",(0,i.jsx)(n.li,{children:"'SDL' field in schema, like Apollo Federation"}),"\n",(0,i.jsx)(n.li,{children:"storing metadata in the description field"}),"\n",(0,i.jsx)(n.li,{children:"adding metadata entirely in user-space"}),"\n",(0,i.jsx)(n.li,{children:"'applied directives'"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:'It expands on the pros and cons of these approaches and asks "is there a better\nsolution".'}),"\n",(0,i.jsx)(n.p,{children:'Note that this topic has historically been referred to as "schema metadata", but\nupon discussion with other WG members it has become clear that "annotations" is\na better term - we\'re annotating the types/fields/arguments/etc rather than the\ndata.'}),"\n",(0,i.jsx)(n.h2,{id:"problems",children:"Problems"}),"\n",(0,i.jsx)(n.p,{children:"Some of the main problems that need to be solved with schema annotations are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"representing all desired annotations (including polymorphic annotations)"}),"\n",(0,i.jsx)(n.li,{children:"the need for granularity (partial introspection)"}),"\n",(0,i.jsx)(n.li,{children:"the need for support in tooling (e.g. GraphiQL) to give visibility into the\nannotations"}),"\n",(0,i.jsx)(n.li,{children:"being able to fully introspect the GraphQL schema in a small number of\nroundtrips"}),"\n",(0,i.jsx)(n.li,{children:"avoiding the need for complex parsing on the client"}),"\n",(0,i.jsx)(n.li,{children:"allowing for future expansion of the annotations/introspection schema (without\nnamespace clashes)"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"granularity",children:"Granularity"}),"\n",(0,i.jsx)(n.p,{children:"It can be useful for clients to include small introspection queries as part of\ntheir applications - for example you might introspect a particular named enum to\nmake available sorting options in a dropdown. If the schema adds support for a\nnew sort method, the client could add this option to the dropdown without\nneeding to be updated thanks to introspection. However, enum values don't\ncurrently contain enough information for this."}),"\n",(0,i.jsx)(n.p,{children:'Consider that we add a "label" property to the annotations for each enum value -\nthen we would have all we need to display it to the user, so long as they spoke\nthat language. To cater to an international audience, we could add many\ntranslations to each enum value - but now the size of the introspection has\ngrown. A better solution might be to allow the client to select just the\ntranslation that it needs from the enum value. (We also don\'t need any of the\nother annotations for the enum values, only the labels.)'}),"\n",(0,i.jsx)(n.p,{children:"Here's a few slides about other (significantly more desirable) capabilities\ngranular annotations could enable:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://docs.google.com/presentation/d/1e6o2kd3fVc_DQH1O8RxJo-idZM0kTOx-q322coNeIIo/present",children:"https://docs.google.com/presentation/d/1e6o2kd3fVc_DQH1O8RxJo-idZM0kTOx-q322coNeIIo/present"})}),"\n",(0,i.jsx)(n.h2,{id:"solution",children:"Solution"}),"\n",(0,i.jsxs)(n.p,{children:["This RFC proposes what I feel is a more capable and elegant solution than any of\nthe previously proposed solutions covered by my talk, but it's predicated on the\nexistence of a polymorphic-capable composite type that can be used symmetrically\nfor both input and output. As it happens there's ",(0,i.jsx)(n.a,{href:"/rfcs/Struct",children:"an RFC for that"}),",\nso you can see this annotations RFC as an extension of that Struct RFC."]}),"\n",(0,i.jsxs)(n.p,{children:["Note that though we use the keyword ",(0,i.jsx)(n.code,{children:"struct"})," to indicate this type, really we're\njust extending the ",(0,i.jsx)(n.code,{children:"input"})," object type to be available on output too, so you can\nreplace the keyword ",(0,i.jsx)(n.code,{children:"struct"})," with ",(0,i.jsx)(n.code,{children:"input"})," if you prefer."]}),"\n",(0,i.jsx)(n.h3,{id:"sdl",children:"SDL"}),"\n",(0,i.jsxs)(n.p,{children:["We could introduce annotations as a separate keyword (e.g.\n",(0,i.jsx)(n.code,{children:"annotation +source(table: String, column: String, service: ServiceSource) on OBJECT | FIELD_DEFINITION"}),"),\nhowever the WG seem generally in favour of using directives to represent\nannotations, so we'll show how to power\n",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/discussions/1096",children:"Lee's Metadata Directives proposal"}),"\nsyntax with structs. I've taken the liberty of replacing the keyword ",(0,i.jsx)(n.code,{children:"metadata"}),"\nwith ",(0,i.jsx)(n.code,{children:"annotation"}),", but it's otherwise equivalent."]}),"\n",(0,i.jsx)(n.p,{children:"Here's an example schema a user might define:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'directive @source(table: String, column: String, service: ServiceSource) annotation on OBJECT | FIELD_DEFINITION\ndirective @visibility(only: [VisibilityScope!]!) annotation on OBJECT\ndirective @label(en: String, fr: String, de: String) annotation on ENUM_VALUE\n\nstruct ServiceSource {\n  serviceName: string\n  identifier: string\n}\n\nenum VisibilityScope {\n  NONE\n  PERSONAL\n  TEAM\n  ORGANIZATION\n  ADMINS\n  PUBLIC @label(en: "Everyone", fr: "Tout les monde", de: "Alle")\n}\n\ntype User\n  @source(table: "public.users")\n  @visibility(only: [ORGANIZATION])\n{\n  id: ID!\n  # Omitted for brevity:\n  # organization: Organization!\n  username: String! @source(column: "handle")\n  avatar: String! @source(service: {\n    serviceName: "S3"\n    identifier: "/avatars/27.png"\n  })\n}\n\ntype Query {\n  me: User\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"introspection",children:"Introspection"}),"\n",(0,i.jsx)(n.p,{children:"Introspection query example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'{\n  User: __type(name: "User") {\n    annotations\n    # Or:\n    annotations {\n      __typename\n      ... on __Annotation_source {\n        table\n      }\n      ... on __Annotation_visibility {\n        only\n      }\n    }\n  }\n  VisibilityScope: __type(name: "VisibilityScope") {\n    enumValues {\n      name\n      # Only show me the \'label\' directives, and only the \'en\' argument of those:\n      annotations(directiveNames: ["label"]) {\n        ... on __Annotation_label {\n          en\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Changes to the schema introspection types:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"# Each annotation directive will have a struct implicitly defined for it, named\n# `__Annotation_${directiveName}` with a field for each argument the directive\n# accepts. The type of these fields will be the same as the type of the\n# directive arguments.\n\n# The struct for the `@source(table: String, column: String, service: ServiceSource)` annotation directive:\nstruct __Annotation_source {\n  table: String\n  column: String\n  service: ServiceSource\n}\n\n# The struct for the `@visibility(only: [VisibilityScope!]!)` annotation directive:\nstruct __Annotation_visibility {\n  only: [VisibilityScope!]!\n}\n\n# The struct for the `@label(en: String, fr: String, de: String)` annotation directive:\nstruct __Annotation_label {\n  en: String\n  fr: String\n  de: String\n}\n\n# Each of the introspection entrypoints will have an `annotations` field added,\n# which will return a list of struct-unions of the directives that were applied\n# in those locations in order. The field can optionally accept a list of\n# directives you're interested in to allow for more granular metadata selection.\n\ntype __Type {\n  # ...\n  annotations(directiveNames: [String!]): [__TypeAnnotation]\n}\ntype __Field {\n  # ...\n  annotations(directiveNames: [String!]): [__FieldAnnotation]\n}\ntype __EnumValue {\n  # ...\n  annotations(directiveNames: [String!]): [__EnumValueAnnotation]\n}\n# etc\n\n# For `__TypeAnnotation` we get a struct-union representing all annotation\n# directives that are valid on a GraphQL type (`OBJECT`, `INPUT_OBJECT`,\n# `UNION`, `INTERFACE`, `SCALAR`, `ENUM`). There are two directives\n# (`@source` and `@visibility`) that are available on at least one of these\n# locations:\nunion __TypeAnnotation =\n  | __Annotation_source\n  | __Annotation_visibility\n"})}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>s,a:()=>r});var i=t(7294);const o={},a=i.createContext(o);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);