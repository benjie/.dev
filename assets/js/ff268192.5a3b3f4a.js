"use strict";(self.webpackChunk_localrepo_benjie_dev=self.webpackChunk_localrepo_benjie_dev||[]).push([[1372],{4826:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var a=t(5893),s=t(1151);const r={identifier:"FragmentModularity",stage:"0",title:"Fragment Modularity",events:[{type:"docCreated",date:new Date("2022-01-06T08:59:59.000Z"),href:"https://github.com/graphql/graphql-wg/blob/d6103434afc3e516240f7b53721eb7b728ca525c/rfcs/FragmentModularity.md",actor:"Matt Mahoney"}],related:"137, 865, 879, 895, ClientControlledNullability, wg857",shortname:"Fragment Modularity",image:"/img/rfc_tracker.png"},i=void 0,o={id:"FragmentModularity",title:"Fragment Modularity",description:"At a glance",source:"@site/rfcs/FragmentModularity.md",sourceDirName:".",slug:"/FragmentModularity",permalink:"/rfcs/FragmentModularity",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{identifier:"FragmentModularity",stage:"0",title:"Fragment Modularity",events:[{type:"docCreated",date:"2022-01-06T08:59:59.000Z",href:"https://github.com/graphql/graphql-wg/blob/d6103434afc3e516240f7b53721eb7b728ca525c/rfcs/FragmentModularity.md",actor:"Matt Mahoney"}],related:"137, 865, 879, 895, ClientControlledNullability, wg857",shortname:"Fragment Modularity",image:"/img/rfc_tracker.png"},sidebar:"rfcsSidebar",previous:{title:"Fragment Modularity",permalink:"/rfcs/wg857"},next:{title:"Nested GraphQL Mutations",permalink:"/rfcs/wg815"}},l={},d=[{value:"At a glance",id:"at-a-glance",level:2},{value:"Timeline",id:"timeline",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Goal",id:"goal",level:2},{value:"Prior Art",id:"prior-art",level:2},{value:"Related Issues",id:"related-issues",level:2},{value:"Solution Space: Modularity via fragment response keys",id:"solution-space-modularity-via-fragment-response-keys",level:2},{value:"Syntax #0: key all fragment \u201cspreads\u201d",id:"syntax-0-key-all-fragment-spreads",level:3},{value:"Syntax #1: aliased spreads <code>Foo: ...Foo</code>",id:"syntax-1-aliased-spreads-foo-foo",level:3},{value:"Syntax #2: aliased object <code>Foo: { ...Foo }</code>",id:"syntax-2-aliased-object-foo--foo-",level:3},{value:"Syntax #3: special syntax instead of <code>...</code>",id:"syntax-3-special-syntax-instead-of-",level:3},{value:"Solution Space: Modularity via metadata",id:"solution-space-modularity-via-metadata",level:2},{value:"Metadata Option 1: Add a field that indicates whether a selection set was fulfilled",id:"metadata-option-1-add-a-field-that-indicates-whether-a-selection-set-was-fulfilled",level:3},{value:"Metadata Option 2: Add information into the response\u2019s <code>extensions</code>",id:"metadata-option-2-add-information-into-the-responses-extensions",level:3},{value:"Solution Space: New Response Format",id:"solution-space-new-response-format",level:2},{value:"Response Format Option 1: Graph Response",id:"response-format-option-1-graph-response",level:3}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"at-a-glance",children:"At a glance"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Identifier"}),": FragmentModularity"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Stage"}),": ",(0,a.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md#stage-0-strawman",children:"RFC0: Strawman"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Champion"}),": -"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"PR"}),": -"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Related"}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/rfcs/865",title:"Fragment Arguments (parameterized fragments) for GraphQL / RFCS",children:"#865"})," (Fragment Arguments (parameterized fragments) for GraphQL)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/rfcs/879",title:"__fulfilled meta field / RFC0",children:"#879"})," (__fulfilled meta field)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/rfcs/895",title:"Client Controlled Nullability / RFCX",children:"#895"})," (Client Controlled Nullability)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/rfcs/ClientControlledNullability",title:"Client Controlled Nullability / RFC0",children:"ClientControlledNullability"})," (Client Controlled Nullability)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/rfcs/wg857",title:"Fragment Modularity / RFC0",children:"wg#857"})," (Fragment Modularity)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"timeline",children:"Timeline"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/d6103434afc3e516240f7b53721eb7b728ca525c/rfcs/FragmentModularity.md",children:"RFC document created"})})," on 2022-01-06 by Matt Mahoney"]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.h1,{id:"rfc-fragment-modularity",children:"RFC: Fragment Modularity"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Proposed by:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://github.com/mjmahone",children:"Matt Mahoney"})," - Facebook"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Contributors:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://github.com/josephsavona",children:"Joe Savona"})," - Facebook"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://github.com/captbaritone",children:"Jordan Eldredge"})," - Facebook"]}),"\n",(0,a.jsx)(n.li,{children:"You?"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["GraphQL was originally designed to support building mobile applications, where for performance reasons applications need to fetch the minimum amount of data needed for a given UI surface and aggregate requests into fewer network requests. In parallel with GraphQL\u2019s evolution, component-oriented UI frameworks (ie React) gained traction, supporting a style in which applications could be broken down into modular, reusable components. GraphQL fragments were a natural way for components to describe their data dependencies in a ",(0,a.jsx)(n.em,{children:"mostly"})," modular and reusable way, and Relay and other GraphQL clients have taken this approach to its logical extreme and use fragments as a fundamental unit in their APIs and architectures."]}),"\n",(0,a.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,a.jsxs)(n.p,{children:["Unfortunately the \u201cfragments are like components but for data\u201d analogy breaks down because \u2014 unlike UI components in typical frameworks \u2014 ",(0,a.jsx)(n.strong,{children:"fragments are not truly reusable or modular"}),". We discuss reusability in other RFCs, but this RFC focuses specifically on fragment\u2019s lack of ",(0,a.jsx)(n.strong,{children:"modularity"}),". The core challenge is that in GraphQL-the-spec, fragments are facades: ",(0,a.jsx)(n.code,{children:"...Foo"})," is no different than having copy-pasted the selections of ",(0,a.jsx)(n.code,{children:"Foo"})," (and its type condition) at the same location. This \u201cspread\u201d or inlining behavior breaks encapsulation of fragments and causes several concrete challenges to designing robust GraphQL clients, and in turn to application developers:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Developers cannot reason about fragments in isolation. Because the results of a fragment are spread/inlined at their usage site, GraphQL requires global validations such as preventing conflicting fields/arguments at a given path in the response. Developers frequently have to come up with arbitrary aliases for fields as a way to avoid accidental collisions with unrelated code \u2014 breaking encapsulation."}),"\n",(0,a.jsx)(n.li,{children:"Similarly, build tools must implement these whole-program validations, making the cost to changes O(codebase) rather than O(changed fragment). Because any change to a fragment could break the no-conflicting-aliases rule, any change to any fragment has to be checked against all the operations that transitively reference that fragment. Developers see this in the form of slower builds and slower tools, and rightfully attribute this as GraphQL introducing friction in their develpment process."}),"\n",(0,a.jsxs)(n.li,{children:["At runtime, code cannot easily inspect query results to determine whether a fragment spread or inline fragment was fulfilled or not (for fragments that may be conditionally fulfilled based on their type). There is also no way to refer to the data for a specific fragment in a response: in a response for ",(0,a.jsx)(n.code,{children:"{a, ...Foo}"})," there is no way for code to reference the value that contains the results for ",(0,a.jsx)(n.code,{children:"Foo"})," other than to point to the entire response value, which happens to also contain ",(0,a.jsx)(n.code,{children:"a"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["For the latter, the best workaround we have found is to inject a meta-field for each fragment spread (ie querying ",(0,a.jsx)(n.code,{children:"__isFragmentName: __typename"})," for each fragment) and then checking the existence of this key in the response. However, this does not provide a clear way to refer to the results of a particular fragment (ie to pass that result to a child UI component) and has limitations with typical type systems when trying to determine which fragments were or were not evaluated."]}),"\n",(0,a.jsx)(n.p,{children:"For example, given the following fragments:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"fragment Foo on Actor {\n  ...Bar\n  ... on HasName {\n    name\n  }\n  id\n}\n\nfragment Bar on HasPhoto {\n  photo { uri }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["There is no obvious way to determine whether the ",(0,a.jsx)(n.code,{children:"...Bar"})," or ",(0,a.jsx)(n.code,{children:"... on HasName"})," selections were evaluated or not. Ideally, developers could do something like ",(0,a.jsx)(n.code,{children:"if (foo.HasName) { let name = foo.HasName.name }"})," or ",(0,a.jsx)(n.code,{children:"if (foo.Bar) { /* render Bar component with foo.Bar */ }"}),", but this is only currently possible if a GraphQL client adds an intermediate API and does not directly match the GraphQL response shape. In other words, clients face an ongoing tension in which accurately modeling GraphQL features such as fragments and type refinements requires abandoning GraphQL\u2019s \u201cwhat you query is what you get\u201d query/response correspondence."]}),"\n",(0,a.jsx)(n.h2,{id:"goal",children:"Goal"}),"\n",(0,a.jsx)(n.p,{children:"Our goal with this proposal is to address fragment modularity and the three main challenges above. Specifically:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"GraphQL should provide a first-class\u200b syntax for using fragments in a modular way, such that developers can reason locally about fragments as they do with UI components. It should be easy to write code such that by design it cannot violate no-conflicting-alias rule."}),"\n",(0,a.jsx)(n.li,{children:"Similarly, build tools should be able to exploit this property to avoid whole-program checks when fragments are spread using the modular syntax."}),"\n",(0,a.jsx)(n.li,{children:"Finally, the new syntax would offer developers a way to easily check which fragments are fulfilled, and refer precisely to the results of a fragment without any unrelated sibling field data."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"prior-art",children:"Prior Art"}),"\n",(0,a.jsx)(n.p,{children:"This is not the first time people have argued that a truly modular approach to fragments would improve the language:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["During GraphQL\u2019s conception, there was debate on whether fragments should be included in the response via copy-paste/merge operations or via independent keys/composition: ",(0,a.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/issues/137#issuecomment-170184907",children:"https://github.com/graphql/graphql-spec/issues/137#issuecomment-170184907"})]}),"\n",(0,a.jsxs)(n.li,{children:["Fragment merging concretely required a complex update to our field-merging validation: ",(0,a.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/commit/d481d173749a03e342434070d14fb47116272dfa",children:"https://github.com/graphql/graphql-spec/commit/d481d173749a03e342434070d14fb47116272dfa"})]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"related-issues",children:"Related Issues"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Fragment Arguments: ",(0,a.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/pull/865",children:"https://github.com/graphql/graphql-spec/pull/865"})]}),"\n",(0,a.jsxs)(n.li,{children:["Client Controlled Nullability: ",(0,a.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/pull/895",children:"https://github.com/graphql/graphql-spec/pull/895"})]}),"\n",(0,a.jsx)(n.li,{children:"Error Boundaries (see discussion in Client Defined Nullability)"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"solution-space-modularity-via-fragment-response-keys",children:"Solution Space: Modularity via fragment response keys"}),"\n",(0,a.jsx)(n.p,{children:"TL;DR: We want to move selection sets towards a model of composing child fragments, as Relay and other native clients already provide."}),"\n",(0,a.jsx)(n.p,{children:"There are a few different ways we could tackle this problem. One thing people have reached for many times is adding a key into the response that \u201csplits\u201d a fragment\u2019s sub-response into an explicitly keyed sub-tree."}),"\n",(0,a.jsx)(n.p,{children:"So if we have GraphQL like:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"fragment Foo on Actor {\n  # replace these spreads with various syntax proposals below\n  ...Bar\n  ... on HasName {\n    name\n  }\n  id\n}\nfragment Bar on HasAccount {\n  account_name\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"We should get a response like:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'{\n  "Bar": {\n    "account_name": "mjmahone"\n  },\n  "HasName": {\n    "name": "Matt"\n  },\n  "id": 0\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"syntax-0-key-all-fragment-spreads",children:"Syntax #0: key all fragment \u201cspreads\u201d"}),"\n",(0,a.jsx)(n.p,{children:"This proposal basically says that responses by default would now add in a key for each fragment spread and inline fragment spread. So the document described above would have the response with keyed fragments, with no syntax changes needed."}),"\n",(0,a.jsx)(n.p,{children:"This is very clearly not backwards compatible, but if we were redesigning a new version of GraphQL, might be something we\u2019d want to consider."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Option #0B: Use a directive to turn key-ness on/off"})}),"\n",(0,a.jsxs)(n.p,{children:["If we\u2019re convinced that by ",(0,a.jsx)(n.em,{children:"default"})," fragments should be keyed, we could have some directive that changes the shape of the response, a la ",(0,a.jsx)(n.code,{children:"...Foo @alias"}),". Lee Byron has noted that specification directives should probably not change the response shape: this is not a great option if we want to abide by that logic."]}),"\n",(0,a.jsxs)(n.h3,{id:"syntax-1-aliased-spreads-foo-foo",children:["Syntax #1: aliased spreads ",(0,a.jsx)(n.code,{children:"Foo: ...Foo"})]}),"\n",(0,a.jsx)(n.p,{children:"Allow people to opt-in to getting a keyed fragment sub-response by enabling fragment spreads (inline and named) to be aliased. This makes fragment spreads an alias-able value."}),"\n",(0,a.jsx)(n.p,{children:"Example Executable:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"fragment Foo on Actor {\n  Bar: ...Bar\n  HasName: ... on HasName {\n    name\n  }\n  id\n}\nfragment Bar on HasAccount {\n  account_name\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If ",(0,a.jsx)(n.strong,{children:"every"})," fragment spread was aliased with the above syntax, then we\u2019d have some neat request/response symmetry: every fragment, inline or not, would have their selection set\u2019s response brackets exactly line up with ",(0,a.jsx)(n.strong,{children:"one"})," set of ",(0,a.jsx)(n.code,{children:"{}"})," within the executable document."]}),"\n",(0,a.jsx)(n.p,{children:"Personally, this is @mjmahone's current favored potential solution to adding fragment keys to the response."}),"\n",(0,a.jsxs)(n.h3,{id:"syntax-2-aliased-object-foo--foo-",children:["Syntax #2: aliased object ",(0,a.jsx)(n.code,{children:"Foo: { ...Foo }"})]}),"\n",(0,a.jsxs)(n.p,{children:["For this option, we\u2019d allow arbitrary object aliasing. Dan Schafer found this syntax pleasant, as it provides a way to keep brackets matched between the executable document and response. On the other hand, that symmetry ignores that we ",(0,a.jsx)(n.em,{children:"already"})," have mismatched brackets with inline fragment spreads."]}),"\n",(0,a.jsx)(n.p,{children:"Example Executable:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"fragment Foo on Actor {\n  Bar: {\n    ...Bar\n  }\n  HasName: {\n    ... on HasName {\n      name\n    }\n  }\n  name\n}\nfragment Bar on HasAccount {\n account_name\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["With this syntax, we could encapsulate arbitrary fields under an alias. However, we ",(0,a.jsx)(n.em,{children:"already"})," can do that with untyped inline fragment spreads, a la ",(0,a.jsx)(n.code,{children:"... { some_fields }"}),'. It might be cleaner to start considering fragment definitions and inline fragments as "bracket creators" in the response to get the symmetry Dan found pleasing.']}),"\n",(0,a.jsx)(n.p,{children:"Solution #2 could be combined with the Solution #1 to allow arbitrary aliasing of both spreads and arbitrary selection sets, though that might cause more confusion than it would clear up."}),"\n",(0,a.jsxs)(n.h3,{id:"syntax-3-special-syntax-instead-of-",children:["Syntax #3: special syntax instead of ",(0,a.jsx)(n.code,{children:"..."})]}),"\n",(0,a.jsxs)(n.p,{children:["Given ",(0,a.jsx)(n.code,{children:"..."})," right now has semantic meaning, essentially, of \u201ccopy paste conditionally based on type\u201d, it might muddy meaning if we allowed that copy-paste semantic to be used in an aliased way. Therefore, it may be better to have a new syntax to mean \u201ccreate a key for the inline fragment or fragment spread\u201d. If we used the ",(0,a.jsx)(n.code,{children:"&"})," symbol, we could have:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"fragment Foo on Actor {\n  &Bar\n  & on HasName {\n    name\n  }\n  id\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Some options:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"#Foo"}),": hashtag sort of means \u201clink\u201d on the web, but in GraphQL is overloaded already to mean \u201cComment this line\u201d"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"@Foo"}),": similarly, ",(0,a.jsx)(n.code,{children:"@"})," sort of means \u201clink to this other thing\u201d, but again is overloaded, this time for directive usage."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"&Foo"}),": ",(0,a.jsx)(n.code,{children:"&"})," usually means reference in programming, and that\u2019s kind of what we\u2019re doing here: we\u2019re saying \u201cin this spot in the response, add a reference to the following fragment\u201d. Unfortunately, in both JS and PHP ref values are usually associated with spaghetti code, so it might come off as looking bad"]}),"\n",(0,a.jsx)(n.li,{children:"Other options?"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"solution-space-modularity-via-metadata",children:"Solution Space: Modularity via metadata"}),"\n",(0,a.jsxs)(n.p,{children:["Another potential option would be to add metadata into the response to indicate which fragments were actually included. One shape of solution is via something like the ",(0,a.jsxs)(n.a,{href:"https://github.com/graphql/graphql-spec/pull/879",children:[(0,a.jsx)(n.code,{children:"__fulfilled"})," meta-field RFC"]}),". Any of these options have the downside of being essentially client compile-time only information, that means what the client needs in order to properly fulfill a product UI starts to stray from what the user actually writes."]}),"\n",(0,a.jsx)(n.h3,{id:"metadata-option-1-add-a-field-that-indicates-whether-a-selection-set-was-fulfilled",children:"Metadata Option 1: Add a field that indicates whether a selection set was fulfilled"}),"\n",(0,a.jsxs)(n.p,{children:["This is essentially the ",(0,a.jsx)(n.code,{children:"__fulfilled"})," proposal in ",(0,a.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/pull/879",children:"https://github.com/graphql/graphql-spec/pull/879"})]}),"\n",(0,a.jsx)(n.p,{children:"We could support pretty much any of the fragment-spread-syntax changes above by transforming a selection set like"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"{\n  Foo: ...Foo\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"To something like"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"{\n  ... on HasAccount {\n    fulfilledFoo: __fulfilled\n    ...Foo\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"metadata-option-2-add-information-into-the-responses-extensions",children:["Metadata Option 2: Add information into the response\u2019s ",(0,a.jsx)(n.code,{children:"extensions"})]}),"\n",(0,a.jsxs)(n.p,{children:["This adds metadata around which fragments were included in a response in ",(0,a.jsx)(n.code,{children:"extensions"}),". It could be used in conjunction with a fragment-spread directive. A downside here is that we\u2019ve just made a non-modular design (all fragments end up in the ",(0,a.jsx)(n.code,{children:"extensions"})," key, not colocated with their other fragment fields within the response) in order to achieve some semblance of client-facing modularity."]}),"\n",(0,a.jsx)(n.h2,{id:"solution-space-new-response-format",children:"Solution Space: New Response Format"}),"\n",(0,a.jsx)(n.p,{children:"A core reason we originally chose not to have a fragment spread represented via a key in the response was due to a worry about duplicating fields many times in the response."}),"\n",(0,a.jsxs)(n.p,{children:["However, it\u2019s possible that GraphQL the Ecosystem would improve if we had some alternative response designs. These responses could encapsulate ",(0,a.jsx)(n.strong,{children:"more"})," information than the existing Specification-described JSON response format. Basically, the requirement is likely just that we can go from this new response format to a perfectly valid Specification-described response without losing any Specification-described information, but we may not need to support the inverse (i.e. we could only go from a Spec-response to the New-response in a lossy way)."]}),"\n",(0,a.jsx)(n.h3,{id:"response-format-option-1-graph-response",children:"Response Format Option 1: Graph Response"}),"\n",(0,a.jsxs)(n.p,{children:["We might be able to have a more efficient design if the response came back in a Graph form, as opposed to in JSON tree form. You would probably still ",(0,a.jsx)(n.strong,{children:"access"})," the graph via tree-shaped structures in client code, but this would format the response similar to how most normalized GraphQL stores that keep data consistent across responses are formatted."]}),"\n",(0,a.jsx)(n.p,{children:"An example of a psuedo-syntax for a response from the query below:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"query {\n  me {\n    id\n    ...Bar\n  }\n}\n\nfragment Bar on HasAccount {\n  account_name\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"might look something like:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'Query {\n  me -> User:0\n}\n\nUser:0 {\n  id: 0\n  account_name: "mjmahone"\n  Bar -> User:0\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["In this world, the ",(0,a.jsx)(n.code,{children:"Query.me"})," field points to a specific entity, ",(0,a.jsx)(n.code,{children:"User"})," with ",(0,a.jsx)(n.code,{children:"id"})," ",(0,a.jsx)(n.code,{children:"0"}),".  ",(0,a.jsx)(n.code,{children:"...Bar"})," is a fragment spread that also points to that same ",(0,a.jsx)(n.code,{children:"User"}),". If for some reason ",(0,a.jsx)(n.code,{children:"Bar"})," was unfulfilled in the query (i.e. ",(0,a.jsx)(n.code,{children:"me"})," does not fulfill ",(0,a.jsx)(n.code,{children:"HasAccount"}),"), the fragment spread pointer could be null."]}),"\n",(0,a.jsx)(n.p,{children:"The above response format would require\u200b the server understanding how to merge two fields that logically represent the same value, but are present in two completely different places in the request tree. There are many potential ways to solve this problem: above, we're solving it by keying each entity by its type and some server-defined \u201cprimary key\u201d, but we could make this entity key more explicit or even less formalized within the specification."}),"\n",(0,a.jsx)(n.p,{children:"We could also combine the new graph response with a new fragment \u201ckey\u201d syntax, such that regular fragment spreads still act as inheritance, and only the new keys end up in the graph response. However, given the lower cost for duplicated fields in a graph format, this may not be a major issue."}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>i});var a=t(7294);const s={},r=a.createContext(s);function i(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);