"use strict";(self.webpackChunk_localrepo_benjie_dev=self.webpackChunk_localrepo_benjie_dev||[]).push([[8152],{3529:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>d});var r=i(5893),t=i(1151);const a={identifier:"FragmentArguments",stage:"0",title:"Fragment Arguments",events:[{type:"docCreated",date:new Date("2023-02-10T11:26:50.000Z"),href:"https://github.com/graphql/graphql-wg/blob/7f882eb24f26b54b7663f766c69d0a3b0ef76535/rfcs/FragmentArguments.md",actor:"Matt Mahoney"}],related:"1045",shortname:"Fragment Arguments",image:"/img/rfc_tracker.png"},s=void 0,l={id:"FragmentArguments",title:"Fragment Arguments",description:"At a glance",source:"@site/rfcs/FragmentArguments.md",sourceDirName:".",slug:"/FragmentArguments",permalink:"/rfcs/FragmentArguments",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{identifier:"FragmentArguments",stage:"0",title:"Fragment Arguments",events:[{type:"docCreated",date:"2023-02-10T11:26:50.000Z",href:"https://github.com/graphql/graphql-wg/blob/7f882eb24f26b54b7663f766c69d0a3b0ef76535/rfcs/FragmentArguments.md",actor:"Matt Mahoney"}],related:"1045",shortname:"Fragment Arguments",image:"/img/rfc_tracker.png"},sidebar:"rfcsSidebar",previous:{title:'"Root" Types clarity \u2192 "Operation Type"',permalink:"/rfcs/1015"},next:{title:"Fragment Arguments: RFC + Implementation Details",permalink:"/rfcs/wg1239"}},o={},d=[{value:"At a glance",id:"at-a-glance",level:2},{value:"Timeline",id:"timeline",level:2},{value:"RFC: Fragment Arguments",id:"rfc-fragment-arguments",level:2},{value:"New Fragment Argument Definition syntax",id:"new-fragment-argument-definition-syntax",level:2},{value:"New Fragment Spread Argument syntax",id:"new-fragment-spread-argument-syntax",level:2},{value:"Scope: Local",id:"scope-local",level:2},{value:"New Validation Rule: Fragment Argument Definitions Used in Fragment",id:"new-validation-rule-fragment-argument-definitions-used-in-fragment",level:2},{value:"Consideration: how strict should this rule be?",id:"consideration-how-strict-should-this-rule-be",level:3},{value:"Updated Validation Rule: Required Arguments are Provided",id:"updated-validation-rule-required-arguments-are-provided",level:2},{value:"Potential Alternative: Default Value indicates <em>required or not</em>, and <code>!</code> indicates <em>non-null or nullable</em>.",id:"potential-alternative-default-value-indicates-required-or-not-and--indicates-non-null-or-nullable",level:3},{value:"Updated Validation: Overlapping Fields Can Be Merged",id:"updated-validation-overlapping-fields-can-be-merged",level:2},{value:"WILL NOT IMPLEMENT Validation Rule: Document Argument Uniqueness",id:"will-not-implement-validation-rule-document-argument-uniqueness",level:2},{value:"Initial Implementation",id:"initial-implementation",level:2}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"at-a-glance",children:"At a glance"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Identifier"}),": FragmentArguments"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stage"}),": ",(0,r.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md#stage-0-strawman",children:"RFC0: Strawman"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Champion"}),": -"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"PR"}),": -"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Related"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/rfcs/1045",title:"Remove fragmentSpreadName from visitedFragments when visit is complete / RFC0",children:"#1045"})," (Remove fragmentSpreadName from visitedFragments when visit is complete)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"timeline",children:"Timeline"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/7f882eb24f26b54b7663f766c69d0a3b0ef76535/rfcs/FragmentArguments.md",children:"RFC document created"})})," on 2023-02-10 by Matt Mahoney"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.h2,{id:"rfc-fragment-arguments",children:"RFC: Fragment Arguments"}),"\n",(0,r.jsx)(n.h1,{id:"problem-variable-modularity",children:"Problem: Variable Modularity"}),"\n",(0,r.jsx)(n.p,{children:"GraphQL fragments are designed to allow a client's data requirements to compose.\nTwo different screens can use the same underlying UI component. If that\ncomponent has a corresponding fragment, then each of those screens can include\nexactly the data required by having each query spread the child component's\nfragment."}),"\n",(0,r.jsx)(n.p,{children:"This modularity begins to break down for variables. As an example, let\u200b's imagine\na FriendsList component that shows a variable number of friends. We would have a\nfragment for that component like so:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"fragment FriendsList on User {\n  friends(first: $nFriends) {\n    name\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"In one use, we might want to show some screen-supplied number of friends, and in\nanother the top 10. For example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"fragment AnySizedFriendsList on User {\n  name\n  ...FriendsList\n}\n\nfragment TopFriendsUserProfile on User {\n  name\n  profile_picture { uri }\n  ...FriendsList\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Even though every usage of ",(0,r.jsx)(n.code,{children:"TopFriendsUserProfile"})," should be setting ",(0,r.jsx)(n.code,{children:"$nFriends"}),"\nto ",(0,r.jsx)(n.code,{children:"10"}),", the only way to enforce that is by manually walking all callers of\n",(0,r.jsx)(n.code,{children:"TopFriendsUserProfile"}),", recursively, until you arrive at the operation\ndefinition and verify the variable is defined like ",(0,r.jsx)(n.code,{children:"$nFriends: Int = 10"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"This causes a few major usability problems:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If I ever want to change the number of items ",(0,r.jsx)(n.code,{children:"TopFriendsUserProfile"})," includes,\nI now need to update every ",(0,r.jsx)(n.em,{children:"operation"})," that includes it. This could be dozens\nor hundreds of individual locations."]}),"\n",(0,r.jsxs)(n.li,{children:["Even if the component for ",(0,r.jsx)(n.code,{children:"TopFriendsUserProfile"})," is only able to display 10\nfriends, in most clients at runtime the user can override the default value,\nenabling a mismatch between the data required and the data asked for."]}),"\n"]}),"\n",(0,r.jsxs)(n.h1,{id:"existing-solution-relays-argumentsargumentdefinitions",children:["Existing Solution: Relay's ",(0,r.jsx)(n.code,{children:"@arguments"}),"/",(0,r.jsx)(n.code,{children:"@argumentDefinitions"})]}),"\n",(0,r.jsxs)(n.p,{children:["Relay has a solution for this problem by using a custom, non-spec-compliant pair\nof directives,\n",(0,r.jsxs)(n.a,{href:"https://relay.dev/docs/api-reference/graphql-and-directives/#arguments",children:[(0,r.jsx)(n.code,{children:"@arguments"}),"/",(0,r.jsx)(n.code,{children:"@argumentDefinitions"})]}),"."]}),"\n",(0,r.jsx)(n.p,{children:"These directives live only in user-facing GraphQL definitions, and are compiled\naway prior to making a server request."}),"\n",(0,r.jsx)(n.p,{children:"Following the above example, if we were using Relay we'd be able to write:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'fragment FriendsList on User @argumentDefinitions(nFriends: {type: "Int!"}) {\n  friends(first: $nFriends) {\n    name\n  }\n}\n\nfragment AnySizedFriendsList on User {\n  name\n  ...FriendsList @arguments(nFriends: $operationProvidedFriendCount)\n}\n\nfragment TopFriendsUserProfile on User {\n  name\n  profile_picture { uri }\n  ...FriendsList @arguments(nFriends: 10)\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Before sending a query to the server, Relay compiles away these directives so\nthe server, when running an operation using ",(0,r.jsx)(n.code,{children:"TopFriendsUserProfile"}),", sees:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"fragment FriendsList on User {\n  friends(first: 10) {\n    name\n  }\n}\n\nfragment TopFriendsUserProfile on User {\n  name\n  profile_picture { uri }\n  ...FriendsList\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The exact mechanics of how Relay rewrites the user-written operation based on\n",(0,r.jsx)(n.code,{children:"@arguments"})," supplied is not the focus of this RFC."]}),"\n",(0,r.jsxs)(n.p,{children:["However, even to enable this client-compile-time operation transformation, Relay\nhad to introduce ",(0,r.jsx)(n.em,{children:"non-compliant directives"}),": each argument to ",(0,r.jsx)(n.code,{children:"@arguments"}),"\nchanges based on the fragment the directive is applied to. While syntactically\nvalid, this fails the\n",(0,r.jsx)(n.a,{href:"https://spec.graphql.org/draft/#sec-Argument-Names",children:"Argument Names validation"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Additionally, the ",(0,r.jsx)(n.code,{children:"@argumentDefinitions"})," directive gets very verbose and unsafe,\nusing strings to represent variable type declarations."]}),"\n",(0,r.jsxs)(n.p,{children:["Relay has supported ",(0,r.jsx)(n.code,{children:"@arguments"})," in its current form since\n",(0,r.jsx)(n.a,{href:"https://github.com/facebook/relay/releases/tag/v2.0.0",children:"v2.0"}),", released in\nJanuary 2019. There's now a large body of evidence that allowing fragments to\ndefine arguments that can be passed into fragment spreads is a significant\nusability improvement, and valuable to the wider GraphQL community. However, if\nwe are to introduce this notion more broadly, we should make sure the ergonomics\nof it conform to users' expectations."]}),"\n",(0,r.jsx)(n.h1,{id:"proposal-introduce-fragment-argument-definitions-which-allow-using-arguments-on-fragment-spreads",children:"Proposal: Introduce Fragment Argument Definitions, which allow using arguments on Fragment Spreads"}),"\n",(0,r.jsxs)(n.p,{children:["Relay's ",(0,r.jsx)(n.code,{children:"@arguments"}),"/",(0,r.jsx)(n.code,{children:"@argumentDefinitions"})," concepts provide value, and can be\napplied against GraphQL written for existing GraphQL servers so long as there is\na pre-server compiler which transforms the concept away."]}),"\n",(0,r.jsx)(n.h2,{id:"new-fragment-argument-definition-syntax",children:"New Fragment Argument Definition syntax"}),"\n",(0,r.jsxs)(n.p,{children:["For the ",(0,r.jsx)(n.code,{children:"@argumentDefinitions"})," concept, we can allow fragments to share the same\nsyntax as operation level definitions. Going back to the previous example, this\nwould look like:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"fragment FriendsList($nFriends: Int!) on User {\n  friends(first: $nFriends) {\n    name\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The syntax re-uses the concepts from Variable Definitions, so that when you\n",(0,r.jsx)(n.em,{children:"define"})," and ",(0,r.jsx)(n.em,{children:"use"})," the argument, it preserves the same appearance (",(0,r.jsx)(n.code,{children:"$"})," + name)."]}),"\n",(0,r.jsx)(n.h2,{id:"new-fragment-spread-argument-syntax",children:"New Fragment Spread Argument syntax"}),"\n",(0,r.jsxs)(n.p,{children:["For the ",(0,r.jsx)(n.code,{children:"@arguments"})," concept, we can allow fragment spreads to share the same\nsyntax as field and directive arguments."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"fragment AnySizedFriendsList on User {\n  name\n  ...FriendsList(nFriends: $operationProvidedFriendCount)\n}\n\nfragment TopFriendsUserProfile on User {\n  name\n  profile_picture { uri }\n  ...FriendsList(nFriends: 10)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This may feel a little weird: for fields, arguments are defined as\n",(0,r.jsx)(n.code,{children:"argName: Type"})," and then used like ",(0,r.jsx)(n.code,{children:"...Foo(argName: $variable)"}),". The\nalternatives here are:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Define ",(0,r.jsx)(n.code,{children:"argName: Type"})," for fragment arguments","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"This has the disadvantage of seeing both the argument definition and the\nargument usage in the same fragment with different styles."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Call ",(0,r.jsx)(n.code,{children:"...Foo($argName: $variable)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["This feels incredibly confusing: ",(0,r.jsx)(n.code,{children:"$"})," typically means \"replace this token\nwith a value\", and that's not what's happening."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Notably, this proposed syntax, of using ",(0,r.jsx)(n.code,{children:"$name"})," at the definition and usage\nsite, and ",(0,r.jsx)(n.code,{children:"name:"})," when calling the Fragment/Function\u200b, is the convention that PHP\nuses for\n",(0,r.jsx)(n.a,{href:"https://www.php.net/manual/en/functions.arguments.php#functions.named-arguments",children:"Named Arguments"}),".\nGiven GraphQL was designed with many PHP-isms, it seems like we should re-use\nthe conventions chosen there when there's no clear reason not to."]}),"\n",(0,r.jsx)(n.h2,{id:"scope-local",children:"Scope: Local"}),"\n",(0,r.jsx)(n.p,{children:'Fragment Arguments should always have local scope. This gets us closer to the\nidea that while operations are "global", fragments behave more like well-scoped\nfunctions.'}),"\n",(0,r.jsx)(n.p,{children:"This has a bunch of beneficial side effects:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"For validation, we don't need ot check for fragment argument definition\nclashes"}),"\n",(0,r.jsx)(n.li,{children:"For composability, I can use the same argument on many fragments and not worry\nabout unrelated fragments."}),"\n",(0,r.jsx)(n.li,{children:"For ease-of-understanding, you don't need to keep track of how all child\nfragments use a fragment argument to understand how changing something like\nthe default value will modify the results."}),"\n",(0,r.jsx)(n.li,{children:"Makes it easy to update Variables In Allowed Positions, as we don't need to\nhunt the definition of a variable across many potential parent fragments."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The other scoping options are:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Global, i.e. a fragment argument is just syntactic sugar for an operation\nvariable.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"This is what we implemented at Meta, and it was terrible for all the reasons\nyou can think of."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Recursively local, i.e. the variable takes on any parent fragment argument\ndefinition","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"This preserves the concept of the value being some sort of recursively\nscoped variable."}),"\n",(0,r.jsx)(n.li,{children:"However, as explained above, keeping track of what's happening, and\npreventing fragment conflicts, becomes really difficult."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["We're choosing to explicitly ",(0,r.jsx)(n.em,{children:"allow"})," overriding operation variables, as the\nlocal scope means you can clearly see whether a variable is scoped to the\nfragment or operation."]}),"\n",(0,r.jsx)(n.h2,{id:"new-validation-rule-fragment-argument-definitions-used-in-fragment",children:"New Validation Rule: Fragment Argument Definitions Used in Fragment"}),"\n",(0,r.jsx)(n.p,{children:"With local scope, this rule is very simple."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"fragment Foo($x: Int) on User {\n  name\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"would be invalid."}),"\n",(0,r.jsx)(n.p,{children:"Additionally,"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"fragment Foo($x: Int!) on User {\n  ...Bar\n}\n\nfragment Bar {\n  number(x: $x)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["would also be invalid: even though ",(0,r.jsx)(n.code,{children:"$x"})," is used underneath Foo, it is used\noutside of Foo's explicit definition. In this context, ",(0,r.jsx)(n.code,{children:"$x"})," in Bar is actually\nan operation variable."]}),"\n",(0,r.jsx)(n.p,{children:"However, this would be valid:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"fragment Foo($x: Int!) on User {\n  ...Bar(x: $x)\n}\n\nfragment Bar($x: Int) {\n  number(x: $x)\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"consideration-how-strict-should-this-rule-be",children:"Consideration: how strict should this rule be?"}),"\n",(0,r.jsxs)(n.p,{children:["As an initial RFC, I'd advocate for encouraging the ",(0,r.jsx)(n.em,{children:"strictest"})," version of this\nrule possible: any argument defined on a fragment must be explicitly used by\nthat same fragment. It would be easy to relax the rule later, but very difficult\nto do the reverse."]}),"\n",(0,r.jsxs)(n.p,{children:["It's clearly more composable if, when changing a child fragment, you don't need\nto worry about modifying argument definitions on parent fragments callsites.\nHowever, we could in the future allow annotating argument definitions with\n",(0,r.jsx)(n.code,{children:"@deprecated"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"updated-validation-rule-required-arguments-are-provided",children:"Updated Validation Rule: Required Arguments are Provided"}),"\n",(0,r.jsxs)(n.p,{children:["We update\n",(0,r.jsx)(n.a,{href:"https://spec.graphql.org/draft/#sec-Required-Arguments",children:"Required Arguments"})," to\ninclude fragment spreads. This makes the validation's first two bullets:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["For each Field, ",(0,r.jsx)(n.strong,{children:"Fragment Spread"})," or Directive in the document."]}),"\n",(0,r.jsxs)(n.li,{children:["Let ",(0,r.jsx)(n.em,{children:"arguments"})," be the set of argument definitions of that Field, ",(0,r.jsx)(n.strong,{children:"Fragment"}),"\nor Directive."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["With this rule, the below example is invalid, even if the argument\n",(0,r.jsx)(n.code,{children:"User.number(x:)"})," is nullable in the schema."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"fragment Foo on User {\n  ...Bar\n}\n\nfragment Bar($x: Int!) on User {\n  number(x: $x)\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"potential-alternative-default-value-indicates-required-or-not-and--indicates-non-null-or-nullable",children:["Potential Alternative: Default Value indicates ",(0,r.jsx)(n.em,{children:"required or not"}),", and ",(0,r.jsx)(n.code,{children:"!"})," indicates ",(0,r.jsx)(n.em,{children:"non-null or nullable"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If we were writing the language from scratch, I'd advocate for making ",(0,r.jsx)(n.em,{children:"all"}),"\nargument definitions without a default value to be required, regardless of their\nnullability. If you want to make a nullable argument optional, you do so by\nadding a ",(0,r.jsx)(n.code,{children:"= null"})," to its definition."]}),"\n",(0,r.jsx)(n.p,{children:"In short, if I define:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"fragment Bar($x: Int) { number(x: $x) }\n"})}),"\n",(0,r.jsxs)(n.p,{children:["then ",(0,r.jsx)(n.code,{children:"...Bar"})," would be ",(0,r.jsx)(n.strong,{children:"invalid"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:['However, that\'s not how operation variables, field arguments, directive\narguments or input object fields work today, no matter how much I might wish it.\nFor this RFC, I\'m making the meaning of "required" and "nullable" for fragment\nspread arguments the same as all other inputs, because doing something\n',(0,r.jsx)(n.em,{children:"different"})," would be more confusing IMO, even if that difference would lead to\nunvalidated fewer foot guns."]}),"\n",(0,r.jsx)(n.h2,{id:"updated-validation-overlapping-fields-can-be-merged",children:"Updated Validation: Overlapping Fields Can Be Merged"}),"\n",(0,r.jsx)(n.p,{children:"Previously, fragment spreads didn't have to be considered as unique selections\nin the overlapping field merging algorithm. However, in practice the algorithm,\nbut not the spec, still de-duplicated common fragment spreads."}),"\n",(0,r.jsx)(n.p,{children:"With this change, we can just treat deduplicated fragment spreads as being keyed\nby (name, arguments) rather than just by name. When visiting child selections,\nwe need to apply any fragment argument values (basically replace them with\neither variable or const\u200b values), and then any time we encounter duplicated\nfragment spreads with different arguments within merging selections, we consider\nthat invalid."}),"\n",(0,r.jsxs)(n.p,{children:["We ",(0,r.jsx)(n.em,{children:"could"})," just allow field merging rules to apply, but stopping the validation\nwhen same-named fragment spreads with different args are discovered helps\nprovide much better error messaging and root-causes the issue: the issue isn't\nthat you reached the same field in the same fragment twice, but rather than you\nreached the same fragment spread with different arguments, which will induce\nthose two usages to be merging the same field with different arguments."]}),"\n",(0,r.jsx)(n.h2,{id:"will-not-implement-validation-rule-document-argument-uniqueness",children:"WILL NOT IMPLEMENT Validation Rule: Document Argument Uniqueness"}),"\n",(0,r.jsxs)(n.p,{children:["If the client pre-server compiler rewrites an operation, it's possible to end up\nwith a selection set that violates\n",(0,r.jsx)(n.a,{href:"https://spec.graphql.org/draft/#sec-Field-Selection-Merging",children:"Field Selection Merging"}),"\nvalidation. Additionally, we have no mechanism on servers today to handle the\nsame fragment having different variable values depending on that fragment's\nlocation in an operation."]}),"\n",(0,r.jsx)(n.p,{children:"Therefore, any Fragment Spread for the same Fragment in an Operation could be\nrequired to have non-conflicting argument values passed in."}),"\n",(0,r.jsx)(n.p,{children:"As an example, this is invalid:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"query {\n  user {\n    best_friend {\n      ...UserProfile(imageSize: 100)\n    }\n    ...UserProfile(imageSize: 200)\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Note: today Relay's compiler handles this ambiguity. In an extreme\nsimplification, this is done by producing two unique versions of ",(0,r.jsx)(n.code,{children:"UserProfile"}),",\nwhere in ",(0,r.jsx)(n.code,{children:"UserProfile_0"})," ",(0,r.jsx)(n.code,{children:"$imageSize"})," is replaced with ",(0,r.jsx)(n.code,{children:"100"}),", and in\n",(0,r.jsx)(n.code,{children:"UserProfile_1"})," ",(0,r.jsx)(n.code,{children:"$imageSize"})," is replaced with ",(0,r.jsx)(n.code,{children:"200"}),". However, there exist client\nimplementations that are unable to have multiple applications of the same\nfragment within a single operation (the clients I work on cannot use Relay's\ntrick)."]}),"\n",(0,r.jsx)(n.p,{children:"This validation rule is more strict than necessary: the graphql-js\nimplementation did not require\u200b it, given the Overlapping Fields Can Be Merged\nchanges that protect against mis-merged fields."}),"\n",(0,r.jsx)(n.p,{children:"This validation rule may end up being more strict than required, but it would be easier to relax the rule than make it more strict later."}),"\n",(0,r.jsx)(n.h1,{id:"implementation",children:"Implementation"}),"\n",(0,r.jsxs)(n.p,{children:["This proposal is implemented completely in\n",(0,r.jsx)(n.a,{href:"https://github.com/graphql/graphql-js/pull/3152",children:"graphql-js"})]}),"\n",(0,r.jsx)(n.h2,{id:"initial-implementation",children:"Initial Implementation"}),"\n",(0,r.jsx)(n.p,{children:"In the initial implementation, I tried to change as little as possible. This\nmeans I only added a single new validation rule. Additionally, there may be some\nweirdness around internal grammar and AST node naming/usage, but the actual\nbehavior should be feature complete."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>l,a:()=>s});var r=i(7294);const t={},a=r.createContext(t);function s(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);