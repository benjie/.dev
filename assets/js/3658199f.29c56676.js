"use strict";(self.webpackChunk_localrepo_benjie_dev=self.webpackChunk_localrepo_benjie_dev||[]).push([[8617],{3939:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>c,toc:()=>h});var i=s(5893),a=s(1151),t=s(768),l=s(4664);const r={type:"page",title:"Naming Conventions",description:"Benjie's researched opinion on GraphQL naming",tag:"graphql",author:"Benjie",breadcrumb:!1,sidebar_position:30},o="Naming conventions",c={id:"graphql/naming",title:"Naming Conventions",description:"Benjie's researched opinion on GraphQL naming",source:"@site/pages/graphql/naming.mdx",sourceDirName:"graphql",slug:"/graphql/naming",permalink:"/graphql/naming",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:30,frontMatter:{type:"page",title:"Naming Conventions",description:"Benjie's researched opinion on GraphQL naming",tag:"graphql",author:"Benjie",breadcrumb:!1,sidebar_position:30},sidebar:"defaultSidebar",previous:{title:"Static Documents",permalink:"/graphql/static-documents"},next:{title:"Nullability",permalink:"/graphql/nullability/"}},d={},h=[{value:"Schema",id:"schema",level:2},{value:"Types",id:"types",level:3},{value:"<code>Query</code>, <code>Mutation</code>, <code>Subscription</code>",id:"query-mutation-subscription",level:4},{value:"UpperCamelCase",id:"uppercamelcase",level:4},{value:"Singular",id:"singular",level:4},{value:"Prefix: none",id:"prefix-none",level:4},{value:"Suffix: mostly none",id:"suffix-mostly-none",level:4},{value:"Suffixes for <code>input</code>s",id:"suffixes-for-inputs",level:4},{value:"Enum values",id:"enum-values",level:3},{value:"CONSTANT_CASE",id:"constant_case",level:4},{value:"Fields (objects and interfaces)",id:"fields-objects-and-interfaces",level:3},{value:"camelCase",id:"camelcase",level:4},{value:"Input fields (input objects)",id:"input-fields-input-objects",level:3},{value:"camelCase",id:"camelcase-1",level:4},{value:"Directives",id:"directives",level:3},{value:"camelCase",id:"camelcase-2",level:4},{value:"Arguments (fields and directives)",id:"arguments-fields-and-directives",level:3},{value:"camelCase",id:"camelcase-3",level:4},{value:"Executable documents",id:"executable-documents",level:2},{value:"Operation names",id:"operation-names",level:3},{value:"camelCase",id:"camelcase-4",level:4},{value:"Fragments",id:"fragments",level:3},{value:"camelCase (or whatever)",id:"camelcase-or-whatever",level:4},{value:"Aliases",id:"aliases",level:3},{value:"camelCase",id:"camelcase-5",level:4},{value:"Short",id:"short",level:4},{value:"Extra research",id:"extra-research",level:2},{value:"Example schema",id:"example-schema",level:3},{value:"Other GraphQL naming guides",id:"other-graphql-naming-guides",level:3}];function u(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"naming-conventions",children:"Naming conventions"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"I rushed this article out a little... Feel free to challenge anything on here\nand I'll be happy to add more detail!"})}),"\n",(0,i.jsxs)(l.Z,{children:[(0,i.jsx)(n.p,{children:"CapitalCase/PascalCase was a reserved space for types \u2014 if I see something\nin PascalCase I default to assuming it's a type in the schema, if I see\nsomething camelCase I assume it's something other than that. Obviously, the\nconvention for field names and argument names and variable names is all camel\ncase. Fragment names are a little bit in an in\u2013between space there. Made\nsense to me to treat them more similarly to a field than more similarly to a\ntype."}),(0,i.jsxs)(n.p,{children:["\u2014 ",(0,i.jsx)(n.em,{children:"Lee Byron, editor of the GraphQL Specification"})]})]}),"\n",(0,i.jsx)(n.p,{children:"This document aims to outline a standard naming conventions for the various\nentities that make up a GraphQL schema or executable document, and explain why\nthe conventions were chosen (and reasons you might consider an alternative)."}),"\n",(0,i.jsx)(n.p,{children:'In general, this guide defers to the conventions used in the GraphQL\nSpecification (the "Spec").'}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Important note: it does not matter what the name used in your underlying\nbusiness logic or data storage is, GraphQL is the names that you present to the\nworld and it should follow conventions that the schema users will find easy to\nfollow."})}),"\n",(0,i.jsx)(n.p,{children:"For a quick summary, use the table of contents."}),"\n",(0,i.jsx)(t.u,{children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"UpperCamelCase"})," for type names."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"camelCase"})," for field names, argument names, directive names, operation names,\nvariable names, and aliases."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CONSTANT_CASE"})," for enum values."]}),"\n",(0,i.jsxs)(n.li,{children:["Name fragments however you want... but if in doubt, use ",(0,i.jsx)(n.code,{children:"camelCase"}),"."]}),"\n"]})}),"\n",(0,i.jsx)(n.h2,{id:"schema",children:"Schema"}),"\n",(0,i.jsx)(n.p,{children:"A GraphQL schema defines a number of types of named entities:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"types: scalar, enum, object, interface, union, input object"}),"\n",(0,i.jsx)(n.li,{children:"enum values"}),"\n",(0,i.jsx)(n.li,{children:"fields (objects and interfaces)"}),"\n",(0,i.jsx)(n.li,{children:"input fields (input objects)"}),"\n",(0,i.jsx)(n.li,{children:"directives"}),"\n",(0,i.jsx)(n.li,{children:"arguments (fields and directives)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Let's look at naming conventions for each of these in turn."}),"\n",(0,i.jsx)(n.h3,{id:"types",children:"Types"}),"\n",(0,i.jsxs)(n.p,{children:['There are 6 kind of "type" in GraphQL: ',(0,i.jsx)(n.code,{children:"scalar"}),", ",(0,i.jsx)(n.code,{children:"enum"}),", ",(0,i.jsx)(n.code,{children:"type"}),' ("object"),\n',(0,i.jsx)(n.code,{children:"interface"}),", ",(0,i.jsx)(n.code,{children:"union"})," and ",(0,i.jsx)(n.code,{children:"input"}),' ("input object"). All these types live in the\nsame namespace, i.e. if you have a ',(0,i.jsx)(n.code,{children:"type"})," called ",(0,i.jsx)(n.code,{children:"Frog"})," then you cannot also\nhave an ",(0,i.jsx)(n.code,{children:"input"})," called ",(0,i.jsx)(n.code,{children:"Frog"}),"."]}),"\n",(0,i.jsx)(n.p,{children:'The naming conventions for all 6 kinds of "type" in GraphQL tend to be aligned.'}),"\n",(0,i.jsxs)(n.h4,{id:"query-mutation-subscription",children:[(0,i.jsx)(n.code,{children:"Query"}),", ",(0,i.jsx)(n.code,{children:"Mutation"}),", ",(0,i.jsx)(n.code,{children:"Subscription"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://spec.graphql.org/draft/#sec-Root-Operation-Types",children:'"Root operation types"'}),"\nare special types that are used as the type of the ",(0,i.jsx)(n.code,{children:"query"}),", ",(0,i.jsx)(n.code,{children:"mutation"})," and\n",(0,i.jsx)(n.code,{children:"subscription"})," operations. You should name these ",(0,i.jsx)(n.code,{children:"Query"}),", ",(0,i.jsx)(n.code,{children:"Mutation"})," and\n",(0,i.jsx)(n.code,{children:"Subscription"})," respectively so you don't need to declare the supported\noperations/types via the ",(0,i.jsx)(n.code,{children:"schema"})," keyword."]}),"\n",(0,i.jsx)(n.h4,{id:"uppercamelcase",children:"UpperCamelCase"}),"\n",(0,i.jsx)(n.p,{children:"The root operation types already use this naming convention, and it's used\nthroughout the Spec. Seems uncontroversial."}),"\n",(0,i.jsx)(n.h4,{id:"singular",children:"Singular"}),"\n",(0,i.jsxs)(n.p,{children:["If you have a type that represents a person, the type should be called something\nlike ",(0,i.jsx)(n.code,{children:"Person"}),". It should not be called ",(0,i.jsx)(n.code,{children:"People"}),". There are no plural type names\nin the Spec."]}),"\n",(0,i.jsx)(n.h4,{id:"prefix-none",children:"Prefix: none"}),"\n",(0,i.jsxs)(n.p,{children:['GraphQL types should not be prefixed, for example an interface representing\n"media" would be called ',(0,i.jsx)(n.code,{children:"Media"}),", ",(0,i.jsx)(n.strong,{children:"not"})," ",(0,i.jsx)(n.code,{children:"IMedia"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"suffix-mostly-none",children:"Suffix: mostly none"}),"\n",(0,i.jsxs)(n.p,{children:["In general GraphQL types should not have suffixes, for example a custom scalar\nrepresenting a UUID would be called ",(0,i.jsx)(n.code,{children:"UUID"}),", ",(0,i.jsx)(n.strong,{children:"not"})," ",(0,i.jsx)(n.code,{children:"UUIDScalar"}),". One exception\nto this is input object types..."]}),"\n",(0,i.jsxs)(n.h4,{id:"suffixes-for-inputs",children:["Suffixes for ",(0,i.jsx)(n.code,{children:"input"}),"s"]}),"\n",(0,i.jsxs)(n.p,{children:["At time of writing the Spec includes the following non-placeholder ",(0,i.jsx)(n.code,{children:"input"}),"s in\nexamples:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"input Point"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"input Point2D"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"input FindDogInput"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["In real-world schemas it's rare to find input objects that don't have a suffix;\nthis is because it's very common for an ",(0,i.jsx)(n.code,{children:"input"})," to have an associated ",(0,i.jsx)(n.code,{children:"type"}),",\nand these types cannot use the same name. Generally the ",(0,i.jsx)(n.code,{children:"type"}),' will use the\n"base name" (e.g. ',(0,i.jsx)(n.code,{children:"Point"}),") and the input will use a derived name that has a\nsuffix, for example ",(0,i.jsx)(n.code,{children:"PointInput"}),", ",(0,i.jsx)(n.code,{children:"PointPatch"})," or similar."]}),"\n",(0,i.jsx)(n.p,{children:"Common suffixes used for input objects are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Input"}),' - generally used for the input version of an output type (e.g. for a\n"create" or "upsert" mutation)']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Patch"})," or ",(0,i.jsx)(n.code,{children:"Update"}),' (Benjie prefers "Patch") - generally used when applying an\nupdate to an output type, typically all of the fields are nullable so that you\ncan choose to only update the fields you specify (e.g. for an "update"\nmutation)']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Filter"})," - generally used to specify how to filter a collection"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Order"})," - generally used for ordering (sorting) a collection"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Reason: PostGraphile API, GitHub API"}),"\n",(0,i.jsx)(n.h3,{id:"enum-values",children:"Enum values"}),"\n",(0,i.jsx)(n.h4,{id:"constant_case",children:"CONSTANT_CASE"}),"\n",(0,i.jsx)(n.p,{children:"Reason: the Spec, PostGraphile API, GitHub API"}),"\n",(0,i.jsx)(n.h3,{id:"fields-objects-and-interfaces",children:"Fields (objects and interfaces)"}),"\n",(0,i.jsx)(n.h4,{id:"camelcase",children:"camelCase"}),"\n",(0,i.jsx)(n.p,{children:"Reason: the Spec, PostGraphile API, GitHub API"}),"\n",(0,i.jsx)(n.h3,{id:"input-fields-input-objects",children:"Input fields (input objects)"}),"\n",(0,i.jsx)(n.p,{children:"Generally the same as object fields."}),"\n",(0,i.jsx)(n.h4,{id:"camelcase-1",children:"camelCase"}),"\n",(0,i.jsx)(n.p,{children:"Reason: the Spec, PostGraphile API, GitHub API"}),"\n",(0,i.jsx)(n.h3,{id:"directives",children:"Directives"}),"\n",(0,i.jsx)(n.h4,{id:"camelcase-2",children:"camelCase"}),"\n",(0,i.jsxs)(n.p,{children:["The built in directives ",(0,i.jsx)(n.code,{children:"@skip"})," and ",(0,i.jsx)(n.code,{children:"@include"})," could be camelCase or even\nsnake_case; but we discussed this at the GraphQL WG regarding the ",(0,i.jsx)(n.code,{children:"@oneOf"}),"\ndirective and it was decided that we would use camelCase going forward."]}),"\n",(0,i.jsx)(n.p,{children:"Reason: the Spec"}),"\n",(0,i.jsx)(n.h3,{id:"arguments-fields-and-directives",children:"Arguments (fields and directives)"}),"\n",(0,i.jsx)(n.h4,{id:"camelcase-3",children:"camelCase"}),"\n",(0,i.jsx)(n.p,{children:"Reason: the Spec"}),"\n",(0,i.jsx)(n.h2,{id:"executable-documents",children:"Executable documents"}),"\n",(0,i.jsx)(n.p,{children:'A GraphQL "executable document" (the document in a GraphQL request, often\nimprecisely referred to as a "query") generally uses the names defined in the\nschema, but it also defines a number of types of named entities:'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"operation names"}),"\n",(0,i.jsx)(n.li,{children:"fragment names"}),"\n",(0,i.jsx)(n.li,{children:"aliases"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"operation-names",children:"Operation names"}),"\n",(0,i.jsxs)(n.p,{children:["e.g. in the Spec one example document is ",(0,i.jsx)(n.code,{children:"query getDogName { dog { name } }"}),";\nthe operation name in this is ",(0,i.jsx)(n.code,{children:"getDogName"}),". Operation names are optional."]}),"\n",(0,i.jsx)(n.h4,{id:"camelcase-4",children:"camelCase"}),"\n",(0,i.jsxs)(n.p,{children:["The Spec uses a mixture of ",(0,i.jsx)(n.code,{children:"camelCase"})," and ",(0,i.jsx)(n.code,{children:"UpperCamelCase"})," for operation names,\nbut there are significantly more examples using ",(0,i.jsx)(n.code,{children:"camelCase"})," than\n",(0,i.jsx)(n.code,{children:"UpperCamelCase"}),", so that's what we recommend."]}),"\n",(0,i.jsx)(n.p,{children:"Reason: the Spec"}),"\n",(0,i.jsx)(n.h3,{id:"fragments",children:"Fragments"}),"\n",(0,i.jsxs)(n.p,{children:["One ",(0,i.jsx)(n.a,{href:"https://spec.graphql.org/draft/#example-80138",children:"example"})," in the Spec:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"fragment userFragment on User {\n  friends {\n    count\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"camelcase-or-whatever",children:"camelCase (or whatever)"}),"\n",(0,i.jsx)(n.p,{children:"This one is a little controversial."}),"\n",(0,i.jsxs)(n.p,{children:["In the April 20th 2023 Spec WG ",(0,i.jsx)(n.a,{href:"https://youtu.be/Dk7zQA0bUVc?t=539",children:"I asked Lee"}),"\nwhy camelCase was generally used in the spec for naming fragments. Lee said:"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"CapitalCase/PascalCase was a reserved space for types \u2014 if I see\nsomething in PascalCase I default to assuming it's a type in the schema, if I\nsee something camelCase I assume it's something other than that. Obviously,\nthe convention for field names and argument names and variable names is all\ncamel case. Fragment names are a little bit in an in\u2013between space\nthere. Made sense to me to treat them more similarly to a field than more\nsimilarly to a type."}),"\n",(0,i.jsxs)(n.p,{children:["-- ",(0,i.jsx)(n.a,{href:"https://youtu.be/Dk7zQA0bUVc?t=539",children:"https://youtu.be/Dk7zQA0bUVc?t=539"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"There's actually a mixture of naming for fragments in the spec, some use\nUpperCamelCase but the majority use camelCase."}),"\n",(0,i.jsx)(n.p,{children:"It's worth noting that Relay requires that fragment names start with the name of\nthe file in which they're defined."}),"\n",(0,i.jsx)(n.p,{children:"You should use whatever your team wants to use; but if in doubt then the spec\nleans towards camelCase."}),"\n",(0,i.jsx)(n.p,{children:"Reason: the Spec."}),"\n",(0,i.jsx)(n.h3,{id:"aliases",children:"Aliases"}),"\n",(0,i.jsx)(n.h4,{id:"camelcase-5",children:"camelCase"}),"\n",(0,i.jsx)(n.p,{children:"Aliases are just different names for fields, generally they should use the same\nnaming convention as fields unless you have a good reason (e.g. you're trying to\nmatch some external data format)."}),"\n",(0,i.jsx)(n.h4,{id:"short",children:"Short"}),"\n",(0,i.jsx)(n.p,{children:"Aliases have three main purposes:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Abbreviating long field names (e.g. ",(0,i.jsx)(n.code,{children:"fullName"})," -> ",(0,i.jsx)(n.code,{children:"name"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["Allowing you to reference the same field twice with different parameters\n(e.g. ",(0,i.jsx)(n.code,{children:"smallPic: profilePic(size: 64), bigPic: profilePic(size: 1024)"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["Clarifying intent (e.g. ",(0,i.jsx)(n.code,{children:"nodes"})," -> ",(0,i.jsx)(n.code,{children:"people"}),")"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In all cases, the alias you use should be short. Using too many aliases, or\naliases that are too long, may trigger a server's security protections."}),"\n",(0,i.jsx)(n.h2,{id:"extra-research",children:"Extra research"}),"\n",(0,i.jsx)(n.h3,{id:"example-schema",children:"Example schema"}),"\n",(0,i.jsxs)(n.p,{children:["The Spec contains\n",(0,i.jsx)(n.a,{href:"https://spec.graphql.org/draft/#example-8b4ff",children:"this example schema"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"type Query {\n  dog: Dog\n  findDog(searchBy: FindDogInput): Dog\n}\n\nenum DogCommand {\n  SIT\n  DOWN\n  HEEL\n}\n\ntype Dog implements Pet {\n  name: String!\n  nickname: String\n  barkVolume: Int\n  doesKnowCommand(dogCommand: DogCommand!): Boolean!\n  isHouseTrained(atOtherHomes: Boolean): Boolean!\n  owner: Human\n}\n\ninterface Sentient {\n  name: String!\n}\n\ninterface Pet {\n  name: String!\n}\n\ntype Alien implements Sentient {\n  name: String!\n  homePlanet: String\n}\n\ntype Human implements Sentient {\n  name: String!\n  pets: [Pet!]\n}\n\nenum CatCommand {\n  JUMP\n}\n\ntype Cat implements Pet {\n  name: String!\n  nickname: String\n  doesKnowCommand(catCommand: CatCommand!): Boolean!\n  meowVolume: Int\n}\n\nunion CatOrDog = Cat | Dog\nunion DogOrHuman = Dog | Human\nunion HumanOrAlien = Human | Alien\n\ninput FindDogInput {\n  name: String\n  owner: String\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"other-graphql-naming-guides",children:"Other GraphQL naming guides"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.apollographql.com/docs/technotes/TN0002-schema-naming-conventions/",children:"https://www.apollographql.com/docs/technotes/TN0002-schema-naming-conventions/"})}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},4664:(e,n,s)=>{s.d(n,{Z:()=>t});s(7294);const i="pullquote_fEhA";var a=s(5893);const t=e=>{let{children:n}=e;return(0,a.jsx)("aside",{className:i,children:(0,a.jsx)("blockquote",{children:n})})}},768:(e,n,s)=>{s.d(n,{u:()=>l});s(7294);const i="tldr_fcon",a="inner_JkE_";var t=s(5893);const l=e=>{let{children:n}=e;return(0,t.jsx)("aside",{className:i,children:(0,t.jsx)("div",{className:a,children:n})})}},1151:(e,n,s)=>{s.d(n,{Z:()=>r,a:()=>l});var i=s(7294);const a={},t=i.createContext(a);function l(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);