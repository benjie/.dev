"use strict";(self.webpackChunk_localrepo_benjie_dev=self.webpackChunk_localrepo_benjie_dev||[]).push([[284],{1304:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var i=t(5893),s=t(1151);const r={identifier:"395",title:"inputUnion type",stage:"1",champion:"tgriesser",prUrl:"https://github.com/graphql/graphql-spec/pull/395",events:[{type:"prCreated",date:new Date("2018-01-11T20:12:37.000Z"),href:"https://github.com/graphql/graphql-spec/pull/395",actor:"tgriesser"},{type:"commitsPushed",date:new Date("2018-01-11T00:00:00.000Z"),href:"https://github.com/graphql/graphql-spec/commit/543f1fbe34dde748f2f8dc96d809b258c40b4097",actor:"tgriesser",commits:[{href:"https://github.com/graphql/graphql-spec/commit/543f1fbe34dde748f2f8dc96d809b258c40b4097",headline:"RFC: inputUnion type",ghUser:"tgriesser",authorName:"Tim Griesser"}]}],related:"586, InputUnion",shortname:"inputUnion type",image:"/img/rfc_tracker.png",closedAt:new Date("2019-11-05T22:42:15.000Z")},o=void 0,l={id:"395",title:"inputUnion type",description:"At a glance",source:"@site/rfcs/395.md",sourceDirName:".",slug:"/395",permalink:"/rfcs/395",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{identifier:"395",title:"inputUnion type",stage:"1",champion:"tgriesser",prUrl:"https://github.com/graphql/graphql-spec/pull/395",events:[{type:"prCreated",date:"2018-01-11T20:12:37.000Z",href:"https://github.com/graphql/graphql-spec/pull/395",actor:"tgriesser"},{type:"commitsPushed",date:"2018-01-11T00:00:00.000Z",href:"https://github.com/graphql/graphql-spec/commit/543f1fbe34dde748f2f8dc96d809b258c40b4097",actor:"tgriesser",commits:[{href:"https://github.com/graphql/graphql-spec/commit/543f1fbe34dde748f2f8dc96d809b258c40b4097",headline:"RFC: inputUnion type",ghUser:"tgriesser",authorName:"Tim Griesser"}]}],related:"586, InputUnion",shortname:"inputUnion type",image:"/img/rfc_tracker.png",closedAt:"2019-11-05T22:42:15.000Z"},sidebar:"rfcsSidebar",previous:{title:"Tagged type",permalink:"/rfcs/733"},next:{title:"GraphQL Subscriptions should handle errors in the source stream",permalink:"/rfcs/1126"}},a={},c=[{value:"At a glance",id:"at-a-glance",level:2},{value:"Timeline",id:"timeline",level:2},{value:"Checklist:",id:"checklist",level:3},{value:"Are we solving a real problem.",id:"are-we-solving-a-real-problem",level:4},{value:"Does this enable new use cases.",id:"does-this-enable-new-use-cases",level:4},{value:"How common is this use case.",id:"how-common-is-this-use-case",level:4},{value:"Can we enable it without a change to GraphQL.",id:"can-we-enable-it-without-a-change-to-graphql",level:4},{value:"Additional thoughts",id:"additional-thoughts",level:3},{value:"Open questions:",id:"open-questions",level:3}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"at-a-glance",children:"At a glance"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Identifier"}),": #395"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stage"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md#stage-x-rejected",children:"RFCX: Closed"})," 2019-11-05T22:42:15Z"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Champion"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/tgriesser",children:"@tgriesser"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"PR"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/pull/395",children:"inputUnion type"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Related"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/rfcs/586",title:"Input Objects accepting exactly @oneField / RFCX",children:"#586"})," (Input Objects accepting exactly @oneField)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/rfcs/InputUnion",title:"GraphQL Input Union / RFC0",children:"InputUnion"})," (GraphQL Input Union)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"timeline",children:"Timeline"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/pull/395",children:"Spec PR"})," created"]})," on 2018-01-11 by tgriesser"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Commit pushed"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/commit/543f1fbe34dde748f2f8dc96d809b258c40b4097",children:"RFC: inputUnion type"})," on 2018-01-11 by ",(0,i.jsx)(n.a,{href:"https://github.com/tgriesser",children:"@tgriesser"})]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Related graphql-js PR: graphql/graphql-js#1196"}),"\n",(0,i.jsxs)(n.p,{children:["This is an RFC for a new type: ",(0,i.jsx)(n.code,{children:"inputUnion"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["An ",(0,i.jsx)(n.code,{children:"inputUnion"})," is a union of one or more ",(0,i.jsx)(n.code,{children:"input"})," types. It may be used in any location where an ",(0,i.jsx)(n.code,{children:"input"})," is currently valid. When fulfilling an ",(0,i.jsx)(n.code,{children:"inputUnion"})," an additional field ",(0,i.jsx)(n.code,{children:"__inputname"})," must be specified in the map/object fulfilling the input, where the value of ",(0,i.jsx)(n.code,{children:"__inputname"})," is the name of a single member of the ",(0,i.jsx)(n.code,{children:"inputUnion"})," being fulfilled."]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"input PostInput {\n  title: String!\n  body: String!\n}\ninput ImageInput {\n  photo: String!\n  caption: String\n}\n\ninputUnion MediaBlock = PostInput | ImageInput\n\ntype Mutation {\n   addContent(content: [MediaBlock]!): Post   \n}\n\nmutation AddContent($content: [MediaBlock]!) {\n   addContent(content: $content) {\n      id\n   }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Valid ",(0,i.jsx)(n.code,{children:"$content"})," value:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'[\n  {__inputname: "PostInput", title: "Hello", content: "World"},\n  {__inputname: "ImageInput", photo: "http://graphql.org/img/logo.svg", caption: "Logo"}\n]\n'})}),"\n",(0,i.jsx)(n.p,{children:"Invalid Value Examples:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'{__inputname: "PostInput", title: "Invalid, missing \'content\'"}\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'{title: "Invalid, missing __inputname", content: "World"}\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'{\n  __inputname: "PostInput", \n  title: "Invalid, photo is not defined on PostInput", \n  content: "World", \n  photo: "http://graphql.org/img/logo.svg"\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"checklist",children:"Checklist:"}),"\n",(0,i.jsx)(n.h4,{id:"are-we-solving-a-real-problem",children:"Are we solving a real problem."}),"\n",(0,i.jsx)(n.p,{children:"Yes. Many of these problems or use cases are laid out in graphql/graphql-js#207 but to summarize:"}),"\n",(0,i.jsx)(n.p,{children:"When creating input objects, both in mutations and queries you face a tradeoff when creating complex input structs, with one of two options:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Enforce a well typed structure of the input via required fields ",(0,i.jsx)(n.code,{children:"!"}),". Create multiple endpoints (mutation or query) utilizing these various strict, special case input types."]}),"\n",(0,i.jsx)(n.li,{children:"Loosen the input type requirements and rely on runtime/server-side validation to determine the intended uses."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["This solution aims to offer a third path, where more complex combinations of strict input combinations may be utilized, while still keeping the input types fulfillment unambiguous via the ",(0,i.jsx)(n.code,{children:"__inputname"})," field requirement."]}),"\n",(0,i.jsx)(n.h4,{id:"does-this-enable-new-use-cases",children:"Does this enable new use cases."}),"\n",(0,i.jsxs)(n.p,{children:["Yes. Many of the use cases are detailed in graphql/graphql-js#207. I think the biggest thing this unlocks is the list of heterogeneous inputs, which can be used to define an ordered set of instructions. This also reduces the need for many individual mutations while being able to maintain strictly typed inputs. In my experience tools like ",(0,i.jsx)(n.a,{href:"https://github.com/apollographql/apollo-codegen",children:"apollo-codegen"})," and ",(0,i.jsx)(n.a,{href:"https://github.com/dotansimha/graphql-code-generator",children:"graphql-code-generator"})," have proven invaluable in creating Flow/TypeScript definitions for validating queries. This change will work well in combination with those tools, making complex input semantics simpler to statically check."]}),"\n",(0,i.jsx)(n.h4,{id:"how-common-is-this-use-case",children:"How common is this use case."}),"\n",(0,i.jsx)(n.p,{children:'Very common. This is the most commented issue in graphql-js, and I personally have run into the tradeoff of creating many highly restrictive mutations vs loosening them up and creating an ad-hoc server implementation. This sort of concept feels like the missing corollary to the expressiveness of the graphql Query execution (single "smart" entry point rather than many ad-hoc endpoints).'}),"\n",(0,i.jsx)(n.h4,{id:"can-we-enable-it-without-a-change-to-graphql",children:"Can we enable it without a change to GraphQL."}),"\n",(0,i.jsx)(n.p,{children:"No, at least not without pushing any type-checking semantics to the execution layer."}),"\n",(0,i.jsx)(n.h3,{id:"additional-thoughts",children:"Additional thoughts"}),"\n",(0,i.jsxs)(n.p,{children:["What about ",(0,i.jsx)(n.code,{children:"interfaces"}),"? There are several comments in related tickets expressing a desire for interfaces in addition to input unions. While it sounds nice for symmetry with querying, I don't see these as being useful or necessary in practice at the input layer. Interfaces are most useful when you wish to query for a ",(0,i.jsx)(n.em,{children:"generic partial representation"})," of a more specific type. This same requirement does not exist for inputs and it is my opinion that ",(0,i.jsx)(n.code,{children:"inputInterface"})," would not add enough additional value to justify its addition."]}),"\n",(0,i.jsx)(n.h3,{id:"open-questions",children:"Open questions:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Is the use of ",(0,i.jsx)(n.code,{children:"__inputname"})," a valid option based on spec (__ is reserved for introspection, not sure if we can mirror this for execution)"]}),"\n",(0,i.jsxs)(n.li,{children:["Does ",(0,i.jsx)(n.code,{children:"__inputname"})," make sense as the name for this?"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>l,a:()=>o});var i=t(7294);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);