"use strict";(self.webpackChunk_localrepo_benjie_dev=self.webpackChunk_localrepo_benjie_dev||[]).push([[1150],{3998:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var t=r(5893),i=r(1151);const s={sidebar_position:33,collapsed:!1},o="Modelling Errors",a={id:"graphql/errors",title:"Modelling Errors",description:"There's a lot of discussion about how to model errors in GraphQL, and a lot of",source:"@site/pages/graphql/errors.md",sourceDirName:"graphql",slug:"/graphql/errors",permalink:"/graphql/errors",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:33,frontMatter:{sidebar_position:33,collapsed:!1},sidebar:"defaultSidebar",previous:{title:"Naming Conventions",permalink:"/graphql/naming"},next:{title:"Nullability",permalink:"/graphql/nullability/"}},l={},d=[{value:"Categorising errors",id:"categorising-errors",level:2},{value:"Domain errors",id:"domain-errors",level:3},{value:"Exceptions",id:"exceptions",level:3},{value:"No modelling for exceptions",id:"no-modelling-for-exceptions",level:2},{value:"Domain error general principles",id:"domain-error-general-principles",level:2},{value:"Existence",id:"existence",level:3},{value:"Forbidden access",id:"forbidden-access",level:3},{value:"No side effects in queries",id:"no-side-effects-in-queries",level:3},{value:"No domain errors in queries",id:"no-domain-errors-in-queries",level:3},{value:"Modelling domain errors in mutations",id:"modelling-domain-errors-in-mutations",level:2}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"modelling-errors",children:"Modelling Errors"}),"\n",(0,t.jsx)(n.p,{children:"There's a lot of discussion about how to model errors in GraphQL, and a lot of\ndifferent approaches. Here's my take on it."}),"\n",(0,t.jsx)(n.h2,{id:"categorising-errors",children:"Categorising errors"}),"\n",(0,t.jsx)(n.p,{children:"I find it easiest to think in these terms; there are two broad categories of\nerrors applicable to GraphQL:"}),"\n",(0,t.jsx)(n.h3,{id:"domain-errors",children:"Domain errors"}),"\n",(0,t.jsx)(n.p,{children:"These are things that are part of your business domain logic, for example:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"username is too short"}),"\n",(0,t.jsx)(n.li,{children:"email address is already registered"}),"\n",(0,t.jsx)(n.li,{children:"you don't have enough credits to create that"}),"\n",(0,t.jsx)(n.li,{children:"you must be logged in to do that"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"arguably"})," rate limiting errors for non-malicious actors"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:'In most cases, domain errors are "non-recoverable" - the user must take some\naction to fix the problem in their request.'}),"\n",(0,t.jsx)(n.h3,{id:"exceptions",children:"Exceptions"}),"\n",(0,t.jsxs)(n.p,{children:["Essentially exceptions are everything that isn't a domain error: things that you\nwouldn't generally ",(0,t.jsx)(n.em,{children:"expect"})," to happen, like ",(0,t.jsx)(n.code,{children:"us-east-1"})," going down [/irony]."]}),"\n",(0,t.jsx)(n.p,{children:"Typically exceptions are things that, in a perfect world (bug-free technology,\ninfinitely scalable, zero cost, latency was zero, no bad actors existed, and\nuser requests were serialized) would not happen:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"network errors"}),"\n",(0,t.jsx)(n.li,{children:"storage errors"}),"\n",(0,t.jsx)(n.li,{children:"order-of-operations errors (deadlocks, transaction conflicts, etc)"}),"\n",(0,t.jsx)(n.li,{children:"service errors (e.g. microservice crashed)"}),"\n",(0,t.jsxs)(n.li,{children:["rate limiting errors (",(0,t.jsx)(n.em,{children:"arguably"})," just for malicious actors)"]}),"\n",(0,t.jsx)(n.li,{children:"etc"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:'In most cases, exceptions are "recoverable" - temporary failure, retry in a few\nhours time.'}),"\n",(0,t.jsx)(n.h2,{id:"no-modelling-for-exceptions",children:"No modelling for exceptions"}),"\n",(0,t.jsx)(n.p,{children:"In my opinion, exceptions should not be modelled in the schema - there's way too\nmany types of them, and they can happen basically anywhere. Adding them to the\nschema would add a lot of noise, would require frontend developers to put in a\nlot of boilerplate code to handle them all, and would slow down time to market\nwithout delivering significant value. Users don't typically care why it went\nwrong, they just care whether it's their fault or not, and if not when they\nshould try again."}),"\n",(0,t.jsxs)(n.p,{children:["Instead, exceptions should be handled through standard GraphQL error handling.\nDevelopers should make use of the ",(0,t.jsx)(n.code,{children:"extensions"})," property to indicate common\ninformation that's useful for the error page:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A specific ",(0,t.jsx)(n.code,{children:"errorCode"})," that uniquely identifies the error"]}),"\n",(0,t.jsxs)(n.li,{children:["An error category that indicates the type of failure (this may be a prefix of\nthe ",(0,t.jsx)(n.code,{children:"errorCode"}),", or indicated separately)"]}),"\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.code,{children:"retryAfter"})," timestamp or duration indicating when a good time to retry\nwould be"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The GraphQL client (Relay, Apollo Client, URQL, gql.tada, Graffle, GraphQL-TOE +\nwindow.fetch, etc) should ensure that errors are suitably represented in the\nresponse fed to application code. There are a number of options for this:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["application developers can indicate specifically where and how in the\nresponse errors should be handled via\n",(0,t.jsxs)(n.a,{href:"https://relay.dev/docs/guides/catch-directive/",children:["a ",(0,t.jsx)(n.code,{children:"@catch"})," directive"]}),", for\nexample via a ",(0,t.jsx)(n.code,{children:"Result"})," type where error or not is explicitly checked to\naccess the underlying data"]}),"\n",(0,t.jsxs)(n.li,{children:["the GraphQL client can throw the error when the application code attempts to read\nfrom an errored field (for example, using\n",(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/graphql-toe",children:"GraphQL Throw On Error"}),"), and\napplication code can handle errors with traditional ",(0,t.jsx)(n.code,{children:"try"}),"/",(0,t.jsx)(n.code,{children:"catch"})," or\n",(0,t.jsx)(n.code,{children:"<ErrorBoundary />"})," patterns."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Either way, the application should render a generic error details page about the\nerror, using the ",(0,t.jsx)(n.code,{children:"extensions"})," property to guide them."]}),"\n",(0,t.jsx)(n.h2,{id:"domain-error-general-principles",children:"Domain error general principles"}),"\n",(0,t.jsx)(n.p,{children:"This is where things get a bit more nuanced. Let's start by thinking about some\ngeneral principles:"}),"\n",(0,t.jsx)(n.h3,{id:"existence",children:"Existence"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"null"}),' means "does not exist".']}),"\n",(0,t.jsxs)(n.p,{children:["If you request some data through GraphQL, and that data does not exist, then the\nGraphQL schema should return ",(0,t.jsx)(n.code,{children:"null"}),", not an error, since ",(0,t.jsx)(n.code,{children:"null"})," already means\nthe data does not exist."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Requested data not existing is not an error."})," Most things you can imagine\ndon't exist."]}),"\n",(0,t.jsx)(n.h3,{id:"forbidden-access",children:"Forbidden access"}),"\n",(0,t.jsxs)(n.p,{children:['Telling someone "this exists, but you\'re not allowed to see it" and "this does\nnot exist ',(0,t.jsx)(n.em,{children:"in the set of things you're allowed to see"}),'" are two different\nthings. The first reveals the existence of the thing, the latter does not say\none way or the other whether it actually exists or not.']}),"\n",(0,t.jsxs)(n.p,{children:["From a security/privacy perspective, it's preferred to reveal as little as\npossible about things that a user is not permitted to know about, including\nwhether or not they exist. Thus I subscribe to the idea that ",(0,t.jsx)(n.code,{children:"403 Forbidden"}),"\nshould not be used for data access unless ",(0,t.jsx)(n.em,{children:"all"})," instances of that resource\n(extant or not) are forbidden to the user. Instead, ",(0,t.jsx)(n.code,{children:"404 Not Found"})," should be\nused to indicate that the resource does not exist within the set of things the\nuser is allowed to see."]}),"\n",(0,t.jsx)(n.p,{children:"Take GitHub for example:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/graphql/tsc",children:"https://github.com/graphql/tsc"})," - if you're a GraphQL TSC member (and logged in\nto GitHub) you'll be able to see this repository, but otherwise it will render\nas a 404 Not Found page."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/benjie/world-domination-plan",children:"https://github.com/benjie/world-domination-plan"})," - this repository may or may\nnot exist, and you'll never know unless I reveal it"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Thus:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:["Requests to data you are not permitted to access should be equivalent to the\ndata not existing - the data ",(0,t.jsx)(n.em,{children:"does not exist in the set of things you're allowed\nto see"}),"."]})," (If you request a single item you're not allowed to see, GraphQL\nshould return ",(0,t.jsx)(n.code,{children:"null"}),". If you're requesting a list of things and some of them\nyou're not allowed to see, the list should ",(0,t.jsx)(n.em,{children:"skip over"})," those items. If you're\nnot allowed to see any of them, you get an empty list.)"]}),"\n",(0,t.jsx)(n.h3,{id:"no-side-effects-in-queries",children:"No side effects in queries"}),"\n",(0,t.jsx)(n.p,{children:"The GraphQL specification states (emphasis mine):"}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Because ",(0,t.jsx)(n.strong,{children:"the resolution of fields other than top-level mutation fields must\nalways be side effect-free and idempotent"}),", the execution order must not\naffect the result, and hence the service has the freedom to execute the field\nentries in whatever order it deems optimal."]}),"\n"]}),(0,t.jsx)("figcaption",{children:(0,t.jsx)("a",{href:"https://spec.graphql.org/draft/#sel-GANVLDCB2BBiKn6D",children:"6.3.4 Normal and Serial Execution"})})]}),"\n",(0,t.jsx)(n.p,{children:"Queries must be side-effect free and idempotent."}),"\n",(0,t.jsx)(n.p,{children:'That means, for example, that simply accessing a value should not change\nanything. So you cannot have fields that have a limited number of accesses in a\nquery (for example "read this article three times then it\'s forbidden") - if you\nneed a side-effect like this then this access must be modelled as a mutation to\nbe GraphQL compliant.'}),"\n",(0,t.jsx)(n.p,{children:"This is actually pretty critical for doing GraphQL well - applications should be able\nto refetch data at will, with fragments that describe their data requirements,\nand not need to keep count of how many times they've accessed something."}),"\n",(0,t.jsx)(n.h3,{id:"no-domain-errors-in-queries",children:"No domain errors in queries"}),"\n",(0,t.jsx)(n.p,{children:"Combining the above principles, we can conclude that it's very unlikely that\ndomain errors should ever be returned from queries. And since the only remaining\nerrors are exceptions, and these should not be modelled in the schema, query\nfields should never contain error types modelled in the schema. (Similar logic\napplies to subscriptions.)"}),"\n",(0,t.jsxs)(n.p,{children:["Thus, the ",(0,t.jsx)(n.em,{children:"only"})," place where we need to consider modelling errors in the schema\nis in mutations."]}),"\n",(0,t.jsx)(n.h2,{id:"modelling-domain-errors-in-mutations",children:"Modelling domain errors in mutations"}),"\n",(0,t.jsx)(n.p,{children:"So now we've limited our scope to mutation fields only, our job is much simpler!"}),"\n",(0,t.jsx)(n.p,{children:"We have essentially three choices:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Handle domain errors the same way as we would exceptions"}),"\n",(0,t.jsx)(n.li,{children:"Model domain errors as mutation fields returning a union type"}),"\n",(0,t.jsx)(n.li,{children:"Model domain errors as a list on the mutation result payload"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Option 1 is simple and Just Works (we already have exception handling code!);\nbut is not very helpful for users of our application. Domain errors typically\ninclude information that users can act on to fix their request, so it's better\nto outline to the application which types of errors are expected, so that they\ncan be handled explicitly."}),"\n",(0,t.jsx)(n.p,{children:"Option 2 makes it explicit what errors are expected, but stops as soon as the\nfirst error occurs. This isn't ideal for helping the user fix the form they were\nsubmitting:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'Server: "that username is already in use"'}),"\n",(0,t.jsxs)(n.li,{children:["Them: ",(0,t.jsx)(n.em,{children:"fix and submit"})]}),"\n",(0,t.jsx)(n.li,{children:'Server: "that email address is invalid"'}),"\n",(0,t.jsxs)(n.li,{children:["Them: ",(0,t.jsx)(n.em,{children:"fix and submit"})]}),"\n",(0,t.jsx)(n.li,{children:'Server: "you have not agreed to the terms of service"'}),"\n",(0,t.jsxs)(n.li,{children:["Them: ",(0,t.jsx)(n.em,{children:"fix and submit"})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Instead, all errors should be returned at once, so the user can fix them all in\none go."}),"\n",(0,t.jsxs)(n.p,{children:["We could encompass all of these errors into an aggregate error type\n(",(0,t.jsx)(n.code,{children:"AggregateValidationError"})," with ",(0,t.jsx)(n.code,{children:"errors: [ValidationError!]!"}),"), but not all the\nerrors are necessarily validation errors... There might be validation errors\n",(0,t.jsx)(n.em,{children:"and"})," they have insufficient balance. Go too far down this route, and you start\nreusing massive error types, and this becomes less useful to the application\ndevelopers again."]}),"\n",(0,t.jsxs)(n.p,{children:["Further, maybe we ",(0,t.jsx)(n.em,{children:"did"}),' perform the mutation, but there was a non-fatal error\nthat happened that maybe the user has to deal with (e.g. "we created your\naccount, but we had to change your username due to a conflict").']}),"\n",(0,t.jsxs)(n.p,{children:["Option 3 contains a list of errors (using a mutation-specific error union), and\nlets you indicate separately the result of the mutation. This is my preferred\noption. It also has the advantage that anyone following\n",(0,t.jsx)(n.a,{href:"https://www.apollographql.com/blog/designing-graphql-mutations",children:"solid mutation design advice"}),"\ncan integrate it into existing schemas without a breaking change."]})]})}function c(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},1151:(e,n,r)=>{r.d(n,{Z:()=>a,a:()=>o});var t=r(7294);const i={},s=t.createContext(i);function o(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);