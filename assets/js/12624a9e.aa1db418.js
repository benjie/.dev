"use strict";(self.webpackChunk_localrepo_benjie_dev=self.webpackChunk_localrepo_benjie_dev||[]).push([[8257],{8354:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>d});var i=t(5893),s=t(1151),r=t(4664);t(768);const a={type:"page",title:"GraphQL Security",description:"Techniques to protect your GraphQL API.",tag:"graphql",author:"Benjie",breadcrumb:!1,sidebar_position:10},o="Protecting your GraphQL API",l={id:"graphql/security",title:"GraphQL Security",description:"Techniques to protect your GraphQL API.",source:"@site/pages/graphql/security.mdx",sourceDirName:"graphql",slug:"/graphql/security",permalink:"/graphql/security",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:10,frontMatter:{type:"page",title:"GraphQL Security",description:"Techniques to protect your GraphQL API.",tag:"graphql",author:"Benjie",breadcrumb:!1,sidebar_position:10},sidebar:"defaultSidebar",previous:{title:"GraphQL",permalink:"/graphql/"},next:{title:"Trusted Documents",permalink:"/graphql/trusted-documents"}},c={},d=[{value:"Rejecting malicious documents",id:"rejecting-malicious-documents",level:2},{value:"Trusted documents",id:"trusted-documents",level:3},{value:"Custom validation rules",id:"custom-validation-rules",level:3},{value:"Depth limit",id:"depth-limit",level:4},{value:"List depth limit",id:"list-depth-limit",level:4},{value:"Self-referential limits",id:"self-referential-limits",level:4},{value:"Alias limits",id:"alias-limits",level:3},{value:"More resources",id:"more-resources",level:3},{value:"Rejecting malicious requests",id:"rejecting-malicious-requests",level:2},{value:"Pagination limits",id:"pagination-limits",level:3},{value:"Query cost analysis",id:"query-cost-analysis",level:3},{value:"Beware: GraphQL bombs",id:"beware-graphql-bombs",level:3},{value:"<code>multipart/form-data</code> and <code>application/x-www-form-urlencoded</code>",id:"multipartform-data-and-applicationx-www-form-urlencoded",level:3},{value:"Protecting validation",id:"protecting-validation",level:2},{value:"Limit validation errors",id:"limit-validation-errors",level:3},{value:"Size and token limits",id:"size-and-token-limits",level:3},{value:"Validation timeout",id:"validation-timeout",level:3},{value:"Protecting runtime",id:"protecting-runtime",level:2},{value:"Timeouts",id:"timeouts",level:3},{value:"Cancellation token",id:"cancellation-token",level:3},{value:"Rate limiting",id:"rate-limiting",level:3},{value:"Runtime errors",id:"runtime-errors",level:3},{value:"General resources",id:"general-resources",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"protecting-your-graphql-api",children:"Protecting your GraphQL API"}),"\n",(0,i.jsxs)(n.p,{children:["The security practices you invoke for protecting your GraphQL API will differ\ndepending on how you expose it and how you intend it to be consumed. GraphQL is\nnot tied to any particular transport, in fact it does not need a transport at\nall \u2014 it's fairly common to consume GraphQL directly via a local function\ncall within your application's memory space. That said, the majority of GraphQL\nschemas are exposed over a network, most commonly over HTTP as specified by the\n",(0,i.jsx)(n.a,{href:"https://graphql.github.io/graphql-over-http/draft/",children:"GraphQL-over-HTTP specification"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"This page aims to outline some of the techniques and concerns you should\nconsider when protecting your GraphQL-over-HTTP API from malicious traffic. It\nis not exhaustive, and it does not cover the standard best practices that would\napply to any HTTP API whether it's GraphQL, REST, gRPC, SOAP, or anything else\n\u2014 instead it focusses only on GraphQL-specific topics."}),"\n",(0,i.jsx)(n.h2,{id:"rejecting-malicious-documents",children:"Rejecting malicious documents"}),"\n",(0,i.jsx)(r.Z,{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Protecting"})," your servers ",(0,i.jsx)(n.strong,{children:"against malicious queries"})," is one of the key\nconcerns of GraphQL security"]})}),"\n",(0,i.jsx)(n.p,{children:"Though GraphQL's query language acts as a well defined security boundary between\nthe client and your business logic, the language itself can enable asymmetric\nattacks \u2014 without much effort, malicious actors can issue requests for the\nserver to perform large amounts of work. This can be leveraged to perform denial\nof service attacks."}),"\n",(0,i.jsx)(n.p,{children:"Therefore, protecting your servers against malicious queries is one of the key\nconcerns of GraphQL security."}),"\n",(0,i.jsx)(n.h3,{id:"trusted-documents",children:"Trusted documents"}),"\n",(0,i.jsxs)(n.p,{children:["The simplest way to protect against malicious documents is to only allow\npre-approved documents that you are sure are not malicious. This technique is\nonly suitable where you can know the required documents ahead of time, but this\nis fortunately the case for the vast majority of APIs since they are only\ndesigned to power the organization's own applications (web apps, mobile apps,\ndesktop apps and so on). Public APIs intended to receive arbitrary third party\nqueries, for example the\n",(0,i.jsx)(n.a,{href:"https://docs.github.com/en/graphql",children:"GitHub GraphQL API"}),", can sadly not use this\ntechnique for all requests \u2014 though it can still be used for first-party\napplications, third-party requests will require additional checks."]}),"\n",(0,i.jsx)(r.Z,{children:(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"If you can use trusted documents, you should!"})})}),"\n",(0,i.jsxs)(n.p,{children:["If you can ",(0,i.jsx)(n.a,{href:"/graphql/trusted-documents",children:(0,i.jsx)(n.strong,{children:"use trusted documents"})}),", you should!\nThey are a powerful technique that protects your GraphQL API against a certain\nclass of known and unknown threats. We've written about this highly recommended\nsecurity technique in detail in the\n",(0,i.jsx)(n.a,{href:"/graphql/trusted-documents",children:"GraphQL Trusted Documents page"})," page."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/graphql/trusted-documents",children:(0,i.jsx)(n.img,{alt:"Trusted Documents: if you can, you should!",src:t(7138).Z+"",width:"1024",height:"1024"})})}),"\n",(0,i.jsx)(n.h3,{id:"custom-validation-rules",children:"Custom validation rules"}),"\n",(0,i.jsx)(n.p,{children:"The GraphQL specification details standard validation rules, but most servers\nwill allow you to add your own custom validation rules above and beyond these."}),"\n",(0,i.jsx)(n.p,{children:"Normally validation applies only to documents and does not factor in variables,\nso we'll concentrate on these document-only validation rules for now. In the\n\"malicious requests\" section below we'll talk about validation rules that also\nfactor in variable values."}),"\n",(0,i.jsx)(n.h4,{id:"depth-limit",children:"Depth limit"}),"\n",(0,i.jsx)(n.p,{children:'A depth limit is a basic protection that throws out documents that attempt to\nquery "too deep" into your schema. GraphQL execution operates on a\nlayer-by-layer basis, and this rule limits the number of layers involved.'}),"\n",(0,i.jsx)(n.p,{children:"What limits you apply are dependent on your schema and your clients needs but\nit's common to see legitimate GraphQL queries that are 12 or more levels deep -\nfor example the standard GraphQL introspection query used by GraphiQL is 14\nlevels deep. It's generally best to start with a low limit and increase it if\nyou need to, and to use a separate limit for introspection:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"maxDepth: 12\nmaxIntrospectionDepth: 14\n"})}),"\n",(0,i.jsxs)(n.p,{children:["It's not uncommon to need to increase ",(0,i.jsx)(n.code,{children:"maxDepth"})," into the twenties, so simple\ndepth limiting is a fairly limited protection in itself but at least rules out\nthe very worst offenders."]}),"\n",(0,i.jsx)(r.Z,{children:(0,i.jsxs)(n.p,{children:["Simple ",(0,i.jsx)(n.strong,{children:"depth limiting"})," is a fairly ",(0,i.jsx)(n.strong,{children:"limited protection"})]})}),"\n",(0,i.jsx)(n.h4,{id:"list-depth-limit",children:"List depth limit"}),"\n",(0,i.jsx)(n.p,{children:"Though it's fairly common to have legitimate GraphQL queries that are quite\ndeep, it's rare to see clients legitimately query lists in GraphQL more than 2\nlevels deep because past that pagination becomes a real struggle! Lists are also\nmuch more dangerous since they can cause an exponential growth in the complexity\nof the request - rather than just adding another layer as would be the case with\nan object field, they add a layer that must be executed N times, once for each\nreturned item in the list."}),"\n",(0,i.jsx)(r.Z,{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"list depth limiting"})," is a ",(0,i.jsx)(n.strong,{children:"vital mitigation"})," against ",(0,i.jsx)(n.strong,{children:"exponential"}),"\nworkloads from bad actors exploiting ",(0,i.jsx)(n.strong,{children:"cycles"})," in your graph"]})}),"\n",(0,i.jsx)(n.p,{children:"Consider a GraphQL API representing a film database; and imagine that each film\nwithin it has an average cast size of 100, each actor has on average 2 children,\neach of these children act in on average 20 films (it's all about who you\nknow!), and each film has on average 100 crew. A simple query like this that is\nonly 5 levels deep could already be requesting in the order of 40 million\nrecords (many of which will be repeated records), with minimal effort from the\nclient. Even if the server can fetch this highly-redundant data efficiently,\nserializing it to send over the wire is still a significant amount of effort\n(and memory usage)!"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"{\n  allFilms(first: 100) {\n    # 100 films\n    cast {\n      # 100 * 100 cast\n      children {\n        # 100 * 100 * 2 children\n        films {\n          # 100 * 100 * 2 * 20 films\n          crew {\n            # 100 * 100 * 2 * 20 * 100 crew = 40,000,000 nodes!\n            name\n          }\n        }\n      }\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Therefore list depth limiting is a vital mitigation, preventing bad actors from\nexploiting cycles in your graph to have your server perform exponentially\ngrowing workloads. Prevent all documents from querying lists any deeper than you\nspecifically need; start with a low limit on list nesting, and increase it if\nyou need to."}),"\n",(0,i.jsxs)(n.p,{children:["Introspection has slightly different needs here (we want to exhaustively know\neverything about the schema, which involves querying\n",(0,i.jsx)(n.code,{children:"__schema>types>fields>args"})," - three levels of lists), but because it's entirely\nsynchronous we can use a larger limit:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"maxListDepth: 2\nmaxIntrospectionListDepth: 3\n"})}),"\n",(0,i.jsx)(n.h4,{id:"self-referential-limits",children:"Self-referential limits"}),"\n",(0,i.jsx)(r.Z,{children:(0,i.jsxs)(n.p,{children:["attackers can abuse the ",(0,i.jsx)(n.strong,{children:"cycles"})," in your graph"]})}),"\n",(0,i.jsx)(n.p,{children:"GraphQL schemas tend to contain loads of cycles, and attackers can abuse the\ncycles in your graph to request the server perform excessively large amounts of\nwork. It's best to start with a base line of not allowing the same field to be\nrequested inside of its own selection sets (directly or transitively):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"maxSelfReferentialDepth: 1\nmaxIntrospectionSelfReferentialDepth: 1\n"})}),"\n",(0,i.jsxs)(n.p,{children:["However, it's vital to note that there will be fields where self-references are\nreasonable. For example in the graphql.js introspection query\n",(0,i.jsxs)(n.a,{href:"https://github.com/graphql/graphql-js/blob/9a91e338101b94fb1cc5669dd00e1ba15e0f21b3/src/utilities/getIntrospectionQuery.ts#L140-L179",children:[(0,i.jsx)(n.code,{children:"ofType"})," is queried 9 levels deep"]}),'.\nOther examples of legitimate self-referential queries include "friends of\nfriends" in a social networking API, or following the maternal or paternal line\nbackwards in a genealogy API\n(',(0,i.jsx)(n.code,{children:"person { mother { mother { mother { mother { name } } } } }"}),"). Thus it's\nimportant when creating self-referential limits to ensure that these exceptions\ncan be specifically allowed:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'"__Type.ofType": 9\n"User.friends": 2\n"Person.mother": 8\n"Person.father": 8\n'})}),"\n",(0,i.jsx)(n.p,{children:"For introspection overrides, I recommend the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'"__Type.ofType": 9\n"__Type.fields": 1\n"__Type.inputFields": 1\n"__Type.interfaces": 1\n"__Type.possibleTypes": 1\n"__Field.args": 1\n"__Field.type": 1\n'})}),"\n",(0,i.jsx)(n.h3,{id:"alias-limits",children:"Alias limits"}),"\n",(0,i.jsx)(n.p,{children:"Sometimes its reasonable for a client to execute a field more than once, with\ndifferent parameters - for example to generate an avatar in two different sizes.\nAnd generally, because GraphQL is a client-focussed language, we want to allow\nclients to rename fields for their own convenience. For these reasons, GraphQL\nallows aliasing of fields."}),"\n",(0,i.jsx)(n.p,{children:"However, this useful feature introduces another attack vector; for example an\nattacker might use aliases to request a server generate an avatar in every\npossible size in order to tie up the servers resources resulting in a denial of\nservice."}),"\n",(0,i.jsx)(n.p,{children:"Limiting the number of aliases a particular field can have is one solution;\nthough you will need overrides to allow for the fields where multiple aliases\nwould be reasonable."}),"\n",(0,i.jsx)(n.p,{children:"It's important to note that every alias a field has causes its resolver and the\nresolvers on all descendents of that field to be called, potentially multiplying\nup the server's workload. Usage of techniques such as DataLoader somewhat\nmitigate this, but it may be best to not allow multiple aliases by default, and\nthen liberally add exceptions where sensible."}),"\n",(0,i.jsx)(n.p,{children:"Some people choose to disable aliases entirely, but I would not recommend this:\nGraphQL is a client-focussed technology and clients often want to rename things\nto make them easier to work with. Some GraphQL clients even rely on the ability\nto alias fields, so disabling aliases would also prevent these clients from\noperating."}),"\n",(0,i.jsx)(n.h3,{id:"more-resources",children:"More resources"}),"\n",(0,i.jsxs)(n.p,{children:["The above options relate to ",(0,i.jsx)(n.a,{href:"https://npmjs.com/package/gqlcheck",children:"gqlcheck"})," which\ncan quickly analyze all your GraphQL documents in parallel with efficient AST\ntraversal, and is pluggable so that additional checks can be easily added. This\nproject started out with the intent of analysing static documents (e.g. during\nyour CI process for checking your trusted documents are relatively safe) but\nwe'll likely add a way of leveraging its rules for runtime validation at some\npoint - if this interests you, please file an issue!"]}),"\n",(0,i.jsxs)(n.p,{children:["Another system I recommend that you run in CI to help your developers write safe\nqueries is ",(0,i.jsx)(n.a,{href:"https://the-guild.dev/graphql/eslint/docs",children:"graphql-eslint"}),"; and\nwhilst we're talking about projects from The Guild you should also check out\nYoga's excellent\n",(0,i.jsx)(n.a,{href:"https://the-guild.dev/graphql/envelop/v3/guides/securing-your-graphql-api",children:"Securing your GraphQL API"}),"\narticle."]}),"\n",(0,i.jsx)(n.h2,{id:"rejecting-malicious-requests",children:"Rejecting malicious requests"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.em,{children:"GraphQL request"})," is composed of the ",(0,i.jsx)(n.em,{children:"document"})," we discussed above, along with\nany runtime values for ",(0,i.jsx)(n.em,{children:"variables"})," and an indication of which ",(0,i.jsx)(n.em,{children:"operation name"}),"\nto execute if the document defines more than one operation."]}),"\n",(0,i.jsxs)(n.p,{children:["Whether or not you use ",(0,i.jsx)(n.a,{href:"/graphql/trusted-documents",children:"Trusted Documents"}),",\nattackers can attempt to supply malicious variable values as an attack vector,\nso it's important to consider how these may be abused."]}),"\n",(0,i.jsx)(n.h3,{id:"pagination-limits",children:"Pagination limits"}),"\n",(0,i.jsx)(r.Z,{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"every"})," collection resolver should enforce ",(0,i.jsx)(n.strong,{children:"pagination limits"})]})}),"\n",(0,i.jsxs)(n.p,{children:["I'm sure you wouldn't want someone to request 10 billion records from one of\nyour collections \u2014 every collection resolver should ",(0,i.jsx)(n.strong,{children:"enforce pagination\nlimits"})," (either directly, or in the business logic it calls) to prevent\nattackers having an easy time. What value to limit to depends on the complexity\nof the field in question including the shape of the data it returns, but common\nlimits include 10, 25, 100 and 500. Beware that large limits multiply by the\nnumber of levels of lists you allow to query, so with a ",(0,i.jsx)(n.code,{children:"maxListDepth"})," of ",(0,i.jsx)(n.code,{children:"3"}),", a\nlimit of ",(0,i.jsx)(n.code,{children:"500"})," for each list could still yield ",(0,i.jsx)(n.code,{children:"500^3 = 125,000,000"})," records!\nDefault to using a low pagination limit (e.g. 25) and only increase it when\nnecessary."]}),"\n",(0,i.jsx)(r.Z,{children:(0,i.jsxs)(n.p,{children:["variable-aware ",(0,i.jsx)(n.strong,{children:"validation rules"})," [...] can throw out requests that exceed\nyour limits before they even start to execute"]})}),"\n",(0,i.jsxs)(n.p,{children:["Limits like these in resolvers require the operation to actually execute for the\nlimit to take effect; by leveraging ",(0,i.jsx)(n.strong,{children:"variable-aware validation rules"})," we can\nenforce consistent pagination limits for every request and throw out requests\nthat exceed your limits before they even start to execute. We can even calculate\nthe maximum number of nodes that would be returned by a request and reject it if\nit's too high (e.g.\n",(0,i.jsx)(n.code,{children:"allFilms(first: 25) { cast(first: 10) { children(first: 10) { ..."})," may be\nallowed since it would return at most 2500 nodes; whereas\n",(0,i.jsx)(n.code,{children:"allFilms(first: 500) { cast(first: 500) { children(first: 500) { ..."})," may be\nforbidden since 125 million is likely unreasonable)."]}),"\n",(0,i.jsx)(n.h3,{id:"query-cost-analysis",children:"Query cost analysis"}),"\n",(0,i.jsxs)(n.p,{children:["Trusted documents prevent attackers from sending our servers expensive queries,\nbut if you can't use them\n(",(0,i.jsx)(n.a,{href:"/graphql/trusted-documents",children:"if you can, you should!"}),") then query\ncost/complexity analysis is another technique to add to your arsenal. By applies\nheuristics during AST traversal, a maximal cost of a request can be estimated,\nand request that exceed a given cost limit can be rejected prior to execution.\nIt's even possible to factor this calculated cost into your rate limits, so a\nuser may only perform a small number of large complex queries, but could perform\na larger number of simpler smaller queries."]}),"\n",(0,i.jsx)(n.p,{children:"Figuring out the cost of a document is itself an expensive process that can be\nattacked, so if you use this technique think about how the technique itself can\nbe abused."}),"\n",(0,i.jsxs)(n.p,{children:["IBM have written a well-researched\n",(0,i.jsx)(n.a,{href:"https://ibm.github.io/graphql-specs/",children:"GraphQL Cost Directives Specification"}),"\nyou can follow, and there are a number of existing solutions out there that are\njust a search away."]}),"\n",(0,i.jsx)(n.h3,{id:"beware-graphql-bombs",children:"Beware: GraphQL bombs"}),"\n",(0,i.jsxs)(n.p,{children:["If your GraphQL API accepts file uploads (I'd strongly advise against that,\nGraphQL is not really designed for file uploads!) then be sure to protect\nyourself from\n",(0,i.jsx)(n.a,{href:"https://escape.tech/blog/forging-graphql-bombs-the-2022-version-of-zip-bombs/",children:"GraphQL bombs"})," -\nwhere a moderately sized uploaded file can be referenced many times within a\ndocument to invoke large memory usage on the server, potentially leading to\ndenial of service."]}),"\n",(0,i.jsxs)(n.p,{children:["To protect against this, either don't allow ",(0,i.jsx)(n.code,{children:"multipart/form-data"})," requests to\nyour GraphQL API and use a different technology for file uploads, or:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Limit the size of file uploads"}),"\n",(0,i.jsx)(n.li,{children:"When designing your schema, only allow file uploads to be referenced in root\npositions (never inside of lists!)"}),"\n",(0,i.jsx)(n.li,{children:"Prevent the same file upload variable from being referenced multiple times in\nthe same document (via a custom validation rule)"}),"\n",(0,i.jsx)(n.li,{children:"Don't allow any kind of GraphQL request or variable batching to be used with\nfile uploads"}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"multipartform-data-and-applicationx-www-form-urlencoded",children:[(0,i.jsx)(n.code,{children:"multipart/form-data"})," and ",(0,i.jsx)(n.code,{children:"application/x-www-form-urlencoded"})]}),"\n",(0,i.jsxs)(n.p,{children:["When using ",(0,i.jsx)(n.code,{children:"multipart/form-data"}),", ",(0,i.jsx)(n.code,{children:"application/x-www-form-urlencoded"}),', and other\n"simple" content-types, browsers bypass CORS preflight requests. This allows\nattackers to attempt CSRF requests - if one of your logged-in users visits a\nmalicious website, that site can make a request to your API using their cookies,\nwith potentially disastrous results (privilege escalation, account deletion,\netc).']}),"\n",(0,i.jsxs)(n.p,{children:['To protect against this, simply do not allow these "simple" content types and\nstick to the standard ',(0,i.jsx)(n.code,{children:"application/json"})," as detailed in the\n",(0,i.jsx)(n.a,{href:"https://graphql.github.io/graphql-over-http/draft/",children:"GraphQL-over-HTTP specification"}),".\nAlternatively, ensure that requests contain a custom header (e.g.\n",(0,i.jsx)(n.code,{children:"GraphQL-Require-Preflight"})," or ",(0,i.jsx)(n.code,{children:"X-CSRF-Token"}),"), which forces browsers to perform\npreflight requests allowing you to prevent this style of attack."]}),"\n",(0,i.jsx)(n.h2,{id:"protecting-validation",children:"Protecting validation"}),"\n",(0,i.jsx)(n.p,{children:"A lot of our solutions above related to validation; but validation itself is a\npotential attack vector."}),"\n",(0,i.jsx)(n.h3,{id:"limit-validation-errors",children:"Limit validation errors"}),"\n",(0,i.jsxs)(n.p,{children:["Consider the query ",(0,i.jsx)(n.code,{children:"{a a a a a a a a \u2026 a a a a a a a a}"})," with as many ",(0,i.jsx)(n.code,{children:"a"})," as\nyour server allows. This might seem harmless enough, but assuming that your\nschema does not have a ",(0,i.jsx)(n.code,{children:"Query.a"})," field, each ",(0,i.jsx)(n.code,{children:"a"})," here will generate a separate\nvalidation error, requiring the server to send a much much larger response body\nthan the query body would suggest:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n    "errors": [\n        {\n            "message": "Cannot query field \\"a\\" on type \\"Root\\".",\n            "locations": [\n                {\n                    "line": 1,\n                    "column": 2\n                }\n            ]\n        },\n        {\n            "message": "Cannot query field \\"a\\" on type \\"Root\\".",\n            "locations": [\n                {\n                    "line": 1,\n                    "column": 4\n                }\n            ]\n        },\n        {\n            "message": "Cannot query field \\"a\\" on type \\"Root\\".",\n            "locations": [\n                {\n                    "line": 1,\n                    "column": 6\n                }\n            ]\n        },\n        \u2026\n'})}),"\n",(0,i.jsxs)(n.p,{children:["A 100KB query containing ~50k ",(0,i.jsx)(n.code,{children:"a"})," characters producing errors like the above\nwould have the server send a 11MB payload - over 100x the size of the input."]}),"\n",(0,i.jsx)(n.p,{children:'Even worse, many GraphQL implementations have a "did you mean" helper on\nvalidation errors to aid developers by hinting at the field names they may have\nintended, but this search for matching field names uses additional compute and\ncan make the payload even larger.'}),"\n",(0,i.jsx)(n.p,{children:"It's best to limit the number of validation errors that can be produced in\nproduction, and if this limit is exceeded then abort validation and return a\nreasonable error:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "errors": [\n    {\n      "message": "Too many validation errors, error limit reached. Validation aborted."\n    }\n  ]\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"size-and-token-limits",children:"Size and token limits"}),"\n",(0,i.jsx)(n.p,{children:"Even getting as far as counting errors in validation can consume a lot of\nresources. Before the GraphQL server even starts the validation process it needs\nto parse the document, and we can apply a limit to the number of tokens that the\ndocument can contain and abort parsing if this limit is exceeded. It's up to you\nto determine a sensible number of tokens for your applications, but consider\nstarting around 1000 and raising the limit if legitimate queries are bumping up\nagainst it."}),"\n",(0,i.jsx)(n.p,{children:"Parsing itself involves some amount of effort - another protection we should\nconsider is limiting the size of GraphQL documents that we will even attempt to\nparse. This would be the limit of the GraphQL document size in bytes, a\nreasonable starting point might be 10kB, and then increase it as need be. A\nslightly larger limit should be applied to the request body (which would include\nany variables) - assuming you're not handling file uploads or large bodies of\ntext, 100kB can often be suitable for simple CRUD APIs."}),"\n",(0,i.jsx)(n.h3,{id:"validation-timeout",children:"Validation timeout"}),"\n",(0,i.jsx)(n.p,{children:'Some parts of validation are more expensive than others, for example field\ncollection can involve a lot of AST traversal, leading to a lot of CPU usage. If\npossible, it may make sense to apply a timeout to validation itself and reject\nrequests that take too long (and consider rate limiting that user quite\nheavily!). However, "noisy neighbor" issues may mean that these kinds of very\nlow time limits (milliseconds) may be exceeded sporadically so some amount of\nleeway is reasonable.'}),"\n",(0,i.jsx)(n.h2,{id:"protecting-runtime",children:"Protecting runtime"}),"\n",(0,i.jsx)(n.p,{children:"We've done what we can above to avoid malicious requests from being executed in\nthe first place; but it's likely some will still fly in under the radar,\npurporting to be legitimate requests. Here are some things to consider to\nprotect the runtime of your GraphQL API."}),"\n",(0,i.jsx)(n.h3,{id:"timeouts",children:"Timeouts"}),"\n",(0,i.jsxs)(n.p,{children:["One of the most common ways of protecting an API of any kind is with a timeout;\nif execution passes a certain threshold (e.g. 10 seconds) then it should be\naborted and an error returned. (We should also rate limit this user to prevent\nthis slow query from impacting the stability of our API.) However, keep in mind\nthat these limits may need to be extended for incremental delivery requests\n(those involving ",(0,i.jsx)(n.code,{children:"@stream"})," and/or ",(0,i.jsx)(n.code,{children:"@defer"})," directives) and maybe suspended\nentirely for subscription requests (whether over websockets, server-sent events,\nor otherwise)."]}),"\n",(0,i.jsxs)(n.p,{children:["In addition to per-request timeouts, the underlying business logic should\nperform its own timeouts to avoid resources being tied up for too long, and you\nshould also consider\n",(0,i.jsx)(n.a,{href:"https://martinfowler.com/bliki/CircuitBreaker.html?ref=wellarchitected",children:"the circuit-breaker pattern"}),"\nin your business logic so that if a part of your infrastructure fails, the\nrelated parts of GraphQL requests can exit early whilst allowing the rest of the\nrequest to still return useful data."]}),"\n",(0,i.jsx)(n.h3,{id:"cancellation-token",children:"Cancellation token"}),"\n",(0,i.jsx)(n.p,{children:"Telling the user that their request took too long so you're returning an error\nis not enough, we need to actually stop any asynchronous work that's taking\nplace. For some languages this is part-and-parcel of a timeout, but for others\nasynchronous work must be manually handled by passing around a \"cancellation\ntoken\" of some kind - each asynchronous operation should subscribe to this\ntoken, and should abort as soon as it triggers."}),"\n",(0,i.jsx)(n.h3,{id:"rate-limiting",children:"Rate limiting"}),"\n",(0,i.jsx)(r.Z,{children:(0,i.jsxs)(n.p,{children:["it's vital to ",(0,i.jsx)(n.strong,{children:"rate limit"})," within the ",(0,i.jsx)(n.strong,{children:"business-logic"})]})}),"\n",(0,i.jsxs)(n.p,{children:["HTTP-level rate limiting is a common protection for any API type, but in GraphQL\nthere are many ways to circumvent this. If the GraphQL service supports it, an\nattacker could use\n",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-over-http/issues/5",children:"operation batching"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'[{"query":"mutation{login(username:\\"admin\\",pin:\\"0000\\")}"}\n,{"query":"mutation{login(username:\\"admin\\",pin:\\"0001\\")}"}\n,{"query":"mutation{login(username:\\"admin\\",pin:\\"0002\\")}"}\n\u2026\n'})}),"\n",(0,i.jsxs)(n.p,{children:["or\n",(0,i.jsx)(n.a,{href:"https://github.com/graphql/composite-schemas-spec/issues/25",children:"variable batching"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{"query":"mutation($p:String!){login(username:\\"admin\\",pin:$p)}",\n "variables":\n  [{"p":"0000"}\n  ,{"p":"0001"}\n  ,{"p":"0002"}\n  \u2026\n'})}),"\n",(0,i.jsx)(n.p,{children:"They could also use aliases within the GraphQL document:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'mutation ($u: String! = "admin") {\n  m0:login(username:$u,pin:"0000")\n  m1:login(username:$u,pin:"0001")\n  m2:login(username:$u,pin:"0002")\n  \u2026\n'})}),"\n",(0,i.jsx)(n.p,{children:"Combining these techniques could allow an attacker to perform an operation\norders of magnitude more often than the HTTP-level rate limit would imply."}),"\n",(0,i.jsx)(n.p,{children:"Therefore it's vital to ensure that vulnerable fields are rate limited at the\nresolver or business-logic level, in addition to any HTTP-level rate limits.\nFurther, HTTP-level rate limits should also factor in the size of any batches\ncontained therein."}),"\n",(0,i.jsx)(n.h3,{id:"runtime-errors",children:"Runtime errors"}),"\n",(0,i.jsx)(n.p,{children:"We've discussed validation errors above; runtime errors have their own concerns.\nGraphQL is designed to support partial success - even in the face of errors, we\nwant to render what we can for the user - but unexpected errors can often\ncontain privileged information. This information is useful for developers, but\nalso very useful to attackers. We should therefore prevent unsafe errors being\nsurfaced to end users in production, instead masking the error and writing the\ndetails to a server log that only trusted parties can see. Some errors (for\nexample, data validation errors) may be safe to send through, but all other\nerrors should be masked by default."}),"\n",(0,i.jsxs)(n.p,{children:["Read more about error masking in\n",(0,i.jsx)(n.a,{href:"https://the-guild.dev/graphql/yoga-server/docs/features/error-masking",children:"The Guild's Yoga documentation"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"general-resources",children:"General resources"}),"\n",(0,i.jsxs)(n.p,{children:["OWASP security cheatsheet:\n",(0,i.jsx)(n.a,{href:"https://cheatsheetseries.owasp.org/cheatsheets/GraphQL_Cheat_Sheet.html",children:"https://cheatsheetseries.owasp.org/cheatsheets/GraphQL_Cheat_Sheet.html"})]})]})}function u(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},4664:(e,n,t)=>{t.d(n,{Z:()=>r});t(7294);const i="pullquote_fEhA";var s=t(5893);const r=e=>{let{children:n}=e;return(0,s.jsx)("aside",{className:i,children:(0,s.jsx)("blockquote",{children:n})})}},768:(e,n,t)=>{t.d(n,{u:()=>a});t(7294);const i="tldr_fcon",s="inner_JkE_";var r=t(5893);const a=e=>{let{children:n}=e;return(0,r.jsx)("aside",{className:i,children:(0,r.jsx)("div",{className:s,children:n})})}},7138:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/if_you_can_you_should-b5538124d3ab9fb4af1cd209136c91c4.png"},1151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>a});var i=t(7294);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);