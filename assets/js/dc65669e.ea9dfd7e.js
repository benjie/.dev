"use strict";(self.webpackChunk_localrepo_benjie_dev=self.webpackChunk_localrepo_benjie_dev||[]).push([[1],{571:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var i=t(5893),o=t(1151);const r={identifier:"wg944",title:"New Intersection Type",stage:"0",champion:"yaacovCR",wgDiscussionUrl:"https://github.com/graphql/graphql-wg/discussions/944",events:[{type:"wgDiscussionCreated",date:new Date("2022-04-30T22:39:31.000Z"),href:"https://github.com/graphql/graphql-wg/discussions/944",actor:"yaacovCR"}],related:"711, 939, 941, ExpandingSubtyping",shortname:"New Intersection Type",image:"/img/rfc_tracker.png"},s=void 0,a={id:"wg944",title:"New Intersection Type",description:"At a glance",source:"@site/rfcs/wg944.md",sourceDirName:".",slug:"/wg944",permalink:"/rfcs/wg944",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{identifier:"wg944",title:"New Intersection Type",stage:"0",champion:"yaacovCR",wgDiscussionUrl:"https://github.com/graphql/graphql-wg/discussions/944",events:[{type:"wgDiscussionCreated",date:"2022-04-30T22:39:31.000Z",href:"https://github.com/graphql/graphql-wg/discussions/944",actor:"yaacovCR"}],related:"711, 939, 941, ExpandingSubtyping",shortname:"New Intersection Type",image:"/img/rfc_tracker.png"},sidebar:"rfcsSidebar",previous:{title:"Servers must preserve lexical ordering between SDL and introspection",permalink:"/rfcs/673"},next:{title:"Fragment Modularity",permalink:"/rfcs/wg857"}},l={},c=[{value:"At a glance",id:"at-a-glance",level:2},{value:"Timeline",id:"timeline",level:2},{value:"Example Behavior",id:"example-behavior",level:3},{value:"Motivation",id:"motivation",level:3},{value:"intersection &quot;implementing&quot; interface",id:"intersection-implementing-interface",level:4},{value:"intersection &quot;implementing&quot; interface AND narrowing unions",id:"intersection-implementing-interface-and-narrowing-unions",level:4},{value:"Tradeoffs between intersections and simply allowing unions to declare &quot;implementation&quot; of interfaces",id:"tradeoffs-between-intersections-and-simply-allowing-unions-to-declare-implementation-of-interfaces",level:3},{value:"Open questions",id:"open-questions",level:3},{value:"Example and further discussion for question 1",id:"example-and-further-discussion-for-question-1",level:3},{value:"Example and further discussion for question 2",id:"example-and-further-discussion-for-question-2",level:3},{value:"Example and further discussion for question 3",id:"example-and-further-discussion-for-question-3",level:3},{value:"Example and further discussion for question 4",id:"example-and-further-discussion-for-question-4",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"at-a-glance",children:"At a glance"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Identifier"}),": wg#944"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stage"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md#stage-0-strawman",children:"RFC0: Strawman"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Champion"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/yaacovCR",children:"@yaacovCR"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"PR"}),": -"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Related"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/rfcs/939",title:"allow unions to declare implementation of interfaces / RFC1",children:"#939"})," (allow unions to declare implementation of interfaces)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/rfcs/ExpandingSubtyping",title:"Expanding Subtyping (for output types) / RFC0",children:"ExpandingSubtyping"})," (Expanding Subtyping (for output types))"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"timeline",children:"Timeline"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/discussions/944",children:"WG discussion"})," created"]})," on 2022-04-30 by yaacovCR"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:['As an alternative to "unions implementing interfaces" (',(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/pull/939",children:"https://github.com/graphql/graphql-spec/pull/939"}),"), a new intersection type could be introduced that models the same behavior."]}),"\n",(0,i.jsxs)(n.p,{children:["Spec PR: ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/pull/941",children:"https://github.com/graphql/graphql-spec/pull/941"}),"\nImplementation PR: ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-js/pull/3550",children:"https://github.com/graphql/graphql-js/pull/3550"})]}),"\n",(0,i.jsx)(n.h3,{id:"example-behavior",children:"Example Behavior"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# SomeIntersection includes TypeA and TypeB below because only they declare implementation of SomeInterface\nintersection SomeIntersection = SomeUnion & SomeInterface  \n\n# AnotherIntersection only includes TypeC below because only TypeC declares implementation of AnotherInterface\nintersection AnotherIntersection = AnotherUnion & AnotherInterface\n\nunion SomeUnion = TypeA | TypeB\nunion AnotherUnion = TypeA | TypeB | TypeC\n\ninterface SomeInterface {\n  someField: String\n}\n\ninterface AnotherInterface {\n  anotherField: String\n}\n\ntype TypeA implements SomeInterface {\n  someField: String\n}\ntype TypeB implements SomeInterface  {\n  someField: String\n  anotherField: String\n}\ntype TypeC implements SomeInterface & AnotherInterface {\n  someField: String\n  anotherField: String\n}\n\n# to remove TypeA and TypeB from SomeIntersection\nextend type intersection SomeIntersection = AnotherInterface\n\n# to add TypeC to SomeUnion and transitively to SomeIntersection\nextend type SomeUnion = TypeC \n\n# to add TypeB to AnotherIntersection and\n# if above changes were also made, to add back TypeB to SomeIntersection\nextend type TypeB implements AnotherInterface \n"})}),"\n",(0,i.jsx)(n.h3,{id:"motivation",children:"Motivation"}),"\n",(0,i.jsx)(n.h4,{id:"intersection-implementing-interface",children:'intersection "implementing" interface'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"# generic types\ninterface Node {\n  id: ID!\n}\n\ninterface Connection {\n  pageInfo: PageInfo!\n  edges: [Edge]\n}\n\ninterface Edge {\n  cursor: String\n  node: Node\n}\n\ntype PageInfo {\n  hasPreviousPage: Boolean\n  hasNextPage: Boolean\n  startCursor: String\n  endCursor: String\n}\n\n# schema-specific types\ninterface Pet {\n  id: ID!\n  name: String\n}\n\ntype Cat implements Pet & Node {\n  id: ID!\n  name: String\n}\n\ntype Dog implements Pet & Node {\n  id: ID!\n  name: String\n}\n\nunion HousePet = Cat | Dog\n\nintersection HousePetNode = HousePet & Pet & Node\n\n# house-pet-specific types\ntype HousePetEdge implements Edge {\n  cursor: String\n  node: HousePetNode # <<< This is unlocked by this PR\n}\n\ntype HousePetConnection implements Connection {\n  pageInfo: PageInfo!\n  edges: [HousePetEdge]\n}\n\n# query\ntype Query {\n  housePets: HousePetConnection\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"intersection-implementing-interface-and-narrowing-unions",children:'intersection "implementing" interface AND narrowing unions'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"# generic types\ninterface Node {\n  id: ID!\n}\n\ninterface Connection {\n  pageInfo: PageInfo!\n  edges: [Edge]\n}\n\ninterface Edge {\n  cursor: String\n  node: Node\n}\n\ntype PageInfo {\n  hasPreviousPage: Boolean\n  hasNextPage: Boolean\n  startCursor: String\n  endCursor: String\n}\n\n# schema-specific types\ninterface Pet {\n  id: ID!\n  name: String\n}\n\ntype Cat implements Pet & Node {\n  id: ID!\n  name: String\n}\n\ntype Dog implements Pet & Node {\n  id: ID!\n  name: String\n}\n\ntype Fish implements Pet & Node {\n  id: ID!\n  name: String\n}\n\ntype Lion implements Pet & Node {\n  id: ID!\n  name: String\n}\n\nunion HousePet = Cat | Dog | Fish\nunion PetWithFur = Cat | Dog | Lion\n\nintersection HousePetWithFurNode = HousePet & PetWithFur & Pet & Node\n\n# house-pet-specific types\ntype HousePetWithFurEdge implements Edge {\n  cursor: String\n  node: HousePetWithFurNode  # <<< This is unlocked by this PR\n}\n\ntype HousePetWithFurNodeConnection implements Connection {\n  pageInfo: PageInfo!\n  edges: [HousePetWithFurEdge]\n}\n\n# query\ntype Query {\n  housePetsWithFur: HousePetWithFurNodeConnection\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"tradeoffs-between-intersections-and-simply-allowing-unions-to-declare-implementation-of-interfaces",children:'Tradeoffs between intersections and simply allowing unions to declare "implementation" of interfaces'}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"What would happen if you wanted to add a type to your union that doesn't implement the interface? If we directly allow unions to implement interfaces, you couldn't do that without making some other change. You would basically be forced to (1) make the union no longer implement the interface, a breaking change, or (2) add a new, different union without the type that doesn't implement the interface. If we use intersections, you could add whatever types you wanted to the original union without fear."}),"\n",(0,i.jsx)(n.li,{children:"With intersections, you can also create new unions that are intersections of the previous existing unions. I doubt anyone is clamoring for that, but you sure could do that."}),"\n",(0,i.jsxs)(n.li,{children:["This points the way toward higher-order abstract types in general. Working on this showed me that we could eventually allow unions to include abstract member types, which would potentially solve ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/issues/711",children:"https://github.com/graphql/graphql-spec/issues/711"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"What are some of the downsides?"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"It's more complex than the unions implement interfaces solution."}),"\n",(0,i.jsx)(n.li,{children:"Changing intersections by adding or subtracting abstract types can cause queries to break, so they are not so mutable. I'm not sure how bad that it is in practice. Adding abstract types can cause object types to no longer fulfill the intersection if they fulfilled the prior set but not the new abstract type. Removing an interface is breaking for the same reason that removing an interface from a type is breaking -- I think it's because it could break the type system, but not queries, but it's still a kind of breaking."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"open-questions",children:"Open questions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"If intersection types include interfaces that implement interfaces, should the ancestor interfaces be required to be listed explicitly within the intersection? (My answer: yes, just like with interfaces.)"}),"\n",(0,i.jsx)(n.li,{children:'Should intersection types be allow to include other intersection types? (My answer: no, the "child" intersection types should just be listed explicitly within the "parent.")'}),"\n",(0,i.jsx)(n.li,{children:"Should one be allowed to query fields directly on the intersection? (My answer: no, intersections that define no union members will have no fields guarantees, so for consistency fragments on intersections should never be allowed.)"}),"\n",(0,i.jsx)(n.li,{children:'What should be considered a "breaking change" with regard to an intersection? (My answer: anything that could remove an object type from the intersection or could remove an interface from the intersection.)'}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-and-further-discussion-for-question-1",children:"Example and further discussion for question 1"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"interface ParentInterface {\n  someField: String\n}\n\ninterface ChildInterface implements ParentInterface {\n  someField String\n}\n\ntype TypeA implements ParentInterface & ChildInterface {\n  someField: String\n}\n\ntype TypeB implements ParentInterface & ChildInterface {\n  someField: String\n}\n\nunion MyUnion = TypeA | TypeB\n"})}),"\n",(0,i.jsx)(n.p,{children:"Should we allow:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"intersection MyIntersection = MyUnion & ChildInterface\n"})}),"\n",(0,i.jsx)(n.p,{children:"vs. requiring"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"intersection MyIntersection = MyUnion & ParentInterface & ChildInterface\n"})}),"\n",(0,i.jsx)(n.p,{children:"As we can see for above, ancestor interfaces are already required for readability reasons on object and interface types. The same argument could be made here -- and I would tend to agree with it! Note that the spec/implementation PRs now implements this requirement."}),"\n",(0,i.jsx)(n.h3,{id:"example-and-further-discussion-for-question-2",children:"Example and further discussion for question 2"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"interface SomeInterface {\n  someField: String\n}\n\ntype AnotherInterface {\n  anotherField: String\n}\n\ntype TypeA implements SomeInterface & AnotherInterface {\n  someField: String\n  anotherField: String\n}\n\ntype TypeB implements AnotherInterface {\n  anotherField: String\n}\n\nunion MyUnion = TypeA | TypeB\n\nintersection SomeIntersection = MyUnion & SomeInterface\nintersection AnotherIntersection = MyUnion & AnotherInterface\n"})}),"\n",(0,i.jsx)(n.p,{children:"Should we allow:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"intersection IntersectingIntersection = SomeIntersection & AnotherIntersection\n"})}),"\n",(0,i.jsx)(n.p,{children:"Or require\u200b:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"intersection SomeIntersection = MyUnion & SomeInterface & AnotherInterface\n"})}),"\n",(0,i.jsx)(n.p,{children:"One could argue that similarly to the required verbosity for interfaces, we should require\u200b intersections to explicitly list all of their members and not include any other intersections. The spec/PR now implements this requirement."}),"\n",(0,i.jsx)(n.h3,{id:"example-and-further-discussion-for-question-3",children:"Example and further discussion for question 3"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"interface Pet {\n  name: String\n}\n\ntype Dog implements Pet {\n  name: String\n}\n\ntype Cat implements Pet {\n  name: String\n}\n\nunion DogOrCat = Dog | Cat\n\nintersection DogOrCatPet = DogOrCat & Pet\n\ntype Query {\n  dogOrCatPets: [DogOrCatPet]  \n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Should we allow:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"{\n  dogOrCatPets {\n    name\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"or require\u200b:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"{\n  dogOrCatPets {\n    ... on Pet {\n      name\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:'An argument in favor of allowing the former is that for this particular intersection, name is always defined, so this should be fine. An argument against allowing could be just from theory => the intersection itself does not define any fields, it just does so transitively through the interface it includes, so it is "wrong" to allow querying on the type. Because some intersections may contain only unions and not have any fields, it might be simpler to "teach" intersections as being more similar to unions, and never allow querying for fields directly on the intersection. I lean against allowing it, but not strongly.'}),"\n",(0,i.jsx)(n.h3,{id:"example-and-further-discussion-for-question-4",children:"Example and further discussion for question 4"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"interface Named {\n  name: String\n}\n\ninterface AnotherInterface {\n  anotherField: String\n}\n\ntype Dog implements Named {\n  name: String\n}\n\nunion LandPet = Dog | Cat\n\nintersection NamedLandPet= LandPet & Named\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Intersection changes could break all sorts of queries. Adding another union or interface MAY remove types, if any of the previously included types are not in the newly added union or do not implement the newly added interface. For example, adding ",(0,i.jsx)(n.code,{children:"AnotherInterface"})," to the intersection would cause all types to be dropped. Removing an interface could also break a type, for the same reason that removing an interface from an object type is breaking. Removing the last union causes all types to drop from the intersection."]}),"\n",(0,i.jsxs)(n.p,{children:["Intersections are therefore to some degree more immutable than other types. The current implementation of this PR assumes that includes removal or addition of ANY constraining types within the results of ",(0,i.jsx)(n.code,{children:"findBreakingChanges"}),". This could be pared back, as adding constraining types may not cause additional object types to drop if the new types are more expansive than the old. Removing a union should only cause types to drop if it is the last remaining union (at least as long as unions can only containing object types and not interfaces)."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>s});var i=t(7294);const o={},r=i.createContext(o);function s(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);