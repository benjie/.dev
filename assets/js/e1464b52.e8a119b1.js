"use strict";(self.webpackChunk_localrepo_benjie_dev=self.webpackChunk_localrepo_benjie_dev||[]).push([[9679],{7744:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>h,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var s=r(5893),t=r(1151),a=r(768);r(4664);const i={type:"page",title:"Referencing Ancestors",description:"Filtering by or comparing against ancestor objects in a field.",tag:"graphql",author:"Benjie",breadcrumb:!1,sidebar_position:70},o="Referencing Ancestors",l={id:"graphql/ancestors",title:"Referencing Ancestors",description:"Filtering by or comparing against ancestor objects in a field.",source:"@site/pages/graphql/ancestors.mdx",sourceDirName:"graphql",slug:"/graphql/ancestors",permalink:"/graphql/ancestors",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:70,frontMatter:{type:"page",title:"Referencing Ancestors",description:"Filtering by or comparing against ancestor objects in a field.",tag:"graphql",author:"Benjie",breadcrumb:!1,sidebar_position:70},sidebar:"defaultSidebar",previous:{title:"Normalized Stores",permalink:"/graphql/normalized"},next:{title:"Talks",permalink:"/talks/"}},h={},d=[{value:"Breaks normalized stores",id:"breaks-normalized-stores",level:2},{value:"Solution: rewrite the query",id:"solution-rewrite-the-query",level:2},{value:"Solution: add another field",id:"solution-add-another-field",level:2},{value:"Thanks",id:"thanks",level:2}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"referencing-ancestors",children:"Referencing Ancestors"}),"\n",(0,s.jsx)(a.u,{children:(0,s.jsxs)(n.p,{children:["GraphQL's execution model does not give you a native way to reference ancestors\nin field resolvers (only the entity itself is provided), and that's for good\nreason: GraphQL mimics ",(0,s.jsx)(n.a,{href:"/graphql/traversal",children:"traversing a graph"}),". The value of a\nnode in the graph is independent of the path you took to get to it; breaking\nthis rule would break technology that relies on it, for example\n",(0,s.jsx)(n.a,{href:"/graphql/normalized",children:"normalized stores"}),"."]})}),"\n",(0,s.jsxs)(n.p,{children:["One of the common requests that I see in GraphQL is users wanting a way to query\nan ancestor object from a descendant object. Throughout this article, I'm going\nto use an example based on the one given in\n",(0,s.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/issues/144#issue-133595212",children:"GraphQL spec issue #144"}),";\nhere's the schema under discussion:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"type Query {\n  events: [Event]\n}\n\ntype Event {\n  id: ID!\n  name: String\n  speakers: [Speaker]\n  talks: [Talk]\n}\n\ntype Speaker {\n  id: ID!\n  name: String\n  events: [Event]\n  talks: [Talk]\n}\n\ntype Talk {\n  id: ID!\n  name: String\n  speaker: Speaker\n  event: Event\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Consider this query:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"query {\n  events {\n    id\n    name\n    speakers {\n      id\n      name\n      talks {\n        id\n        name\n      }\n    }\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The issue author would like to make it such that ",(0,s.jsx)(n.code,{children:">events>speakers>talks"})," (using\n",(0,s.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/main/rfcs/OperationExpressions.md",children:"operation expressions"}),"\nsyntax) returns the list of talks that the speaker has in the ancestor event."]}),"\n",(0,s.jsxs)(n.p,{children:["At first glance, this might seem like a reasonable proposition... However, when\nconsidering ",(0,s.jsx)(n.a,{href:"/graphql/traversal",children:"graph traversal"})," it becomes apparent why this\nwould be problematic \u2014 the value of a ",(0,s.jsx)(n.code,{children:"Speaker"}),"'s ",(0,s.jsx)(n.code,{children:"talks"})," field should be\nindependent of the path through which it was accessed. In particular,\n",(0,s.jsx)(n.a,{href:"/graphql/normalized",children:"normalized stores"})," rely on the graph traversal execution\nbehaviour outlined in the GraphQL specification; to change this fundamental\nbehaviour could cause applications using normalized stores to produce subtle\nissues resulting in a lot of confusion and frustration."]}),"\n",(0,s.jsx)(n.h2,{id:"breaks-normalized-stores",children:"Breaks normalized stores"}),"\n",(0,s.jsx)(n.p,{children:"Let's see why normalized stores would be broken by this. If you implement the\ndescribed change, you might get a result from the request above such as:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"{7-15,23-32}",children:'{\n  "events": [\n    {\n      "id": "EGQLC",\n      "name": "GraphQLConf",\n      "speakers": [\n        {\n          "id": "UB3NJ",\n          "name": "Benjie",\n          "talks": [\n            {\n              "id": "TGFST",\n              "name": "The Future of Efficiency Is Here: Schema Planning"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      "id": "EVRGU",\n      "name": "VR Gamers",\n      "speakers": [\n        {\n          "id": "UB3NJ",\n          "name": "Benjie",\n          "talks": [\n            {\n              "id": "TPOPC",\n              "name": "Mastering Climbing in Population:One"\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"(I've omitted all other speakers and all other events for brevity.)"}),"\n",(0,s.jsxs)(n.p,{children:["When you ",(0,s.jsx)(n.a,{href:"/graphql/normalized",children:"turn this into a normalized store"}),", both events\nreference the speaker ",(0,s.jsx)(n.code,{children:"UB3NJ"}),", who has a field ",(0,s.jsx)(n.code,{children:"talks"})," that accepts no\narguments; so when you merge these, the latter will overwrite the former, and\nthe resulting store will end up being something like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json5",metastring:"{18-30}",children:'{\n  "Query": {\n    "events": [ { "$ref": "EGQLC" }, { "$ref": "EVRGU" } ]\n  }\n  "EGQLC": {\n    "id": "EGQLC",\n    "name": "GraphQLConf",\n    "speakers": [ { "$ref": "UB3NJ" } ]\n  },\n  "EVRGU": {\n    "id": "EVRGU",\n    "name": "VR Gamers",\n    "speakers": [ { "$ref": "UB3NJ" } ]\n  },\n  "UB3NJ": {\n    "id": "UB3NJ",\n    "name": "Benjie",\n    /* This gets overwritten:\n    "talks": [\n      {\n        "id": "TGFST",\n        "name": "The Future of Efficiency Is Here: Schema Planning"\n      }\n    ] */\n    "talks": [\n      {\n        "id": "TPOPC",\n        "name": "Mastering Climbing in Population:One"\n      }\n    ]\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:['When you reconstitute this back into data to render you\'ll end up with Benjie\'s\ntalk for the "VR Gamers" event being used for GraphQLConf... A subtle issue when\ntesting the software (very hard to notice) but super obvious to the attendees of\nGraphQLConf who wonder how relevant "Mastering Climbing in Population',":One",'" is to\nGraphQL!']}),"\n",(0,s.jsx)(n.h2,{id:"solution-rewrite-the-query",children:"Solution: rewrite the query"}),"\n",(0,s.jsx)(n.p,{children:"One solution to this problem is to write your query in such a way that each\nfield can execute in a context-free way and still give you the data you need:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"query {\n  events {\n    id\n    name\n    talks {\n      id\n      name\n      speakers {\n        id\n        name\n      }\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"solution-add-another-field",children:"Solution: add another field"}),"\n",(0,s.jsx)(n.p,{children:"Another solution is to perform the grouping on the server side and expose this\nvia the schema:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"extend type Event {\n  speakersAndTalks: [SpeakerAndTalks]\n}\ntype SpeakerAndTalks {\n  speaker: Speaker\n  talks: [Talk]\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"which you could query like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"query {\n  events {\n    id\n    name\n    speakersAndTalks {\n      speaker {\n        id\n        name\n      }\n      talks {\n        id\n        name\n      }\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"thanks",children:"Thanks"}),"\n",(0,s.jsxs)(n.p,{children:["Thank you to fellow TSC member ",(0,s.jsx)(n.a,{href:"https://github.com/mjmahone",children:"Matt Mahoney"})," for\nproof-reading this article. Matt comments that this can also occur in:"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["REST-based resolvers, where the ",(0,s.jsx)(n.code,{children:"events.speaker"})," field is backed by a REST\nendpoint, which always gives you ",(0,s.jsx)(n.code,{children:"Speaker.talks"})," in a context-dependent way."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},4664:(e,n,r)=>{r.d(n,{Z:()=>a});r(7294);const s="pullquote_fEhA";var t=r(5893);const a=e=>{let{children:n}=e;return(0,t.jsx)("aside",{className:s,children:(0,t.jsx)("blockquote",{children:n})})}},768:(e,n,r)=>{r.d(n,{u:()=>i});r(7294);const s="tldr_fcon",t="inner_JkE_";var a=r(5893);const i=e=>{let{children:n}=e;return(0,a.jsx)("aside",{className:s,children:(0,a.jsx)("div",{className:t,children:n})})}},1151:(e,n,r)=>{r.d(n,{Z:()=>o,a:()=>i});var s=r(7294);const t={},a=s.createContext(t);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);