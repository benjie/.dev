"use strict";(self.webpackChunk_localrepo_benjie_dev=self.webpackChunk_localrepo_benjie_dev||[]).push([[4279],{607:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>c,frontMatter:()=>l,metadata:()=>r,toc:()=>d});var i=t(5893),s=t(1151);const l={identifier:"879",title:"__fulfilled meta field",stage:"0",champion:"mjmahone",prUrl:"https://github.com/graphql/graphql-spec/pull/879",events:[{type:"wgAgenda",href:"https://github.com/graphql/graphql-wg/blob/main/agendas/2021/2021-09-02.md",date:new Date("2021-09-02T00:00:00.000Z"),actor:null},{type:"wgNotes",href:"https://github.com/graphql/graphql-wg/blob/main/notes/2021/2021-09-02.md",date:new Date("2021-09-02T00:00:00.000Z"),actor:null},{type:"wgAgenda",href:"https://github.com/graphql/graphql-wg/blob/main/agendas/2021/2021-08-05.md",date:new Date("2021-08-05T00:00:00.000Z"),actor:null},{type:"prCreated",date:new Date("2021-07-23T21:52:07.000Z"),href:"https://github.com/graphql/graphql-spec/pull/879",actor:"mjmahone"},{type:"commitsPushed",date:new Date("2021-07-23T00:00:00.000Z"),href:"https://github.com/graphql/graphql-spec/commit/2447e944ab8c77b233e00afad2617b28ded9c694",actor:"mjmahone",commits:[{href:"https://github.com/graphql/graphql-spec/commit/2447e944ab8c77b233e00afad2617b28ded9c694",headline:"__fulfilled meta field",ghUser:"mjmahone",authorName:"Matt Mahoney"}]}],related:"FragmentModularity",shortname:"__fulfilled meta field",image:"/img/rfc_tracker.png"},a=void 0,r={id:"879",title:"__fulfilled meta field",description:"At a glance",source:"@site/rfcs/879.md",sourceDirName:".",slug:"/879",permalink:"/rfcs/879",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{identifier:"879",title:"__fulfilled meta field",stage:"0",champion:"mjmahone",prUrl:"https://github.com/graphql/graphql-spec/pull/879",events:[{type:"wgAgenda",href:"https://github.com/graphql/graphql-wg/blob/main/agendas/2021/2021-09-02.md",date:"2021-09-02T00:00:00.000Z",actor:null},{type:"wgNotes",href:"https://github.com/graphql/graphql-wg/blob/main/notes/2021/2021-09-02.md",date:"2021-09-02T00:00:00.000Z",actor:null},{type:"wgAgenda",href:"https://github.com/graphql/graphql-wg/blob/main/agendas/2021/2021-08-05.md",date:"2021-08-05T00:00:00.000Z",actor:null},{type:"prCreated",date:"2021-07-23T21:52:07.000Z",href:"https://github.com/graphql/graphql-spec/pull/879",actor:"mjmahone"},{type:"commitsPushed",date:"2021-07-23T00:00:00.000Z",href:"https://github.com/graphql/graphql-spec/commit/2447e944ab8c77b233e00afad2617b28ded9c694",actor:"mjmahone",commits:[{href:"https://github.com/graphql/graphql-spec/commit/2447e944ab8c77b233e00afad2617b28ded9c694",headline:"__fulfilled meta field",ghUser:"mjmahone",authorName:"Matt Mahoney"}]}],related:"FragmentModularity",shortname:"__fulfilled meta field",image:"/img/rfc_tracker.png"},sidebar:"rfcsSidebar",previous:{title:"Schema Fragments",permalink:"/rfcs/SchemaFragments"},next:{title:"NOTE: this document is kept for historic purposes; GraphQL Subscriptions have been specified and released as part of the official [June 2018 GraphQL Specification](https://spec.graphql.org/June2018/).",permalink:"/rfcs/Subscriptions"}},o={},d=[{value:"At a glance",id:"at-a-glance",level:2},{value:"Timeline",id:"timeline",level:2},{value:"Details: Add the below after 4.1: Type Introspection",id:"details-add-the-below-after-41-type-introspection",level:2},{value:"End Spec Addition: Discussion continues below",id:"end-spec-addition-discussion-continues-below",level:2},{value:"Why?",id:"why",level:2},{value:"Client Specific Considerations",id:"client-specific-considerations",level:2},{value:"What to call this boolean meta-field?",id:"what-to-call-this-boolean-meta-field",level:2},{value:"Alternative 1: Just use <code>__typename</code>",id:"alternative-1-just-use-__typename",level:2},{value:"Alternative 2: Don&#39;t use a meta-field, if you want this ability explicitly add the field to each type in your schema",id:"alternative-2-dont-use-a-meta-field-if-you-want-this-ability-explicitly-add-the-field-to-each-type-in-your-schema",level:2},{value:"Other Alternatives",id:"other-alternatives",level:2}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"at-a-glance",children:"At a glance"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Identifier"}),": #879"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stage"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md#stage-0-strawman",children:"RFC0: Strawman"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Champion"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/mjmahone",children:"@mjmahone"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"PR"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/pull/879",children:"__fulfilled meta field"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Related"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/rfcs/FragmentModularity",title:"Fragment Modularity / RFC0",children:"FragmentModularity"})," (Fragment Modularity)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"timeline",children:"Timeline"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsxs)(n.strong,{children:["Added to ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/main/agendas/2021/2021-09-02.md",children:"2021-09-02 WG agenda"})]})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsxs)(n.strong,{children:["Mentioned in ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/main/notes/2021/2021-09-02.md",children:"2021-09-02 WG notes"})]})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsxs)(n.strong,{children:["Added to ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-wg/blob/main/agendas/2021/2021-08-05.md",children:"2021-08-05 WG agenda"})]})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/pull/879",children:"Spec PR"})," created"]})," on 2021-07-23 by mjmahone"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Commit pushed"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/commit/2447e944ab8c77b233e00afad2617b28ded9c694",children:"__fulfilled meta field"})," on 2021-07-23 by ",(0,i.jsx)(n.a,{href:"https://github.com/mjmahone",children:"@mjmahone"})]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.h1,{id:"proposal-add-a-__fulfilledlabel-string-boolean-meta-field",children:["Proposal: Add a ",(0,i.jsx)(n.code,{children:"__fulfilled(label: String): Boolean!"})," meta-field"]}),"\n",(0,i.jsxs)(n.p,{children:["This is currently a ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md#stage-0-strawman",children:"Stage 0: Strawman"})," proposal, but I'm including a PR with edits and a ",(0,i.jsx)(n.code,{children:"graphql-js"})," implementation such that this can get knocked down or advance to Stage 1 quickly. @mjmahone is currently championing this proposal."]}),"\n",(0,i.jsxs)(n.p,{children:["Implemented in ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-js/pull/3216",children:"graphql-js PR 3216"}),"."]}),"\n",(0,i.jsxs)(n.h2,{id:"details-add-the-below-after-41-type-introspection",children:["Details: Add the below after ",(0,i.jsx)(n.a,{href:"https://spec.graphql.org/draft/#sec-Type-Name-Introspection",children:"4.1: Type Introspection"})]}),"\n",(0,i.jsxs)(n.p,{children:["GraphQL supports the ability to introspect into whether any given selection was included in a response. When a selection is included, all of that selection's fields will be explicitly set, except those not executed due to a directive such as ",(0,i.jsx)(n.code,{children:"@include"})," or ",(0,i.jsx)(n.code,{children:"@skip"}),". Selection introspection is accomplished via the meta-field ",(0,i.jsx)(n.code,{children:"__fulfilled(label: String): Boolean!"})," on any Object, Interface, or Union. It always returns the value ",(0,i.jsx)(n.code,{children:"true"}),": ",(0,i.jsx)(n.code,{children:"__fulfilled"})," will be set if and only if the selection containing it is included in the response."]}),"\n",(0,i.jsx)(n.p,{children:"For example, given the operation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'query Q($foo: Boolean!) {\n  ... @include(if: $foo) {\n    included: __fulfilled(label: "user.included")\n  }\n  ... @skip(if: $foo) {\n    skipped: __fulfilled(label: "user.skipped")\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"The response should be either:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "included": true\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"or"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "skipped": true\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This meta-field is often used to clarify response interaction: as an example, the ",(0,i.jsx)(n.code,{children:"__fulfilled"})," field can be used as a way to tell the consumer whether a specific fragment was included in the response. The optional ",(0,i.jsx)(n.code,{children:"label"})," argument may be used to differentiate between ",(0,i.jsx)(n.code,{children:"__fulfilled"})," selections."]}),"\n",(0,i.jsxs)(n.p,{children:["As a meta-field, ",(0,i.jsx)(n.code,{children:"__fulfilled"})," is implicit and does not appear in the fields list in any defined type."]}),"\n",(0,i.jsxs)(n.p,{children:["Note: ",(0,i.jsx)(n.code,{children:"__fulfilled"})," may not be included as a root field in a subscription operation."]}),"\n",(0,i.jsx)(n.h2,{id:"end-spec-addition-discussion-continues-below",children:"End Spec Addition: Discussion continues below"}),"\n",(0,i.jsx)(n.h2,{id:"why",children:"Why?"}),"\n",(0,i.jsx)(n.p,{children:"I've discussed in the past about how Facebook is moving from product developers interacting with Response-shaped models that use inheritance such that any field in a selection set and all of its children are available. Instead, we try to use composition such that there is one model a product can interact with per selection set, and models need to explicitly convert (via a special conversion method) from parent to child selection sets."}),"\n",(0,i.jsxs)(n.p,{children:["For example, in combination with the ",(0,i.jsxs)(n.a,{href:"https://github.com/graphql/graphql-spec/blob/main/rfcs/DeferStream.md",children:[(0,i.jsx)(n.code,{children:"@defer"})," specification"]}),", when we have GraphQL that looks like:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"fragment UserWithName on User {\n  name\n  ...UserProfilePic @defer\n}\n\nfragment UserProfilePic on User {\n  name\n  profilePicture { \n    uri\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["An example of well-typed ",(0,i.jsx)(n.em,{children:"fragment"})," models for the user to interact with, in pseudo-typescript, might look like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"type UserWithName = {\n  name: string,\n  asUserProfilePic(): UserProfilePic | null,\n};\n\ntype UserProfilePic = {\n  name: string,\n  profilePicture: {\n      uri: string,\n  },\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this case, ",(0,i.jsx)(n.code,{children:"asUserProfilePic()"})," should return ",(0,i.jsx)(n.code,{children:"null"})," if ",(0,i.jsx)(n.code,{children:"UserProfilePic"})," has not yet been fulfilled in a response payload. Unfortunately, to determine that, we'd need to reach ",(0,i.jsx)(n.em,{children:"outside our local fragment"}),", and check the response's ",(0,i.jsx)(n.code,{children:"label"}),". Even that seems a bit buggy: what if ",(0,i.jsx)(n.code,{children:"UserWithName"})," is included in multiple locations in the operation's tree?"]}),"\n",(0,i.jsxs)(n.p,{children:["The cleanest solution I've thought through is having a well-defined boolean field inserted, at the location we care about, that will be true if and only if the selection set we care about is included in the response. Note, this solution applies not just to ",(0,i.jsx)(n.code,{children:"@defer"}),", but also to existing directives like ",(0,i.jsx)(n.code,{children:"@include"})," and ",(0,i.jsx)(n.code,{children:"@skip"}),", and could even enable simpler handling of type resolution. All a client needs to do to check whether a selection set was included, is to add something like ",(0,i.jsx)(n.code,{children:'Foo__fulfilled: __fulfilled(label: "Foo")'}),", and see if the response contains ",(0,i.jsx)(n.code,{children:"Foo_fulfilled: true"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"client-specific-considerations",children:"Client Specific Considerations"}),"\n",(0,i.jsxs)(n.p,{children:["On most of our clients today (including Relay), we parse data from the server into a Graph format: we merge every instance of a single unique record (usually as determined by a primary key's value like ",(0,i.jsx)(n.code,{children:"id"}),"), taking all fields requested across an entire operation (or many operations), and merge them into a locally consistent graph."]}),"\n",(0,i.jsxs)(n.p,{children:["However, ",(0,i.jsx)(n.em,{children:"product developers"})," interact with this local graph as though it is shaped like the ",(0,i.jsx)(n.strong,{children:"GraphQL selection sets"})," described by their operation and fragment definitions. Meaning even though the server response might look like:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "actor": {\n    "__typename": "OpenSourceContributor",\n    "name": "Matt",\n    "org": "GraphQL"\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["there may be a variety of fragments, with drastically different shapes, that describe how specific components ",(0,i.jsx)(n.em,{children:"use"})," that underlying response:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"fragment A on Viewer {\n  actor {\n    __typename\n    name\n    ...B @include(if: $use_b)\n    ... on Business @include(if: $use_business) {\n      org\n    }\n  }\n}\n\nfragment B on User {\n  org\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Just by looking at the ",(0,i.jsx)(n.em,{children:"structure"})," of the response, I ",(0,i.jsx)(n.strong,{children:"don't know"})," whether my component using A should have access to ",(0,i.jsx)(n.code,{children:"actor.org"}),": if both ",(0,i.jsx)(n.code,{children:"User"})," and ",(0,i.jsx)(n.code,{children:"Business"})," are interfaces, how can we tell whether this is the User's org or the Business' org? Or both?"]}),"\n",(0,i.jsxs)(n.p,{children:["Today, in order to determine whether ",(0,i.jsx)(n.code,{children:"org"})," is from ",(0,i.jsx)(n.code,{children:"fragment B"})," or ",(0,i.jsx)(n.code,{children:"... on Business"}),", we have clients that do one of:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Include a known type hierarchy in the client, and","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Check the boolean values for ",(0,i.jsx)(n.code,{children:"$use_b"})," and ",(0,i.jsx)(n.code,{children:"$use_business"})," sent with the original request"]}),"\n",(0,i.jsxs)(n.li,{children:["Check whether the concrete type ",(0,i.jsx)(n.code,{children:"OpenSourceContributor"})," is a ",(0,i.jsx)(n.code,{children:"User"})," or ",(0,i.jsx)(n.code,{children:"Business"})]}),"\n",(0,i.jsx)(n.li,{children:"NOTE: this is prone to dropping fields, as future concrete types are not known to implement any interfaces by the client."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Use the ",(0,i.jsx)(n.code,{children:"__typename"}),"-aliasing hack, and re-route aliased typenames to a client-only field for our local Graph."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"what-to-call-this-boolean-meta-field",children:"What to call this boolean meta-field?"}),"\n",(0,i.jsx)(n.p,{children:"I am open to bikeshedding here. Some alternatives:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"__exists"}),": the field is for figuring out whether a selection set exists, so this feels natural"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"__id"}),': it\'s almost a "selection set identity" function. This is probably ',(0,i.jsx)(n.strong,{children:"not"})," a good name, as it will clash with lots of other implementations where ",(0,i.jsx)(n.code,{children:"__id"}),' means "identifier" rather than the "identity function ',(0,i.jsx)(n.code,{children:"id(x: X): X"}),'".']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"isFulfilled"}),": this makes it clear we're using the field to answer a question. The downside is it's a camelCase'd meta-field, where many ",(0,i.jsx)(n.strong,{children:"implementations"})," use a snake_case style guide. I would greatly prefer a name that works well under either camelCase or snake_case paradigms"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"I am open to other suggestions!"}),"\n",(0,i.jsxs)(n.h2,{id:"alternative-1-just-use-__typename",children:["Alternative 1: Just use ",(0,i.jsx)(n.code,{children:"__typename"})]}),"\n",(0,i.jsxs)(n.p,{children:["Using ",(0,i.jsx)(n.code,{children:"__typename"})," is an option. However, because ",(0,i.jsx)(n.code,{children:"__typename"})," is of type ",(0,i.jsx)(n.code,{children:"String!"}),", it's a complicating option: the response is bloated with unnecessary information, and any infra that relies on this field needs to translate the response as a string to a boolean value, based on whether the key exists rather than the actual ",(0,i.jsx)(n.code,{children:"__typename"})," value."]}),"\n",(0,i.jsxs)(n.p,{children:["Concretely: it's much less error-prone to generate models that, under the hood, do boolean checking on boolean-returned values, rather than ",(0,i.jsx)(n.strong,{children:"requiring"})," either a field-existence check, or a string-exists-and-is-not-empty check (depending on client language)."]}),"\n",(0,i.jsxs)(n.p,{children:["Furthermore, if we are using a ",(0,i.jsx)(n.strong,{children:"normalized, canonical"})," store for our response data, as Relay and Apollo and other clients do, we need a ",(0,i.jsx)(n.em,{children:"special fulfilled field handler"})," just to make sure we don't ",(0,i.jsx)(n.em,{children:"accidentally"})," write ",(0,i.jsx)(n.code,{children:"is_Foo_fulfilled"})," to the canonical ",(0,i.jsx)(n.code,{children:"__typename"}),", and ask whether ",(0,i.jsx)(n.code,{children:"__typename"})," exists. Note, this is usually how we attempt to solve the problem today, and it has lead to actual bugs, hence this PR."]}),"\n",(0,i.jsxs)(n.p,{children:["With the ",(0,i.jsx)(n.code,{children:"__fulfilled(label:)"})," argument, the canonical version of the field can be used to differentiate unique selection sets, allowing the ",(0,i.jsx)(n.code,{children:"asUserProfilePic"})," implementation from the Why? section to become:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"  asUserProfilePic(): UserProfilePic | null {\n    if (_normalizedStoreRecord.getBoolean('__fulfilled(label:\"UserProfilePic\")')) {\n      return new UserProfilePic(_normalizedStoreRecord);\n    }\n    return null;\n  }\n"})}),"\n",(0,i.jsx)(n.h2,{id:"alternative-2-dont-use-a-meta-field-if-you-want-this-ability-explicitly-add-the-field-to-each-type-in-your-schema",children:"Alternative 2: Don't use a meta-field, if you want this ability explicitly add the field to each type in your schema"}),"\n",(0,i.jsxs)(n.p,{children:["We ",(0,i.jsx)(n.strong,{children:"could"})," do this, but then we can't use this field on Unions. Also, if a field exists on every type, it should probably be a meta-field."]}),"\n",(0,i.jsx)(n.h2,{id:"other-alternatives",children:"Other Alternatives"}),"\n",(0,i.jsx)(n.p,{children:"This is a straw man, so I'd be very interested in how other people solve this problem, and whether the above proposal would make their implementations better or be completely useless or harmful."}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>a});var i=t(7294);const s={},l=i.createContext(s);function a(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);