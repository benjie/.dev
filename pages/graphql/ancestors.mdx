---
type: page
title: 'Referencing Ancestors'
description: "Filtering by or comparing against ancestor objects in a field."
tag: graphql
author: Benjie
breadcrumb: false
sidebar_position: 6
draft: true
---

import { Tldr } from "@site/src/components/Tldr";
import { Pullquote } from "@site/src/components/Pullquote";

# Referencing Ancestors

<Tldr>

GraphQL's execution model does not give you a native way to reference ancestors
in field resolvers (only the parent is provided), and that's for good reason:
to do so would break normalized caching. GraphQL mimics [traversing a
graph](#graph-traversal) and the value of a node in the graph is
independent of the path you took to get to it.

</Tldr>

One of the common requests that I see in GraphQL is users wanting a way to query
an ancestor object from a descendant object. Let's take a look at the example in
[GraphQL spec issue #144](https://github.com/graphql/graphql-spec/issues/144#issue-133595212);
here's the schema:

```graphql
type Query {
  events: [Event]
}

type Event {
  id: String
  name: String
  speakers: [Speaker]
  talks: [Talk]
}

type Speaker {
  id: String
  name: String
  events: [Event]
  talks: [Talk]
}

type Talk {
  name: String
  speaker: Speaker
  event: Event
}
```

Now consider this query:


```graphql
query {
  events {
    name
    speakers {
      name
      talks {
        name
      }
    }
  }
}
```

The issue author would like to make it such that `>events>speakers>talks`
(using [operation
expressions](https://github.com/graphql/graphql-wg/blob/main/rfcs/OperationExpressions.md)
format) returns the list of talks that the speaker has in the current event. At
first glance, this might seem like a reasonable ask... But as we think about
the rules in the GraphQL spec and how clients have come to rely on these rules,
we'll discover why this isn't so.
