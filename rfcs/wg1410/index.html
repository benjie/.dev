<!doctype html>
<html lang="en-GB" dir="ltr" class="docs-wrapper plugin-docs plugin-id-rfcs docs-version-current docs-doc-page docs-doc-id-wg1410" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.0">
<title data-rh="true">Strict Semantic Nullability | benjie.dev</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://benjie.dev/rfcs/wg1410"><meta data-rh="true" property="og:locale" content="en_GB"><meta data-rh="true" name="docusaurus_locale" content="en-GB"><meta data-rh="true" name="docsearch:language" content="en-GB"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-rfcs-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-rfcs-current"><meta data-rh="true" property="twitter:title" content="Strict Semantic Nullability | benjie.dev"><meta data-rh="true" property="og:title" content="Strict Semantic Nullability | benjie.dev"><meta data-rh="true" name="description" content="At a glance"><meta data-rh="true" property="og:description" content="At a glance"><meta data-rh="true" property="og:image" content="https://benjie.dev/img/rfc_tracker.png"><meta data-rh="true" name="twitter:image" content="https://benjie.dev/img/rfc_tracker.png"><link data-rh="true" rel="icon" href="/favicon.ico"><link data-rh="true" rel="canonical" href="https://benjie.dev/rfcs/wg1410"><link data-rh="true" rel="alternate" href="https://benjie.dev/rfcs/wg1410" hreflang="en-GB"><link data-rh="true" rel="alternate" href="https://benjie.dev/rfcs/wg1410" hreflang="x-default"><script src="https://assets.calendly.com/assets/external/widget.js"></script><link rel="stylesheet" href="/assets/css/styles.c47278a5.css">
<script src="/assets/js/runtime~main.bad2c297.js" defer="defer"></script>
<script src="/assets/js/main.38e2f530.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/avatar.jpg" alt="benjie" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/avatar.jpg" alt="benjie" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">benjie.dev</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/rfcs/">RFCs</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/book">📞 Book a call</a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/rfcs/">GraphQL RFC Tracker</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/rfcs/activity">Activity</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/rfcs/525">Stage 3: Accepted</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="true" href="/rfcs/793">Stage 2: Draft</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/793">793*: Default value coercion rules [RFC2]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/825">825*: OneOf Input Objects [RFC2]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/860">860*: Prevent @skip and @include on root subscription selection set [RFC2]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/976">976*: Add &#x27;extensions&#x27; to request [RFC2]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/1053">1053*: Implementations may not deprecate a field that the interface hasn&#x27;t deprecated [RFC2]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/1063">1063*: Type system ordering of: object interfaces, directive arguments, input object fields, enum values [RFC2]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/1092">1092*: Recommend that order of unordered collections is maintained where possible [RFC2]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/1102">1102*: Define Data Collections used in the spec [RFC2]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/1081">1081: Fragment arguments/variables (syntax/validation/execution) [RFC2]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/794">794: Schema Coordinates [RFC2]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/955">955: Add validation rule that operation types exist [RFC2]</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="true" href="/rfcs/1142">Stage 1: Proposal</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/1142">1142: make `includeDeprecated` non nullable [RFC1]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/1058">1058*: List coercion algorithm [RFC1]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/1056">1056*: Fix CoerceArgumentValues() hasValue [RFC1]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/1110">1110: Incremental Delivery spec draft [RFC1]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/1127">1127*: When `sourceStream` errors, yield a `{ errors: [...] }` response [RFC1]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/997">997: Expand @deprecated to Objects [RFC1]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/1059">1059*: Introduce Strict and Legacy All Variable Usages Are Allowed [RFC1]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/950">950: allow unions to include interfaces and unions [RFC1]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/939">939: allow unions to declare implementation of interfaces [RFC1]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/907">907: Add support for directives on directives [RFC1]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/892">892: Add descriptions to executable definitions [RFC1]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/509">509: Allow singular variables in list locations [RFC1]</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/rfcs/1050">Stage 0: Strawman</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/1050">1050*: Directive proposal for opting out of null bubbling [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/1065">1065*: SemanticNonNull type (null only on error) [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/SemanticNullability">SemanticNullability: Semantic Nullability [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/ClientControlledNullability">ClientControlledNullability: Client Controlled Nullability [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/1114">1114: add __directive meta field parallel to __type [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/1057">1057*: Fix coercion table for list [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/DeferStream">DeferStream: GraphQL Defer and Stream Directives [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/SchemaCoordinates">SchemaCoordinates: Schema Coordinates [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/InputUnion">InputUnion: GraphQL Input Union [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/FeatureDiscovery">FeatureDiscovery: Feature Discovery [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/Struct">Struct: Polymorphic-capable composite symmetric input/output type (`struct`) [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/1049">1049: Introduce SourceSchemaDocument and FullSchemaDocument [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/rfcs/wg1410">wg1410: Strict Semantic Nullability [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/wg1394">wg1394: True Nullability Schema [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/1045">1045*: Remove fragmentSpreadName from visitedFragments when visit is complete [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/FullSchemas">FullSchemas: Full Schemas [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/1015">1015: &quot;Root&quot; Types clarity → &quot;Operation Type&quot; [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/FragmentArguments">FragmentArguments: Fragment Arguments [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/wg1239">wg1239: Fragment Arguments: RFC + Implementation Details [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/998">998: add spec edits for references [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/OptInFeatures">OptInFeatures: Opt-in features [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/ExpandingSubtyping">ExpandingSubtyping: Expanding Subtyping (for output types) [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/AnnotationStructs">AnnotationStructs: Annotation Structs [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/MetadataStructs">MetadataStructs: Metadata Structs [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/wg1096">wg1096: &quot;Metadata Directives&quot; Proposal [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/CompositeSchemas">CompositeSchemas: GraphQL Composite Schemas [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/wg1071">wg1071*: Struct type [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/673">673: Servers must preserve lexical ordering between SDL and introspection [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/948">948*: OneOf Objects [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/wg944">wg944: New Intersection Type [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/wg857">wg857: Fragment Modularity [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/FragmentModularity">FragmentModularity: Fragment Modularity [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/wg815">wg815: Nested GraphQL Mutations [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/ImplicitInheritance">ImplicitInheritance: Implicit Inheritance [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/OperationExpressions">OperationExpressions: Operation Expressions [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/SchemaFragments">SchemaFragments: Schema Fragments [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/879">879: __fulfilled meta field [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/Subscriptions">Subscriptions: NOTE: this document is kept for historic purposes; GraphQL Subscriptions have been specified and released as part of the official [June 2018 GraphQL Specification](https://spec.graphql.org/June2018/). [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/710">710: Add namedType and punctuatedName to __Type [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/706">706: Add support for directives for an object field name [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/674">674: allow empty selections [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/631">631: Make root query operation type optional [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/567">567: allow directives on directive definitions [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/556">556: Document Directives [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/521">521: Scalar serialize as built-in scalar type [RFC0]</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/rfcs/325">325: Add &quot;Any&quot; scalar type [RFC0]</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/rfcs/1091">Stage X: Rejected</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Strict Semantic Nullability</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="at-a-glance">At a glance<a href="#at-a-glance" class="hash-link" aria-label="Direct link to At a glance" title="Direct link to At a glance">​</a></h2>
<ul>
<li><strong>Identifier</strong>: wg#1410</li>
<li><strong>Stage</strong>: <a href="https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md#stage-0-strawman" target="_blank" rel="noopener noreferrer">RFC0: Strawman</a></li>
<li><strong>Champion</strong>: <a href="https://github.com/leebyron" target="_blank" rel="noopener noreferrer">@leebyron</a></li>
<li><strong>PR</strong>: -</li>
<li><strong>Related</strong>:<!-- -->
<ul>
<li><a title="Null-Only-On-Error / Semantically-Non-Null type (asterisk) / RFCX" href="/rfcs/1048">#1048</a> (Null-Only-On-Error / Semantically-Non-Null type (asterisk))</li>
<li><a title="SemanticNonNull type (null only on error) / RFC0" href="/rfcs/1065">#1065</a> (SemanticNonNull type (null only on error))</li>
<li><a title="Be strict about error paths format / RFC3" href="/rfcs/1073">#1073</a> (Be strict about error paths format)</li>
<li><a title="Semantic Nullability / RFC0" href="/rfcs/SemanticNullability">SemanticNullability</a> (Semantic Nullability)</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="timeline">Timeline<a href="#timeline" class="hash-link" aria-label="Direct link to Timeline" title="Direct link to Timeline">​</a></h2>
<ul>
<li><strong><a href="https://github.com/graphql/graphql-wg/discussions/1410" target="_blank" rel="noopener noreferrer">WG discussion</a> created</strong> on 2023-10-05 by leebyron</li>
</ul>
<hr>
<blockquote>
<p>This is a follow up to #1394 based on a discussion in the Oct 2023 WG meeting.</p>
<hr>
<h1>Future of nullability in GraphQL is strict semantic nullability.</h1>
<p><strong>High level overview:</strong></p>
<ul>
<li>We introduce the concept of a &quot;Semantically Nullable&quot; type modifier <code>?</code> which describes a type as strictly allowing return of semantic null values.</li>
<li>We introduce a schema directive <code>@strictNullability</code> to resolve how to interpret <code>null</code> values.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="graphql-nullability-historical-rationale">GraphQL nullability historical rationale<a href="#graphql-nullability-historical-rationale" class="hash-link" aria-label="Direct link to GraphQL nullability historical rationale" title="Direct link to GraphQL nullability historical rationale">​</a></h2>
<p>GraphQL field types default to being nullable with a modifier <code>!</code> to indicate non-nullability. Why?</p>
<p>First, we want to preserve future evolution of schema. It’s often the case that when first designing schemas that nullability and changes to it over time aren’t deeply considered. It turns out that it’s safe to convert a nullable field to a non-nullable one, but not the other way around. Thus the default is nullable. Defaults matter, and GraphQL’s default prioritizes allowing for future change.</p>
<blockquote>
<p><strong>Callout on safe field type changes</strong></p>
<p>A field type change is &quot;safe&quot; when the new type describes a &quot;subset&quot; of the previous type. Changing <code>Dog</code> to <code>Pet</code> is not safe because a historical client made assumptions about <code>Dog</code> values, and won&#x27;t know what to do with a <code>Bird</code>. Changing from <code>Pet</code> to <code>Dog</code> is safe because historical clients are ready to handle any <code>Pet</code>, and won&#x27;t be surprised by exclusively receiving <code>Dog</code> values. Similarly changing <code>String!</code> to <code>String</code> is not safe because a historical client is not ready to accept <code>null</code> and might <a href="https://en.wikipedia.org/wiki/Null_pointer#:~:text=Because%20a%20null%20pointer%20does,is%20the%20null%20pointer%20error." target="_blank" rel="noopener noreferrer">NPE</a>. Changing <code>String</code> to <code>String!</code> is safe because the historical client was ready to accept <code>null</code> and just will happen to no longer ever receive one.</p>
</blockquote>
<p>Second, we want to assume that anything can fail anywhere, and minimize disruption. A GraphQL field may be resolved by connecting to a service, and if that fails, a null is returned in the result (and also the error is included alongside the data in the response as well). Using the non-null modifier demands that field never returns null such that if an error occurs during resolution that it “bubbles” to instead have the parent field return null. This is nice in that it provides a strict guarantee of non-nullability, but not nice in that it’s destructive and that sibling fields which may have resolved normally are disposed as a result. As a result we provide guidance to use non-null <code>!</code> types sparingly.</p>
<p>A very specific example covering both of these two reasons is considering what happens as a system evolves. Perhaps at first you have a simple application monolith with a single DB. A table column is non nullable so you imagine the resulting GraphQL field isn’t nullable either. However in the future you build a dedicated service for a subset of that table, and now resolving that field could fail to reach the service and result in null. A future change to architecture created the possibility for error, and thus null.</p>
<p>Implicit in this understanding of nullability is that a field type does not make it possible to differentiate between interpreting a null value as “this field is actually the value <code>null</code>” or “this field encountered an error and we have no data to return”. Ideally we can differentiate this both in the Schema, to describe which of these two interpretations are possible, and in the response, to describe which of the two interpretations has occurred for that specific resolution.</p>
<p>Or put more candidly: a GraphQL field is not actually &quot;nullable&quot;, it is <em>&quot;ambiguously nullable&quot;</em>. Ambiguity hurts!</p>
<blockquote>
<p><strong>Callout on terminology for null in GraphQL</strong></p>
<ul>
<li><em>Semantic null:</em> A <code>null</code> value returned which describes the actual value of the field.</li>
<li><em>Error null:</em> A <code>null</code> value returned which describes an error state.</li>
<li><em>Ambiguous null:</em> A <code>null</code> value returned which describes one of the above two states without a way to differentiate which is the case.</li>
</ul>
</blockquote>
<p>The specific way this hurts is that clients must be able to differentiate between these two cases. First (schema) to generate useful type definitions, where the ambiguity requires us to generate nullable types everywhere, which is awful ergonomics. Then (result) to know whether to interpret a null value as a semantic null or handle it as an error null. Today clients must look in the <code>&quot;errors&quot;</code> part of the result to see if an error exists at that field, but how to interpret the <em>absence</em> of an error isn’t clear if it isn’t known if semantic null type was allowed in the first place.</p>
<p>So where do we go from here? How do we resolve this ambiguity?</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="annotate-semantic-nullability-">Annotate semantic nullability: <code>?</code><a href="#annotate-semantic-nullability-" class="hash-link" aria-label="Direct link to annotate-semantic-nullability-" title="Direct link to annotate-semantic-nullability-">​</a></h2>
<p>Today we can describe a field’s type normally <code>field: String</code> or use a non-nullable type modifier, <code>field: String!</code>.</p>
<p>I propose introducing a &quot;semantically nullable&quot; modifier: <code>field: String?</code> (referring to this now as &quot;nullable&quot; to be terse).</p>
<p>If a field type is nullable (<code>String?</code>), that means that null values are in fact semantically allowed. For a client to know the difference between semantic null vs an error, they can now confidently look to the errors result. If an error exists in the array for this field then the null was the result of an error, and if not then it is in fact a semantic null.</p>
<p>This leaves an unmodified type (<code>String</code>) remaining as “ambiguously null”.</p>
<blockquote>
<p><strong>Callout on exact type definitions</strong></p>
<ul>
<li><code>Type! → Type</code> (no null values allowed)</li>
<li><code>Type? → Type | SemanticNull | ErrorNull</code> (differentiation must be possible)</li>
<li><code>Type → Type | AmbiguousNull</code> (differentiation isn&#x27;t always possible)</li>
</ul>
</blockquote>
<p>Now we have a way to describe some fields as specifically allowing semantic null and we have a mechanism (errors result) to differentiate that from an error null.</p>
<p>Now that a nullable modifier exists, to make this truly useful, we would next want to interpret unmodified <code>field: Type</code> as “null only on error” (<a href="https://github.com/graphql/graphql-spec/pull/1048/files" target="_blank" rel="noopener noreferrer">related RFC</a>) and resolve the ambiguity. How can we do this this safely, in a backwards compatible way?</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="a-strict-nullability-schema">A strict nullability schema<a href="#a-strict-nullability-schema" class="hash-link" aria-label="Direct link to A strict nullability schema" title="Direct link to A strict nullability schema">​</a></h2>
<p>The schema can next include a directive (exposed as a new boolean in introspection) called <code>@strictNullability</code>. This directive tells clients that they should interpret unmodified field types (<code>field: String</code>) as semantic null not being a valid value and that any null value in a the data result should be interpreted as a field error, regardless of whether the error portion of the result includes an entry for that field.</p>
<blockquote>
<p><strong>Callout on exact type definition when <code>@strictNullability</code> is set</strong></p>
<ul>
<li><code>Type! → Type</code> (no null values allowed)</li>
<li><code>Type? → Type | SemanticNull | ErrorNull</code> (differentiation must be possible)</li>
<li><code>Type → Type | ErrorNull</code> (differentiation unnecessary)</li>
</ul>
</blockquote>
<p>With both changes in effect, a schema has removed ambiguous null as a potential result from the service overall. Clients know the types possible in the schema and can interpret and differentiate the result accordingly.</p>
<p><strong><em>Edit: added after @benjie&#x27;s feedback below</em></strong></p>
<p>Additionally, the introduction of <code>@strictNullability</code> now <em>requires</em> that an error is included in the error list if an unmodified <code>field: Type</code> returns null. It will do this by changing the execution behavior through the same mechanism as NonNull types in <a href="http://spec.graphql.org/draft/#sec-Value-Completion" target="_blank" rel="noopener noreferrer">Value Completion</a>. Importantly, these errors would not bubble.</p>
<p>Execution behavior (value completion) does not change for nullable types (<code>Type?</code>) since null continues to be allowed.</p>
<p>This means that execution behavior could change in a subtle manner. The result of the <code>&quot;data&quot;</code> field will remain unchanged (what was a null, remains a null), however the <code>&quot;errors&quot;</code> list could appear in some responses it previously did not. This could potentially be breaking when sending responses to a client which discards responses that include any error (unfortunately common for older clients).</p>
<p><em>Here is the specific case of this scenario explained via an example:</em></p>
<p>A field returns a value which is not meant to be semantically nullable, however the resolver is known to fail often. This service knows it has a client which throws out responses that include field errors, so it does not raise a field error from the resolver even though that would have been the semantically correct thing to do. Because the field is known fails often and the service decides that failure is not a big deal and they would like the client to use the rest of the data, they simply return null to indicate failure instead. While this is semantically incorrect, it produced the outcome they were looking for.</p>
<p>When migrating an existing service to <code>@strictNullability</code> that also needs to preserve backwards compatibility for clients which discard full responses if there are any errors, fields that return <code>null</code> to indicate an error should be typed as <code>Type?</code> instead of <code>Type</code> - they should be declared nullable, since that is an accurate typing of the schema design choice that was made.</p>
<p><strong><em>End Edit</em></strong></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="how-to-adopt-this-incrementally">How to adopt this incrementally?<a href="#how-to-adopt-this-incrementally" class="hash-link" aria-label="Direct link to How to adopt this incrementally?" title="Direct link to How to adopt this incrementally?">​</a></h2>
<p>For existing schemas adopting this feature, they will be in an incremental state where &quot;semantically nullable&quot; modifiers (<code>?</code>) are incrementally added to resolve some ambiguity, and in this state the schema does not yet apply <code>@strictNullability</code>.</p>
<p>Once this migration is complete and a service has added all true semantically nullable modifiers to field types, then the <code>@strictNullability</code> directive is added.</p>
<p><em>Alternative incremental migration strategy</em></p>
<p>First, convert <em>all field types</em> to Nullable and apply <code>@strictNullability</code> at the same time, then incrementally remove the Nullable types from fields which are known to never be nullable.</p>
<p>While uglier, this would be safer for avoiding breaking changes if a service is unsure what values are possibly returned and concerned about the impact of introducing new field errors.</p>
<p>In the duration between a client beginning to use nullable type modifiers but before applying <code>@strictNullability</code>, clients can decide how to use code generation and result interpretation. Either:</p>
<ul>
<li>A. Ignore the nullable type modifiers and see no change.</li>
<li>B. Unsafely assume &quot;strictNullability&quot; is enabled and accept the risk of being wrong.</li>
<li>C. Assume strict nullability in a locally incremental way by annotating each fragment for strict nullability typegen and interpretation in coordination with rolling out the nullable types on the service/schema side.</li>
</ul>
<p>Most will do A, and that&#x27;s fine - it&#x27;s the preferred path if the migration will be quick and they prefer to just look ahead. Some will do B, and that&#x27;s fine for small or high-communication teams where you can trust the wrongness risk. Relay and other sophisticated clients will do C, where they allow large teams to adopt this over time.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="lets-look-at-the-effects-does-this-break-things">Let’s look at the effects. Does this break things?<a href="#lets-look-at-the-effects-does-this-break-things" class="hash-link" aria-label="Direct link to Let’s look at the effects. Does this break things?" title="Direct link to Let’s look at the effects. Does this break things?">​</a></h2>
<p>Say a historical schema with many clients has now adopted nullable types and the @strictNullable modifier, what happens to backwards and forwards compatibility?</p>
<p>First of all, new clients no longer see “ambiguous” nulls. The schema now describes if a null is or is not semantically a valid value from the schema’s field type, and we know how to differentiate semantic null from error null (either because <code>Type</code> where null definitionally indicates an error, or <code>Type?</code> where if an error result for the field exists it is an error null, otherwise it is semantic null).</p>
<p><strong><em>Edit after @benjie&#x27;s comment</em></strong></p>
<p>Even without knowledge of the schema, a client can accurately use the <code>&quot;errors&quot;</code> list in the response to know which null values represent errors and which are values, since an <em>error null</em> is always accompanied by an error in the list.</p>
<p>The application of <code>@strictNullability</code> is potentially breaking in an edge case that can be mitigated by use of Nullable types. Execution results are always unchanged for the <code>&quot;data&quot;</code> response, any client which exclusively looks at this part of the response will see no change at all. After applying <code>@strictNullability</code> unmodified types must include an error in the list for a null value. Clients which consider <code>&quot;errors&quot;</code> in the response could see new errors if a service was invalidly returning null from a field not marked nullable.</p>
<p><del>Historical clients are unchanged because critically <em>this has not changed the way the executor works in any way</em>. No field which used to return a null value no longer does or vice versa. No new errors are being emitted in the errors result. Error handling behavior is unchanged. This has <em>exclusively</em> changed the schema to be more descriptive in how to interpret existing results.</del></p>
<p><del>An important subtle point is that a <code>@strictNullability</code> service may return a null value from an unmodified field type <em>without a resulting error payload</em>. Modern clients now know to interpret this as the field failing to resolve an error (<em>error null</em>) and not a <em>semantic null</em>. Historical clients will continue to interpret this as <em>ambiguous null</em>. Introducing a new error payload where there wasn&#x27;t one previously would have been unsafe. Some clients throw out any result payload with any error. (Wat?! See the FAQ below)</del></p>
<p><strong><em>End edit</em></strong></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="what-about-forward-compatibility">What about forward compatibility?<a href="#what-about-forward-compatibility" class="hash-link" aria-label="Direct link to What about forward compatibility?" title="Direct link to What about forward compatibility?">​</a></h2>
<p>In a <code>@strictNullability</code> service/schema, you might still begin by introducing a field with an unmodified type <code>field: Type</code>, and while it&#x27;s still true that later changing this to <code>field: Type!</code> remains safe, once a schema is strict, later changing this to <code>field: Type?</code> is in fact not safe.</p>
<p>However, I am less concerned about this for two reasons:</p>
<ol>
<li>
<p>The primary reason schema designers are tripped up by this forward compat issue is not missing semantic null, it&#x27;s missing error null. They fail to anticipate future changes in their underlying architecture introducing new places for errors to occur, and this proposal includes error nulls as a possibility in the default unmodified type.</p>
</li>
<li>
<p>Given the proliferation of type-safe languages today (not the case in 2012) it&#x27;s likely that strict nullability is a first class​ design consideration for anyone with this directive enabled. If it&#x27;s not, well then this is an opt-in directive and this schema design &quot;footgun&quot; is at least one that schema owners are opting themselves into rather than being surprised by. The default without-directive state will remain <code>Type → Type | AmbiguousNull</code>, which remains fine for less sophisticated services and clients.</p>
</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="faq-should-we-then-continue-to-suggest-use-of-nonnull-">FAQ: Should we then continue to suggest use of NonNull (<code>!</code>)?<a href="#faq-should-we-then-continue-to-suggest-use-of-nonnull-" class="hash-link" aria-label="Direct link to faq-should-we-then-continue-to-suggest-use-of-nonnull-" title="Direct link to faq-should-we-then-continue-to-suggest-use-of-nonnull-">​</a></h2>
<p>Yes, but far less often. It&#x27;s still used sparingly but it implies something which the service guarantees will never produce a null, including an error null. That&#x27;s still useful in some scenarios (obj identifiers).</p>
<p>But generally most will use this a lot less with a more familiar <code>?</code> available to them.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="faq-how-is-it-okay-for-a-strictnullability-field-to-return-null-without-a-matching-error-in-the-errors-array"><del>FAQ: How is it okay for a <code>@strictNullability</code> field to return <code>null</code> without a matching error in the <code>&quot;errors&quot;</code> array?</del><a href="#faq-how-is-it-okay-for-a-strictnullability-field-to-return-null-without-a-matching-error-in-the-errors-array" class="hash-link" aria-label="Direct link to faq-how-is-it-okay-for-a-strictnullability-field-to-return-null-without-a-matching-error-in-the-errors-array" title="Direct link to faq-how-is-it-okay-for-a-strictnullability-field-to-return-null-without-a-matching-error-in-the-errors-array">​</a></h2>
<p><strong>EDIT: This section no longer applies, but leaving here for posterity</strong></p>
<p>Currently, a field returning an <em>ambiguous null</em> could mean one of three things:</p>
<ul>
<li>There is a matching error in the <code>&quot;errors&quot;</code> array response, therefore it is certainly the result of an error.</li>
<li>Otherwise there is not an matching error - what does that mean?<!-- -->
<ul>
<li>If the intent was that this field should in fact allow semantic null values, then that&#x27;s <em>probably</em> what this meant, but we have no way to know for absolute certain since the Schema can&#x27;t yet declare whether <em>semantic null</em> is a possible expected value (the goal of this proposal!)</li>
<li>Otherwise this could be the result of a failure to load the data that&#x27;s just missing an matching error.</li>
</ul>
</li>
</ul>
<p>Wait, what? How is a missing matching error possibly spec compliant?</p>
<p>According to the section on <a href="http://spec.graphql.org/draft/#sec-Handling-Field-Errors" target="_blank" rel="noopener noreferrer">Handling Field Errors</a> if a field error occurs then an error <em>must</em> be added to the errors list. This could happen because the resolver simply failed (threw Exception, return Result&lt;Error&gt;, etc), it could also happen because it returned a value that failed to coerce (was the wrong type, null for a Non-Null modifier, etc). This all implies that if a field failed to return the wrong type of value or failed to return at all that it is a <em>field error</em> and thus must have an error entry.</p>
<p>So how could this a field returning an <em>error null</em> not have a matching error in the list? Well, the field resolver happened to simply return <code>null</code>, which is totally allowed by the executor and schema. It did this not because <em>semantic null</em> was the right value, but just because services are weird sometimes and this is how they decided to represent a failure condition. And this is allowed... and ambiguous 🤷</p>
<p>So what do we do about this? We have two options:</p>
<p><strong>Option A: A <code>@strictNullability</code> service always produces an error for nulls</strong></p>
<p>We amend <a href="http://spec.graphql.org/draft/#sec-Value-Completion" target="_blank" rel="noopener noreferrer">Value Completion</a> so that in strict mode such that if a resolver returns <code>null</code>, and it isn&#x27;t explicitly a <code>Nullable</code> type, then we throw a field error.</p>
<p>Pros:</p>
<ul>
<li>Asserts that the resolver returns a correctly typed value, and when it does not (because <code>null</code> we assume is semantic null and not valid for a strict unmodified <code>field: Type</code>)</li>
<li>Guarantees that every <em>error null</em> has an matching error in the errors list.</li>
</ul>
<p>Cons:</p>
<ul>
<li>It&#x27;s <em>potentially</em> breaking.</li>
</ul>
<p>This introduces a new error which didn&#x27;t exist before. Since lots of historical clients decided to simply reject any result which had an <code>&quot;errors&quot;</code> and try again, it&#x27;s entirely possible that the service had made this strange choice not because they didn&#x27;t know better, but because they considered the failure non-fatal and safe to omit the value. If they had thrown an error instead the client would have treated it too seriously and thrown out the whole thing. This was unfortunately a common pattern for a long time.</p>
<p>This breaking change can be mitigated, but only with careful guidance! Since the directive isn&#x27;t applied by default, adding this to the spec is definitely not breaking. BUT you can&#x27;t simply add the directive and expect no breaking changes! You must first move every field resolver that <em>returns null</em> to be a Nullable type! If that is true, then adding the directive introduces no change and no thus no breakage.</p>
<p><strong>Option B: Do nothing.</strong></p>
<p>No changes to the executor at all. Existing behavior persists.</p>
<p>Pros:</p>
<ul>
<li>It&#x27;s not breaking!</li>
<li>It sure is easy to implement</li>
</ul>
<p>Cons:</p>
<ul>
<li>It allows this non-obvious behavior to continue, and specifically means that in the case of an <em>error null</em> you&#x27;re not guaranteed to have more information describing why. This is particularly bad for clients which seek to interpret error null vs semantic null in their response parsers without requiring knowledge of the schema.</li>
</ul>
<p>Had we been starting from scratch, I&#x27;d definitely do option A (and I&#x27;d also not make strict mode, I&#x27;d just have done this from the start - agreeing with @dschafer&#x27;s comment below). The guarantee of having error info is strictly better, and we&#x27;d just have built better clients.</p>
<p>But alas, I think our <a href="https://github.com/graphql/graphql-spec/blob/main/CONTRIBUTING.md#guiding-principles" target="_blank" rel="noopener noreferrer">Guiding Principles</a> point us to option B.</p>
<p>Also, while the spec can choose to do nothing, GraphQL libraries and services can always choose to be stricter than the spec itself. We&#x27;ve left plenty of room in allowing resolvers to be a <a href="http://spec.graphql.org/draft/#sel-HANTJHCBCAACCZhrR" target="_blank" rel="noopener noreferrer">&quot;internal function&quot;</a> for GraphQL libraries to decide what is best.</p>
<p>I would be totally comfortable with a non-normative note in the spec suggesting that GraphQL libraries may choose option A, but for historical reasons we don&#x27;t enforce it and it&#x27;s still spec compliant to not.</p>
<p>Also, I suspect the cost of not having an error in the list guarantee is quite low. In <code>@strictNullability</code> we don&#x27;t need it to know that a field has in fact failed. If a client wanted to get this guarantee back they could always fill in the gaps and produce a generic error locally that says something akin to &quot;this field unexpectedly returned null&quot;</p>
</blockquote></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/rfcs/1049"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Introduce SourceSchemaDocument and FullSchemaDocument</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/rfcs/wg1394"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">True Nullability Schema</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#at-a-glance" class="table-of-contents__link toc-highlight">At a glance</a></li><li><a href="#timeline" class="table-of-contents__link toc-highlight">Timeline</a></li><li><a href="#graphql-nullability-historical-rationale" class="table-of-contents__link toc-highlight">GraphQL nullability historical rationale</a></li><li><a href="#annotate-semantic-nullability-" class="table-of-contents__link toc-highlight">Annotate semantic nullability: <code>?</code></a></li><li><a href="#a-strict-nullability-schema" class="table-of-contents__link toc-highlight">A strict nullability schema</a></li><li><a href="#how-to-adopt-this-incrementally" class="table-of-contents__link toc-highlight">How to adopt this incrementally?</a></li><li><a href="#lets-look-at-the-effects-does-this-break-things" class="table-of-contents__link toc-highlight">Let’s look at the effects. Does this break things?</a></li><li><a href="#what-about-forward-compatibility" class="table-of-contents__link toc-highlight">What about forward compatibility?</a></li><li><a href="#faq-should-we-then-continue-to-suggest-use-of-nonnull-" class="table-of-contents__link toc-highlight">FAQ: Should we then continue to suggest use of NonNull (<code>!</code>)?</a></li><li><a href="#faq-how-is-it-okay-for-a-strictnullability-field-to-return-null-without-a-matching-error-in-the-errors-array" class="table-of-contents__link toc-highlight"><del>FAQ: How is it okay for a <code>@strictNullability</code> field to return <code>null</code> without a matching error in the <code>&quot;errors&quot;</code> array?</del></a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 Benjie Gillam; all rights reserved. RFC pages pull content from public GitHub issues/PRs/files/etc; this content remains owned its various authors.</div></div></div></footer></div>
</body>
</html>